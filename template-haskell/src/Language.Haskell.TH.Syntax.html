<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621679195582"><span id="local-6989586621679195583"><span id="local-6989586621679195584"><span id="local-6989586621679195585"><span id="local-6989586621679195586"><span id="local-6989586621679195587"><span id="local-6989586621679195588"><span id="local-6989586621679195589"><span id="local-6989586621679195590"><span id="local-6989586621679195591"><span id="local-6989586621679195592"><span id="local-6989586621679195593"><span id="local-6989586621679195594"><span id="local-6989586621679195595"><span id="local-6989586621679195596"><span id="local-6989586621679195597"><span id="local-6989586621679195598"><span id="local-6989586621679195599"><span id="local-6989586621679195600"><span id="local-6989586621679195601"><span id="local-6989586621679195602"><span id="local-6989586621679195603"><span id="local-6989586621679195604"><span id="local-6989586621679195605"><span id="local-6989586621679195606"><span id="local-6989586621679195607"><span id="local-6989586621679195608"><span id="local-6989586621679195609"><span id="local-6989586621679195610"><span id="local-6989586621679195611"><span id="local-6989586621679195612"><span id="local-6989586621679195613"><span id="local-6989586621679195614"><span id="local-6989586621679195615"><span id="local-6989586621679195616"><span id="local-6989586621679195617"><span id="local-6989586621679195618"><span id="local-6989586621679195619"><span id="local-6989586621679195620"><span id="local-6989586621679195621"><span id="local-6989586621679195622"><span id="local-6989586621679195623"><span id="local-6989586621679195624"><span id="local-6989586621679195625"><span id="local-6989586621679195626"><span id="local-6989586621679195627"><span id="local-6989586621679195628"><span id="local-6989586621679195629"><span id="local-6989586621679195630"><span id="local-6989586621679195631"><span id="local-6989586621679195632"><span id="local-6989586621679195633"><span id="local-6989586621679195634"><span id="local-6989586621679195635"><span id="local-6989586621679195636"><span id="local-6989586621679195637"><span id="local-6989586621679195638"><span id="local-6989586621679195639"><span id="local-6989586621679195640"><span id="local-6989586621679195641"><span id="local-6989586621679195642"><span id="local-6989586621679195643"><span id="local-6989586621679195644"><span id="local-6989586621679195645"><span id="local-6989586621679195646"><span id="local-6989586621679195647"><span id="local-6989586621679195648"><span id="local-6989586621679195649"><span id="local-6989586621679195650"><span id="local-6989586621679195651"><span id="local-6989586621679195652"><span id="local-6989586621679195653"><span id="local-6989586621679195654"><span id="local-6989586621679195655"><span id="local-6989586621679195656"><span id="local-6989586621679195657"><span id="local-6989586621679195658"><span id="local-6989586621679195659"><span id="local-6989586621679195660"><span id="local-6989586621679195661"><span id="local-6989586621679195662"><span id="local-6989586621679195663"><span id="local-6989586621679195664"><span id="local-6989586621679195665"><span id="local-6989586621679195666"><span id="local-6989586621679195667"><span id="local-6989586621679195668"><span id="local-6989586621679195669"><span id="local-6989586621679195670"><span id="local-6989586621679195671"><span id="local-6989586621679195672"><span id="local-6989586621679195673"><span id="local-6989586621679195674"><span id="local-6989586621679195675"><span id="local-6989586621679195676"><span id="local-6989586621679195677"><span id="local-6989586621679195678"><span id="local-6989586621679195679"><span id="local-6989586621679195680"><span id="local-6989586621679195681"><span id="local-6989586621679195682"><span id="local-6989586621679195683"><span id="local-6989586621679195684"><span id="local-6989586621679195685"><span id="local-6989586621679195686"><span id="local-6989586621679195687"><span id="local-6989586621679195688"><span id="local-6989586621679195689"><span id="local-6989586621679195690"><span id="local-6989586621679195691"><span id="local-6989586621679195692"><span id="local-6989586621679195693"><span id="local-6989586621679195694"><span id="local-6989586621679195695"><span id="local-6989586621679195696"><span id="local-6989586621679195697"><span id="local-6989586621679195698"><span id="local-6989586621679195699"><span id="local-6989586621679195700"><span id="local-6989586621679195701"><span id="local-6989586621679195702"><span id="local-6989586621679195703"><span id="local-6989586621679195704"><span id="local-6989586621679195705"><span id="local-6989586621679195706"><span id="local-6989586621679195707"><span id="local-6989586621679195708"><span id="local-6989586621679195709"><span id="local-6989586621679195710"><span id="local-6989586621679195711"><span id="local-6989586621679195712"><span id="local-6989586621679195713"><span id="local-6989586621679195714"><span id="local-6989586621679195715"><span id="local-6989586621679195716"><span id="local-6989586621679195717"><span id="local-6989586621679195718"><span id="local-6989586621679195719"><span id="local-6989586621679195720"><span id="local-6989586621679195721"><span id="local-6989586621679195722"><span id="local-6989586621679195723"><span id="local-6989586621679195724"><span id="local-6989586621679195725"><span id="local-6989586621679195726"><span id="local-6989586621679195727"><span id="local-6989586621679195728"><span id="local-6989586621679195729"><span id="local-6989586621679195730"><span id="local-6989586621679195731"><span id="local-6989586621679195732"><span id="local-6989586621679195733"><span id="local-6989586621679195734"><span id="local-6989586621679195735"><span id="local-6989586621679195736"><span id="local-6989586621679195737"><span id="local-6989586621679195738"><span id="local-6989586621679195739"><span id="local-6989586621679195740"><span id="local-6989586621679195741"><span id="local-6989586621679195742"><span id="local-6989586621679195743"><span id="local-6989586621679195744"><span id="local-6989586621679195745"><span id="local-6989586621679195746"><span id="local-6989586621679195747"><span id="local-6989586621679195748"><span id="local-6989586621679195749"><span id="local-6989586621679195750"><span id="local-6989586621679195751"><span id="local-6989586621679195752"><span id="local-6989586621679195753"><span id="local-6989586621679195754"><span id="local-6989586621679195755"><span id="local-6989586621679195756"><span id="local-6989586621679195757"><span id="local-6989586621679195758"><span id="local-6989586621679195759"><span id="local-6989586621679195760"><span id="local-6989586621679195761"><span id="local-6989586621679195762"><span id="local-6989586621679195763"><span id="local-6989586621679195764"><span id="local-6989586621679195765"><span id="local-6989586621679195766"><span id="local-6989586621679195767"><span id="local-6989586621679195768"><span id="local-6989586621679195769"><span id="local-6989586621679195770"><span id="local-6989586621679195771"><span id="local-6989586621679195772"><span id="local-6989586621679195773"><span id="local-6989586621679195774"><span id="local-6989586621679195775"><span id="local-6989586621679195776"><span id="local-6989586621679195777"><span id="local-6989586621679195778"><span id="local-6989586621679195779"><span id="local-6989586621679195780"><span id="local-6989586621679195781"><span id="local-6989586621679195782"><span id="local-6989586621679195783"><span id="local-6989586621679195784"><span id="local-6989586621679195785"><span id="local-6989586621679195786"><span id="local-6989586621679195787"><span id="local-6989586621679195788"><span id="local-6989586621679195789"><span id="local-6989586621679195790"><span id="local-6989586621679195791"><span id="local-6989586621679195792"><span id="local-6989586621679195793"><span id="local-6989586621679195794"><span id="local-6989586621679195795"><span id="local-6989586621679195796"><span id="local-6989586621679195797"><span id="local-6989586621679195798"><span id="local-6989586621679195799"><span id="local-6989586621679195800"><span id="local-6989586621679195801"><span id="local-6989586621679195802"><span id="local-6989586621679195803"><span id="local-6989586621679195804"><span id="local-6989586621679195805"><span id="local-6989586621679195806"><span id="local-6989586621679195807"><span id="local-6989586621679195808"><span id="local-6989586621679195809"><span id="local-6989586621679195810"><span id="local-6989586621679195811"><span id="local-6989586621679195812"><span id="local-6989586621679195813"><span id="local-6989586621679195814"><span id="local-6989586621679195815"><span id="local-6989586621679195816"><span id="local-6989586621679195817"><span id="local-6989586621679195818"><span id="local-6989586621679195819"><span id="local-6989586621679195820"><span id="local-6989586621679195821"><span id="local-6989586621679195822"><span id="local-6989586621679195823"><span id="local-6989586621679195824"><span id="local-6989586621679195825"><span id="local-6989586621679195826"><span id="local-6989586621679195827"><span id="local-6989586621679195828"><span id="local-6989586621679195829"><span id="local-6989586621679195830"><span id="local-6989586621679195831"><span id="local-6989586621679195832"><span id="local-6989586621679195833"><span id="local-6989586621679195834"><span id="local-6989586621679195835"><span id="local-6989586621679195836"><span id="local-6989586621679195837"><span id="local-6989586621679195838"><span id="local-6989586621679195839"><span id="local-6989586621679195840"><span id="local-6989586621679195841"><span id="local-6989586621679195842"><span id="local-6989586621679195843"><span id="local-6989586621679195844"><span id="local-6989586621679195845"><span id="local-6989586621679195846"><span id="local-6989586621679195847"><span id="local-6989586621679195848"><span id="local-6989586621679195849"><span id="local-6989586621679195850"><span id="local-6989586621679195851"><span id="local-6989586621679195852"><span id="local-6989586621679195853"><span id="local-6989586621679195854"><span id="local-6989586621679195855"><span id="local-6989586621679195856"><span id="local-6989586621679195857"><span id="local-6989586621679195858"><span id="local-6989586621679195859"><span id="local-6989586621679195860"><span id="local-6989586621679195861"><span id="local-6989586621679195862"><span id="local-6989586621679195863"><span id="local-6989586621679195864"><span id="local-6989586621679195865"><span id="local-6989586621679195866"><span id="local-6989586621679195867"><span id="local-6989586621679195868"><span id="local-6989586621679195869"><span id="local-6989586621679195870"><span id="local-6989586621679195871"><span id="local-6989586621679195872"><span id="local-6989586621679195873"><span id="local-6989586621679195874"><span id="local-6989586621679195875"><span id="local-6989586621679195876"><span id="local-6989586621679195877"><span id="local-6989586621679195878"><span id="local-6989586621679195879"><span id="local-6989586621679195880"><span id="local-6989586621679195881"><span id="local-6989586621679195882"><span id="local-6989586621679195883"><span id="local-6989586621679195884"><span id="local-6989586621679195885"><span id="local-6989586621679195886"><span id="local-6989586621679195887"><span id="local-6989586621679195888"><span id="local-6989586621679195889"><span id="local-6989586621679195890"><span id="local-6989586621679195891"><span id="local-6989586621679195892"><span id="local-6989586621679195893"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-pragma">{-# LANGUAGE CPP, DeriveDataTypeable,
             DeriveGeneric, FlexibleInstances, DefaultSignatures,
             RankNTypes, RoleAnnotations, ScopedTypeVariables,
             MagicHash, KindSignatures, PolyKinds, TypeApplications, DataKinds,
             GADTs, UnboxedTuples, UnboxedSums, TypeOperators,
             Trustworthy, DeriveFunctor, DeriveTraversable,
             BangPatterns, RecordWildCards, ImplicitParams #-}</span><span>
</span><span id="line-8"></span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-inline-rule-shadowing #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskellQuotes #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE StandaloneKindSignatures #-}</span><span>
</span><span id="line-12"></span><span>
</span><span id="line-13"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- Module      :  Language.Haskell.Syntax</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- Copyright   :  (c) The University of Glasgow 2003</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- License     :  BSD-style (see the file libraries/base/LICENSE)</span><span>
</span><span id="line-18"></span><span class="hs-comment">--</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- Stability   :  experimental</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-22"></span><span class="hs-comment">--</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- Abstract syntax definitions for Template Haskell.</span><span>
</span><span id="line-24"></span><span class="hs-comment">--</span><span>
</span><span id="line-25"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></a></span><span>
</span><span id="line-28"></span><span>    </span><span class="hs-special">(</span><span> </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></a></span><span>
</span><span id="line-29"></span><span>      </span><span class="annot"><span class="hs-comment">-- * Language extensions</span></span><span>
</span><span id="line-30"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Language.Haskell.TH.LanguageExtensions.html"><span class="hs-identifier">Language.Haskell.TH.LanguageExtensions</span></a></span><span>
</span><span id="line-31"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#ForeignSrcLang"><span class="hs-identifier">ForeignSrcLang</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Notes</span></span><span>
</span><span id="line-33"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Unresolved Infix</span></span><span>
</span><span id="line-34"></span><span>    </span><span class="annot"><span class="hs-comment">-- $infix</span></span><span>
</span><span id="line-35"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Fixed.html"><span class="hs-identifier">Data.Fixed</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Fixed</span></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Data.html"><span class="hs-identifier">Data.Data</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Fixity</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.IORef.html"><span class="hs-identifier">Data.IORef</span></a></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/System.IO.Unsafe.html"><span class="hs-identifier">System.IO.Unsafe</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">unsafePerformIO</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="System.FilePath.html"><span class="hs-identifier">System.FilePath</span></a></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/GHC.IO.Unsafe.html"><span class="hs-identifier">GHC.IO.Unsafe</span></a></span><span>    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">unsafeDupableInterleaveIO</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Monad.html"><span class="hs-identifier">Control.Monad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">liftM</span></span><span class="hs-special">)</span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Monad.IO.Class.html"><span class="hs-identifier">Control.Monad.IO.Class</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Monad.IO.Class.html#MonadIO"><span class="hs-identifier">MonadIO</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Monad.Fix.html"><span class="hs-identifier">Control.Monad.Fix</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadFix</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Applicative.html"><span class="hs-identifier">Control.Applicative</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Applicative</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Exception.html"><span class="hs-identifier">Control.Exception</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">BlockedIndefinitelyOnMVar</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">catch</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">throwIO</span></span><span class="hs-special">)</span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Exception.Base.html"><span class="hs-identifier">Control.Exception.Base</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">FixIOException</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Concurrent.MVar.html"><span class="hs-identifier">Control.Concurrent.MVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">newEmptyMVar</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">readMVar</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">putMVar</span></span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/System.IO.html"><span class="hs-identifier">System.IO</span></a></span><span>        </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">hPutStrLn</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">stderr</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Char.html"><span class="hs-identifier">Data.Char</span></a></span><span>        </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">isAlpha</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">isAlphaNum</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">isUpper</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ord</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Int.html"><span class="hs-identifier">Data.Int</span></a></span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.List.NonEmpty.html"><span class="hs-identifier">Data.List.NonEmpty</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">NonEmpty</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Void.html"><span class="hs-identifier">Data.Void</span></a></span><span>        </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Void</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">absurd</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Word.html"><span class="hs-identifier">Data.Word</span></a></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Ratio.html"><span class="hs-identifier">Data.Ratio</span></a></span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.CString.html"><span class="hs-identifier">GHC.CString</span></a></span><span>      </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.CString.html#unpackCString%23"><span class="hs-identifier">unpackCString#</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/GHC.Generics.html"><span class="hs-identifier">GHC.Generics</span></a></span><span>     </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Generic</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html"><span class="hs-identifier">GHC.Types</span></a></span><span>        </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier">Int</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Word"><span class="hs-identifier">Word</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Char"><span class="hs-identifier">Char</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Double"><span class="hs-identifier">Double</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Float"><span class="hs-identifier">Float</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-60"></span><span>                          </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier">TYPE</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier">RuntimeRep</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Levity"><span class="hs-identifier">Levity</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Multiplicity"><span class="hs-identifier">Multiplicity</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Kind.html"><span class="hs-identifier">Data.Kind</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Kind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Type"><span class="hs-identifier">Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html"><span class="hs-identifier">GHC.Prim</span></a></span><span>         </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Int%23"><span class="hs-identifier">Int#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Word%23"><span class="hs-identifier">Word#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Char%23"><span class="hs-identifier">Char#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Double%23"><span class="hs-identifier">Double#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Float%23"><span class="hs-identifier">Float#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Addr%23"><span class="hs-identifier">Addr#</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/GHC.Ptr.html"><span class="hs-identifier">GHC.Ptr</span></a></span><span>          </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Ptr</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">plusPtr</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.Lexeme.html"><span class="hs-identifier">GHC.Lexeme</span></a></span><span>       </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.Lexeme.html#startsVarSym"><span class="hs-identifier">startsVarSym</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.Lexeme.html#startsVarId"><span class="hs-identifier">startsVarId</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html"><span class="hs-identifier">GHC.ForeignSrcLang.Type</span></a></span><span>
</span><span id="line-66"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.LanguageExtensions.html"><span class="hs-identifier">Language.Haskell.TH.LanguageExtensions</span></a></span><span>
</span><span id="line-67"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Numeric.Natural.html"><span class="hs-identifier">Numeric.Natural</span></a></span><span>
</span><span id="line-68"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Prelude.html"><span class="hs-identifier">Prelude</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Applicative</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-69"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Foreign.ForeignPtr.html"><span class="hs-identifier">Foreign.ForeignPtr</span></a></span><span>
</span><span id="line-70"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Foreign.C.String.html"><span class="hs-identifier">Foreign.C.String</span></a></span><span>
</span><span id="line-71"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Foreign.C.Types.html"><span class="hs-identifier">Foreign.C.Types</span></a></span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html"><span class="hs-identifier">Data.Array.Byte</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html#ByteArray"><span class="hs-identifier">ByteArray</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-74"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/GHC.Exts.html"><span class="hs-identifier">GHC.Exts</span></a></span><span>
</span><span id="line-75"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#ByteArray%23"><span class="hs-identifier">ByteArray#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#unsafeFreezeByteArray%23"><span class="hs-identifier">unsafeFreezeByteArray#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#copyAddrToByteArray%23"><span class="hs-identifier">copyAddrToByteArray#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#newByteArray%23"><span class="hs-identifier">newByteArray#</span></a></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#isByteArrayPinned%23"><span class="hs-identifier">isByteArrayPinned#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#isTrue%23"><span class="hs-identifier">isTrue#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#sizeofByteArray%23"><span class="hs-identifier">sizeofByteArray#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unsafeCoerce#</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#byteArrayContents%23"><span class="hs-identifier">byteArrayContents#</span></a></span><span>
</span><span id="line-77"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#copyByteArray%23"><span class="hs-identifier">copyByteArray#</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#newPinnedByteArray%23"><span class="hs-identifier">newPinnedByteArray#</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-78"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/GHC.ForeignPtr.html"><span class="hs-identifier">GHC.ForeignPtr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ForeignPtr</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ForeignPtrContents</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-79"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/GHC.ST.html"><span class="hs-identifier">GHC.ST</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ST</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">runST</span></span><span class="hs-special">)</span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-82"></span><span class="hs-comment">--</span><span>
</span><span id="line-83"></span><span class="hs-comment">--              The Quasi class</span><span>
</span><span id="line-84"></span><span class="hs-comment">--</span><span>
</span><span id="line-85"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span class="hs-keyword">class</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Monad.IO.Class.html#MonadIO"><span class="hs-identifier hs-type">MonadIO</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadFail</span></span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span id="Quasi"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quasi"><span class="hs-identifier hs-var">Quasi</span></a></span></span><span> </span><span id="local-6989586621679193294"><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-88"></span><span>  </span><span id="qNewName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qNewName"><span class="hs-identifier hs-type">qNewName</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-89"></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Fresh names</span></span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span>        </span><span class="hs-comment">-- Error reporting and recovery</span><span>
</span><span id="line-92"></span><span>  </span><span id="qReport"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReport"><span class="hs-identifier hs-type">qReport</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ Report an error (True) or warning (False)</span><span>
</span><span id="line-93"></span><span>                                        </span><span class="hs-comment">-- ...but carry on; use 'fail' to stop</span><span>
</span><span id="line-94"></span><span>  </span><span id="qRecover"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qRecover"><span class="hs-identifier hs-type">qRecover</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193308"><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193308"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the error handler</span></span><span>
</span><span id="line-95"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193308"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ action which may fail</span></span><span>
</span><span id="line-96"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193308"><span class="hs-identifier hs-type">a</span></a></span></span><span>               </span><span class="annot"><span class="hs-comment">-- ^ Recover from the monadic 'fail'</span></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span>        </span><span class="hs-comment">-- Inspect the type-checker's environment</span><span>
</span><span id="line-99"></span><span>  </span><span id="qLookupName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qLookupName"><span class="hs-identifier hs-type">qLookupName</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-100"></span><span>       </span><span class="hs-comment">-- True &lt;=&gt; type namespace, False &lt;=&gt; value namespace</span><span>
</span><span id="line-101"></span><span>  </span><span id="qReify"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReify"><span class="hs-identifier hs-type">qReify</span></a></span></span><span>          </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Info"><span class="hs-identifier hs-type">Info</span></a></span><span>
</span><span id="line-102"></span><span>  </span><span id="qReifyFixity"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReifyFixity"><span class="hs-identifier hs-type">qReifyFixity</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-103"></span><span>  </span><span id="qReifyType"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReifyType"><span class="hs-identifier hs-type">qReifyType</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-104"></span><span>  </span><span id="qReifyInstances"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReifyInstances"><span class="hs-identifier hs-type">qReifyInstances</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-105"></span><span>       </span><span class="hs-comment">-- Is (n tys) an instance?</span><span>
</span><span id="line-106"></span><span>       </span><span class="hs-comment">-- Returns list of matching instance Decs</span><span>
</span><span id="line-107"></span><span>       </span><span class="hs-comment">--    (with empty sub-Decs)</span><span>
</span><span id="line-108"></span><span>       </span><span class="hs-comment">-- Works for classes and type functions</span><span>
</span><span id="line-109"></span><span>  </span><span id="qReifyRoles"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReifyRoles"><span class="hs-identifier hs-type">qReifyRoles</span></a></span></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Role"><span class="hs-identifier hs-type">Role</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-110"></span><span>  </span><span id="qReifyAnnotations"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReifyAnnotations"><span class="hs-identifier hs-type">qReifyAnnotations</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193309"><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193309"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnnLookup"><span class="hs-identifier hs-type">AnnLookup</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679193309"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-111"></span><span>  </span><span id="qReifyModule"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReifyModule"><span class="hs-identifier hs-type">qReifyModule</span></a></span></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModuleInfo"><span class="hs-identifier hs-type">ModuleInfo</span></a></span><span>
</span><span id="line-112"></span><span>  </span><span id="qReifyConStrictness"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReifyConStrictness"><span class="hs-identifier hs-type">qReifyConStrictness</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DecidedStrictness"><span class="hs-identifier hs-type">DecidedStrictness</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span>  </span><span id="qLocation"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qLocation"><span class="hs-identifier hs-type">qLocation</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Loc"><span class="hs-identifier hs-type">Loc</span></a></span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span>  </span><span id="qRunIO"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qRunIO"><span class="hs-identifier hs-type">qRunIO</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193297"><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193297"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193297"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-117"></span><span>  </span><span id="local-6989586621679196024"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qRunIO"><span class="hs-identifier hs-var hs-var">qRunIO</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IO a -&gt; m a
forall a. IO a -&gt; m a
forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><a href="../../base-4.20.1.0-inplace/src/Control.Monad.IO.Class.html#liftIO"><span class="hs-identifier hs-var">liftIO</span></a></span></span><span>
</span><span id="line-118"></span><span>  </span><span class="hs-comment">-- ^ Input/output (dangerous)</span><span>
</span><span id="line-119"></span><span>  </span><span id="qGetPackageRoot"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qGetPackageRoot"><span class="hs-identifier hs-type">qGetPackageRoot</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span>  </span><span id="qAddDependentFile"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qAddDependentFile"><span class="hs-identifier hs-type">qAddDependentFile</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span>  </span><span id="qAddTempFile"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qAddTempFile"><span class="hs-identifier hs-type">qAddTempFile</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span>  </span><span id="qAddTopDecls"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qAddTopDecls"><span class="hs-identifier hs-type">qAddTopDecls</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span>  </span><span id="qAddForeignFilePath"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qAddForeignFilePath"><span class="hs-identifier hs-type">qAddForeignFilePath</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#ForeignSrcLang"><span class="hs-identifier hs-type">ForeignSrcLang</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span>  </span><span id="qAddModFinalizer"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qAddModFinalizer"><span class="hs-identifier hs-type">qAddModFinalizer</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span>  </span><span id="qAddCorePlugin"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qAddCorePlugin"><span class="hs-identifier hs-type">qAddCorePlugin</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span>  </span><span id="qGetQ"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qGetQ"><span class="hs-identifier hs-type">qGetQ</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193314"><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621679193314"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679193314"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span>  </span><span id="qPutQ"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qPutQ"><span class="hs-identifier hs-type">qPutQ</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193315"><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621679193315"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193315"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span>  </span><span id="qIsExtEnabled"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qIsExtEnabled"><span class="hs-identifier hs-type">qIsExtEnabled</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.LanguageExtensions.Type.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-138"></span><span>  </span><span id="qExtsEnabled"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qExtsEnabled"><span class="hs-identifier hs-type">qExtsEnabled</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.LanguageExtensions.Type.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span>  </span><span id="qPutDoc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qPutDoc"><span class="hs-identifier hs-type">qPutDoc</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DocLoc"><span class="hs-identifier hs-type">DocLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-141"></span><span>  </span><span id="qGetDoc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qGetDoc"><span class="hs-identifier hs-type">qGetDoc</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DocLoc"><span class="hs-identifier hs-type">DocLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193294"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span>
</span><span id="line-142"></span><span>
</span><span id="line-143"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-144"></span><span class="hs-comment">--      The IO instance of Quasi</span><span>
</span><span id="line-145"></span><span class="hs-comment">--</span><span>
</span><span id="line-146"></span><span class="hs-comment">--  This instance is used only when running a Q</span><span>
</span><span id="line-147"></span><span class="hs-comment">--  computation in the IO monad, usually just to</span><span>
</span><span id="line-148"></span><span class="hs-comment">--  print the result.  There is no interesting</span><span>
</span><span id="line-149"></span><span class="hs-comment">--  type environment, so reification isn't going to</span><span>
</span><span id="line-150"></span><span class="hs-comment">--  work.</span><span>
</span><span id="line-151"></span><span class="hs-comment">--</span><span>
</span><span id="line-152"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-153"></span><span>
</span><span id="line-154"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679196061"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quasi"><span class="hs-identifier hs-type">Quasi</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-155"></span><span>  </span><span id="local-6989586621679196078"><span class="annot"><span class="annottext">qNewName :: FilePath -&gt; IO Name
</span><a href="Language.Haskell.TH.Syntax.html#qNewName"><span class="hs-identifier hs-var hs-var hs-var">qNewName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO Name
</span><a href="Language.Haskell.TH.Syntax.html#newNameIO"><span class="hs-identifier hs-var">newNameIO</span></a></span><span>
</span><span id="line-156"></span><span>
</span><span id="line-157"></span><span>  </span><span id="local-6989586621679196080"><span class="annot"><span class="annottext">qReport :: Bool -&gt; FilePath -&gt; IO ()
</span><a href="Language.Haskell.TH.Syntax.html#qReport"><span class="hs-identifier hs-var hs-var hs-var">qReport</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>  </span><span id="local-6989586621679196081"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196081"><span class="hs-identifier hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Handle -&gt; FilePath -&gt; IO ()
</span><span class="hs-identifier hs-var">hPutStrLn</span></span><span> </span><span class="annot"><span class="annottext">Handle
</span><span class="hs-identifier hs-var">stderr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Template Haskell error: &quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196081"><span class="hs-identifier hs-var">msg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-158"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#qReport"><span class="hs-identifier hs-var">qReport</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span> </span><span id="local-6989586621679196082"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196082"><span class="hs-identifier hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Handle -&gt; FilePath -&gt; IO ()
</span><span class="hs-identifier hs-var">hPutStrLn</span></span><span> </span><span class="annot"><span class="annottext">Handle
</span><span class="hs-identifier hs-var">stderr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Template Haskell error: &quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196082"><span class="hs-identifier hs-var">msg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span>  </span><span id="local-6989586621679196083"><span class="annot"><span class="annottext">qLookupName :: Bool -&gt; FilePath -&gt; IO (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#qLookupName"><span class="hs-identifier hs-var hs-var hs-var">qLookupName</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO (Maybe Name)
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;lookupName&quot;</span></span><span>
</span><span id="line-161"></span><span>  </span><span id="local-6989586621679196085"><span class="annot"><span class="annottext">qReify :: Name -&gt; IO Info
</span><a href="Language.Haskell.TH.Syntax.html#qReify"><span class="hs-identifier hs-var hs-var hs-var">qReify</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO Info
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;reify&quot;</span></span><span>
</span><span id="line-162"></span><span>  </span><span id="local-6989586621679196086"><span class="annot"><span class="annottext">qReifyFixity :: Name -&gt; IO (Maybe Fixity)
</span><a href="Language.Haskell.TH.Syntax.html#qReifyFixity"><span class="hs-identifier hs-var hs-var hs-var">qReifyFixity</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO (Maybe Fixity)
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;reifyFixity&quot;</span></span><span>
</span><span id="line-163"></span><span>  </span><span id="local-6989586621679196087"><span class="annot"><span class="annottext">qReifyType :: Name -&gt; IO Type
</span><a href="Language.Haskell.TH.Syntax.html#qReifyType"><span class="hs-identifier hs-var hs-var hs-var">qReifyType</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO Type
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;reifyFixity&quot;</span></span><span>
</span><span id="line-164"></span><span>  </span><span id="local-6989586621679196088"><span class="annot"><span class="annottext">qReifyInstances :: Name -&gt; [Type] -&gt; IO [Dec]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyInstances"><span class="hs-identifier hs-var hs-var hs-var">qReifyInstances</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO [Dec]
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;reifyInstances&quot;</span></span><span>
</span><span id="line-165"></span><span>  </span><span id="local-6989586621679196089"><span class="annot"><span class="annottext">qReifyRoles :: Name -&gt; IO [Role]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyRoles"><span class="hs-identifier hs-var hs-var hs-var">qReifyRoles</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO [Role]
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;reifyRoles&quot;</span></span><span>
</span><span id="line-166"></span><span>  </span><span id="local-6989586621679196091"><span class="annot"><span class="annottext">qReifyAnnotations :: forall a. Data a =&gt; AnnLookup -&gt; IO [a]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyAnnotations"><span class="hs-identifier hs-var hs-var hs-var">qReifyAnnotations</span></a></span></span><span> </span><span class="annot"><span class="annottext">AnnLookup
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO [a]
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;reifyAnnotations&quot;</span></span><span>
</span><span id="line-167"></span><span>  </span><span id="local-6989586621679196092"><span class="annot"><span class="annottext">qReifyModule :: Module -&gt; IO ModuleInfo
</span><a href="Language.Haskell.TH.Syntax.html#qReifyModule"><span class="hs-identifier hs-var hs-var hs-var">qReifyModule</span></a></span></span><span> </span><span class="annot"><span class="annottext">Module
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO ModuleInfo
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;reifyModule&quot;</span></span><span>
</span><span id="line-168"></span><span>  </span><span id="local-6989586621679196093"><span class="annot"><span class="annottext">qReifyConStrictness :: Name -&gt; IO [DecidedStrictness]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyConStrictness"><span class="hs-identifier hs-var hs-var hs-var">qReifyConStrictness</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO [DecidedStrictness]
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;reifyConStrictness&quot;</span></span><span>
</span><span id="line-169"></span><span>  </span><span id="local-6989586621679196094"><span class="annot"><span class="annottext">qLocation :: IO Loc
</span><a href="Language.Haskell.TH.Syntax.html#qLocation"><span class="hs-identifier hs-var hs-var hs-var">qLocation</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO Loc
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;currentLocation&quot;</span></span><span>
</span><span id="line-170"></span><span>  </span><span id="local-6989586621679196095"><span class="annot"><span class="annottext">qRecover :: forall a. IO a -&gt; IO a -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#qRecover"><span class="hs-identifier hs-var hs-var hs-var">qRecover</span></a></span></span><span> </span><span class="annot"><span class="annottext">IO a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">IO a
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO a
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;recover&quot;</span></span><span> </span><span class="hs-comment">-- Maybe we could fix this?</span><span>
</span><span id="line-171"></span><span>  </span><span id="local-6989586621679196096"><span class="annot"><span class="annottext">qGetPackageRoot :: IO FilePath
</span><a href="Language.Haskell.TH.Syntax.html#qGetPackageRoot"><span class="hs-identifier hs-var hs-var hs-var">qGetPackageRoot</span></a></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO FilePath
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;getProjectRoot&quot;</span></span><span>
</span><span id="line-172"></span><span>  </span><span id="local-6989586621679196097"><span class="annot"><span class="annottext">qAddDependentFile :: FilePath -&gt; IO ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddDependentFile"><span class="hs-identifier hs-var hs-var hs-var">qAddDependentFile</span></a></span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO ()
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;addDependentFile&quot;</span></span><span>
</span><span id="line-173"></span><span>  </span><span id="local-6989586621679196098"><span class="annot"><span class="annottext">qAddTempFile :: FilePath -&gt; IO FilePath
</span><a href="Language.Haskell.TH.Syntax.html#qAddTempFile"><span class="hs-identifier hs-var hs-var hs-var">qAddTempFile</span></a></span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO FilePath
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;addTempFile&quot;</span></span><span>
</span><span id="line-174"></span><span>  </span><span id="local-6989586621679196099"><span class="annot"><span class="annottext">qAddTopDecls :: [Dec] -&gt; IO ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddTopDecls"><span class="hs-identifier hs-var hs-var hs-var">qAddTopDecls</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO ()
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;addTopDecls&quot;</span></span><span>
</span><span id="line-175"></span><span>  </span><span id="local-6989586621679196100"><span class="annot"><span class="annottext">qAddForeignFilePath :: ForeignSrcLang -&gt; FilePath -&gt; IO ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddForeignFilePath"><span class="hs-identifier hs-var hs-var hs-var">qAddForeignFilePath</span></a></span></span><span> </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO ()
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;addForeignFilePath&quot;</span></span><span>
</span><span id="line-176"></span><span>  </span><span id="local-6989586621679196101"><span class="annot"><span class="annottext">qAddModFinalizer :: Q () -&gt; IO ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddModFinalizer"><span class="hs-identifier hs-var hs-var hs-var">qAddModFinalizer</span></a></span></span><span> </span><span class="annot"><span class="annottext">Q ()
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO ()
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;addModFinalizer&quot;</span></span><span>
</span><span id="line-177"></span><span>  </span><span id="local-6989586621679196102"><span class="annot"><span class="annottext">qAddCorePlugin :: FilePath -&gt; IO ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddCorePlugin"><span class="hs-identifier hs-var hs-var hs-var">qAddCorePlugin</span></a></span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO ()
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;addCorePlugin&quot;</span></span><span>
</span><span id="line-178"></span><span>  </span><span id="local-6989586621679196104"><span class="annot"><span class="annottext">qGetQ :: forall a. Typeable a =&gt; IO (Maybe a)
</span><a href="Language.Haskell.TH.Syntax.html#qGetQ"><span class="hs-identifier hs-var hs-var hs-var">qGetQ</span></a></span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO (Maybe a)
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;getQ&quot;</span></span><span>
</span><span id="line-179"></span><span>  </span><span id="local-6989586621679196106"><span class="annot"><span class="annottext">qPutQ :: forall a. Typeable a =&gt; a -&gt; IO ()
</span><a href="Language.Haskell.TH.Syntax.html#qPutQ"><span class="hs-identifier hs-var hs-var hs-var">qPutQ</span></a></span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO ()
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;putQ&quot;</span></span><span>
</span><span id="line-180"></span><span>  </span><span id="local-6989586621679196107"><span class="annot"><span class="annottext">qIsExtEnabled :: Extension -&gt; IO Bool
</span><a href="Language.Haskell.TH.Syntax.html#qIsExtEnabled"><span class="hs-identifier hs-var hs-var hs-var">qIsExtEnabled</span></a></span></span><span> </span><span class="annot"><span class="annottext">Extension
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO Bool
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;isExtEnabled&quot;</span></span><span>
</span><span id="line-181"></span><span>  </span><span id="local-6989586621679196108"><span class="annot"><span class="annottext">qExtsEnabled :: IO [Extension]
</span><a href="Language.Haskell.TH.Syntax.html#qExtsEnabled"><span class="hs-identifier hs-var hs-var hs-var">qExtsEnabled</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO [Extension]
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;extsEnabled&quot;</span></span><span>
</span><span id="line-182"></span><span>  </span><span id="local-6989586621679196109"><span class="annot"><span class="annottext">qPutDoc :: DocLoc -&gt; FilePath -&gt; IO ()
</span><a href="Language.Haskell.TH.Syntax.html#qPutDoc"><span class="hs-identifier hs-var hs-var hs-var">qPutDoc</span></a></span></span><span> </span><span class="annot"><span class="annottext">DocLoc
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO ()
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;putDoc&quot;</span></span><span>
</span><span id="line-183"></span><span>  </span><span id="local-6989586621679196110"><span class="annot"><span class="annottext">qGetDoc :: DocLoc -&gt; IO (Maybe FilePath)
</span><a href="Language.Haskell.TH.Syntax.html#qGetDoc"><span class="hs-identifier hs-var hs-var hs-var">qGetDoc</span></a></span></span><span> </span><span class="annot"><span class="annottext">DocLoc
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO (Maybe FilePath)
forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var">badIO</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;getDoc&quot;</span></span><span>
</span><span id="line-184"></span><span>
</span><span id="line-185"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-186"></span><span>  </span><span id="local-6989586621679196116"><span class="annot"><span class="annottext">newName :: FilePath -&gt; IO Name
</span><a href="Language.Haskell.TH.Syntax.html#newName"><span class="hs-identifier hs-var hs-var hs-var">newName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO Name
</span><a href="Language.Haskell.TH.Syntax.html#newNameIO"><span class="hs-identifier hs-var">newNameIO</span></a></span><span>
</span><span id="line-187"></span><span>
</span><span id="line-188"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#newNameIO"><span class="hs-identifier hs-type">newNameIO</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-189"></span><span id="newNameIO"><span class="annot"><span class="annottext">newNameIO :: FilePath -&gt; IO Name
</span><a href="Language.Haskell.TH.Syntax.html#newNameIO"><span class="hs-identifier hs-var hs-var">newNameIO</span></a></span></span><span> </span><span id="local-6989586621679196117"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196117"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621679196118"><span class="annot"><a href="#local-6989586621679196118"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">IORef Uniq -&gt; (Uniq -&gt; (Uniq, Uniq)) -&gt; IO Uniq
forall a b. IORef a -&gt; (a -&gt; (a, b)) -&gt; IO b
</span><span class="hs-identifier hs-var">atomicModifyIORef'</span></span><span> </span><span class="annot"><span class="annottext">IORef Uniq
</span><a href="Language.Haskell.TH.Syntax.html#counter"><span class="hs-identifier hs-var">counter</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679196121"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196121"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196121"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Uniq -&gt; Uniq -&gt; Uniq
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><span class="hs-number">1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196121"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-190"></span><span>                 </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameU"><span class="hs-identifier hs-type">mkNameU</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196117"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196118"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-191"></span><span>
</span><span id="line-192"></span><span id="local-6989586621679193319"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-type">badIO</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193319"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-193"></span><span id="badIO"><span class="annot"><span class="annottext">badIO :: forall a. FilePath -&gt; IO a
</span><a href="Language.Haskell.TH.Syntax.html#badIO"><span class="hs-identifier hs-var hs-var">badIO</span></a></span></span><span> </span><span id="local-6989586621679196127"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196127"><span class="hs-identifier hs-var">op</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>   </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; IO ()
forall (m :: * -&gt; *). Quasi m =&gt; Bool -&gt; FilePath -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qReport"><span class="hs-identifier hs-var">qReport</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Can't do `&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196127"><span class="hs-identifier hs-var">op</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;' in the IO monad&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>                </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; IO a
forall a. FilePath -&gt; IO a
forall (m :: * -&gt; *) a. MonadFail m =&gt; FilePath -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Template Haskell failure&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-195"></span><span>
</span><span id="line-196"></span><span class="hs-comment">-- Global variable to generate unique symbols</span><span>
</span><span id="line-197"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#counter"><span class="hs-identifier hs-type">counter</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IORef</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Uniq"><span class="hs-identifier hs-type">Uniq</span></a></span><span>
</span><span id="line-198"></span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#counter"><span class="hs-pragma hs-type">counter</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-199"></span><span id="counter"><span class="annot"><span class="annottext">counter :: IORef Uniq
</span><a href="Language.Haskell.TH.Syntax.html#counter"><span class="hs-identifier hs-var hs-var">counter</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IO (IORef Uniq) -&gt; IORef Uniq
forall a. IO a -&gt; a
</span><span class="hs-identifier hs-var">unsafePerformIO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; IO (IORef Uniq)
forall a. a -&gt; IO (IORef a)
</span><span class="hs-identifier hs-var">newIORef</span></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-203"></span><span class="hs-comment">--</span><span>
</span><span id="line-204"></span><span class="hs-comment">--              The Q monad</span><span>
</span><span id="line-205"></span><span class="hs-comment">--</span><span>
</span><span id="line-206"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-207"></span><span>
</span><span id="line-208"></span><span class="hs-keyword">newtype</span><span> </span><span id="Q"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span></span><span> </span><span id="local-6989586621679193336"><span class="annot"><a href="#local-6989586621679193336"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Q"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="unQ"><span class="annot"><span class="annottext">forall a. Q a -&gt; forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="Language.Haskell.TH.Syntax.html#unQ"><span class="hs-identifier hs-var hs-var">unQ</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193337"><span class="annot"><a href="#local-6989586621679193337"><span class="hs-identifier hs-type">m</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quasi"><span class="hs-identifier hs-type">Quasi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193337"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193337"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193336"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-209"></span><span>
</span><span id="line-210"></span><span class="hs-comment">-- \&quot;Runs\&quot; the 'Q' monad. Normal users of Template Haskell</span><span>
</span><span id="line-211"></span><span class="hs-comment">-- should not need this function, as the splice brackets @$( ... )@</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- are the usual way of running a 'Q' computation.</span><span>
</span><span id="line-213"></span><span class="hs-comment">--</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- This function is primarily used in GHC internals, and for debugging</span><span>
</span><span id="line-215"></span><span class="hs-comment">-- splices by running them in 'IO'.</span><span>
</span><span id="line-216"></span><span class="hs-comment">--</span><span>
</span><span id="line-217"></span><span class="hs-comment">-- Note that many functions in 'Q', such as 'reify' and other compiler</span><span>
</span><span id="line-218"></span><span class="hs-comment">-- queries, are not supported when running 'Q' in 'IO'; these operations</span><span>
</span><span id="line-219"></span><span class="hs-comment">-- simply fail at runtime. Indeed, the only operations guaranteed to succeed</span><span>
</span><span id="line-220"></span><span class="hs-comment">-- are 'newName', 'runIO', 'reportError' and 'reportWarning'.</span><span>
</span><span id="line-221"></span><span id="local-6989586621679193340"><span id="local-6989586621679193341"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#runQ"><span class="hs-identifier hs-type">runQ</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quasi"><span class="hs-identifier hs-type">Quasi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193340"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193341"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193340"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193341"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-222"></span><span id="runQ"><span class="annot"><span class="annottext">runQ :: forall (m :: * -&gt; *) a. Quasi m =&gt; Q a -&gt; m a
</span><a href="Language.Haskell.TH.Syntax.html#runQ"><span class="hs-identifier hs-var hs-var">runQ</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196136"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196136"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a
forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196136"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-223"></span><span>
</span><span id="line-224"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679196142"><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-225"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196145"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196145"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679196146"><span class="annot"><span class="annottext">&gt;&gt;= :: forall a b. Q a -&gt; (a -&gt; Q b) -&gt; Q b
</span><span class="hs-operator hs-var hs-var hs-var">&gt;&gt;=</span></span></span><span> </span><span id="local-6989586621679196147"><span class="annot"><span class="annottext">a -&gt; Q b
</span><a href="#local-6989586621679196147"><span class="hs-identifier hs-var">k</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m b) -&gt; Q b
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a
forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196145"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; (a -&gt; m b) -&gt; m b
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679196155"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679196155"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q b -&gt; forall (m :: * -&gt; *). Quasi m =&gt; m b
forall a. Q a -&gt; forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="Language.Haskell.TH.Syntax.html#unQ"><span class="hs-identifier hs-var">unQ</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; Q b
</span><a href="#local-6989586621679196147"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679196155"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-226"></span><span>  </span><span id="local-6989586621679196157"><span class="annot"><span class="annottext">&gt;&gt; :: forall a b. Q a -&gt; Q b -&gt; Q b
</span><span class="hs-operator hs-var hs-var hs-var">(&gt;&gt;)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q a -&gt; Q b -&gt; Q b
forall a b. Q a -&gt; Q b -&gt; Q b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">(*&gt;)</span></span><span>
</span><span id="line-227"></span><span>
</span><span id="line-228"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadFail</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-229"></span><span>  </span><span id="local-6989586621679196164"><span class="annot"><span class="annottext">fail :: forall a. FilePath -&gt; Q a
</span><span class="hs-identifier hs-var hs-var hs-var">fail</span></span></span><span> </span><span id="local-6989586621679196165"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196165"><span class="hs-identifier hs-var">s</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#report"><span class="hs-identifier hs-var">report</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196165"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Q () -&gt; Q a -&gt; Q a
forall a b. Q a -&gt; Q b -&gt; Q b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; m a
forall a. FilePath -&gt; m a
forall (m :: * -&gt; *) a. MonadFail m =&gt; FilePath -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Q monad failure&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679196172"><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-232"></span><span>  </span><span id="local-6989586621679196176"><span class="annot"><span class="annottext">fmap :: forall a b. (a -&gt; b) -&gt; Q a -&gt; Q b
</span><span class="hs-identifier hs-var hs-var hs-var">fmap</span></span></span><span> </span><span id="local-6989586621679196177"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679196177"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196178"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196178"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m b) -&gt; Q b
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; m a -&gt; m b
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679196177"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">m a
forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196178"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679196193"><span id="local-6989586621679196197"><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-235"></span><span>  </span><span id="local-6989586621679196200"><span class="annot"><span class="annottext">pure :: forall a. a -&gt; Q a
</span><span class="hs-identifier hs-var hs-var hs-var">pure</span></span></span><span> </span><span id="local-6989586621679196201"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679196201"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; m a
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679196201"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196207"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m (a -&gt; b)
</span><a href="#local-6989586621679196207"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679196208"><span class="annot"><span class="annottext">&lt;*&gt; :: forall a b. Q (a -&gt; b) -&gt; Q a -&gt; Q b
</span><span class="hs-operator hs-var hs-var hs-var">&lt;*&gt;</span></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196209"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196209"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m b) -&gt; Q b
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m (a -&gt; b)
forall (m :: * -&gt; *). Quasi m =&gt; m (a -&gt; b)
</span><a href="#local-6989586621679196207"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">m (a -&gt; b) -&gt; m a -&gt; m b
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a
forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196209"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-237"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196217"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196217"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679196218"><span class="annot"><span class="annottext">*&gt; :: forall a b. Q a -&gt; Q b -&gt; Q b
</span><span class="hs-operator hs-var hs-var hs-var">*&gt;</span></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196219"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m b
</span><a href="#local-6989586621679196219"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m b) -&gt; Q b
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a
forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196217"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m b -&gt; m b
forall a b. m a -&gt; m b -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m b
forall (m :: * -&gt; *). Quasi m =&gt; m b
</span><a href="#local-6989586621679196219"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-238"></span><span>
</span><span id="line-239"></span><span class="annot"><span class="hs-comment">-- | @since 2.17.0.0</span></span><span>
</span><span id="line-240"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193386"><span id="local-6989586621679196230"><span id="local-6989586621679196234"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="annot"><a href="#local-6989586621679193386"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193386"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-241"></span><span>  </span><span id="local-6989586621679196241"><span class="annot"><span class="annottext">&lt;&gt; :: Q a -&gt; Q a -&gt; Q a
</span><span class="hs-operator hs-var hs-var hs-var">(&lt;&gt;)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; a) -&gt; Q a -&gt; Q a -&gt; Q a
forall a b c. (a -&gt; b -&gt; c) -&gt; Q a -&gt; Q b -&gt; Q c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span>
</span><span id="line-242"></span><span>
</span><span id="line-243"></span><span class="annot"><span class="hs-comment">-- | @since 2.17.0.0</span></span><span>
</span><span id="line-244"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193389"><span id="local-6989586621679196249"><span id="local-6989586621679196253"><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679193389"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193389"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-245"></span><span>  </span><span id="local-6989586621679196259"><span class="annot"><span class="annottext">mempty :: Q a
</span><span class="hs-identifier hs-var hs-var hs-var">mempty</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Q a
forall a. a -&gt; Q a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-246"></span><span>
</span><span id="line-247"></span><span class="hs-comment">-- | If the function passed to 'mfix' inspects its argument,</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- the resulting action will throw a 'FixIOException'.</span><span>
</span><span id="line-249"></span><span class="hs-comment">--</span><span>
</span><span id="line-250"></span><span class="hs-comment">-- @since 2.17.0.0</span><span>
</span><span id="line-251"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadFix</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-252"></span><span>  </span><span class="hs-comment">-- We use the same blackholing approach as in fixIO.</span><span>
</span><span id="line-253"></span><span>  </span><span class="hs-comment">-- See Note [Blackholing in fixIO] in System.IO in base.</span><span>
</span><span id="line-254"></span><span>  </span><span id="local-6989586621679196277"><span class="annot"><span class="annottext">mfix :: forall a. (a -&gt; Q a) -&gt; Q a
</span><span class="hs-identifier hs-var hs-var hs-var">mfix</span></span></span><span> </span><span id="local-6989586621679196278"><span class="annot"><span class="annottext">a -&gt; Q a
</span><a href="#local-6989586621679196278"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-255"></span><span>    </span><span id="local-6989586621679196279"><span class="annot"><a href="#local-6989586621679196279"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">IO (MVar a) -&gt; Q (MVar a)
forall a. IO a -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#runIO"><span class="hs-identifier hs-var">runIO</span></a></span><span> </span><span class="annot"><span class="annottext">IO (MVar a)
forall a. IO (MVar a)
</span><span class="hs-identifier hs-var">newEmptyMVar</span></span><span>
</span><span id="line-256"></span><span>    </span><span id="local-6989586621679196281"><span class="annot"><a href="#local-6989586621679196281"><span class="hs-identifier hs-var">ans</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#runIO"><span class="hs-identifier hs-type">runIO</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">unsafeDupableInterleaveIO</span></span><span>
</span><span id="line-257"></span><span>             </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">readMVar</span></span><span> </span><span class="annot"><a href="#local-6989586621679196279"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">`catch`</span></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">BlockedIndefinitelyOnMVar
</span><span class="hs-identifier hs-var">BlockedIndefinitelyOnMVar</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-258"></span><span>                                    </span><span class="annot"><span class="annottext">FixIOException -&gt; IO a
forall e a. (HasCallStack, Exception e) =&gt; e -&gt; IO a
</span><span class="hs-identifier hs-var">throwIO</span></span><span> </span><span class="annot"><span class="annottext">FixIOException
</span><span class="hs-identifier hs-var">FixIOException</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-259"></span><span>    </span><span id="local-6989586621679196283"><span class="annot"><a href="#local-6989586621679196283"><span class="hs-identifier hs-var">result</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621679196278"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196281"><span class="hs-identifier hs-type">ans</span></a></span><span>
</span><span id="line-260"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#runIO"><span class="hs-identifier hs-type">runIO</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">putMVar</span></span><span> </span><span class="annot"><a href="#local-6989586621679196279"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196283"><span class="hs-identifier hs-type">result</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-261"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><a href="#local-6989586621679196283"><span class="hs-identifier hs-type">result</span></a></span><span>
</span><span id="line-262"></span><span>
</span><span id="line-263"></span><span>
</span><span id="line-264"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-265"></span><span class="hs-comment">--</span><span>
</span><span id="line-266"></span><span class="hs-comment">--              The Quote class</span><span>
</span><span id="line-267"></span><span class="hs-comment">--</span><span>
</span><span id="line-268"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-269"></span><span>
</span><span id="line-270"></span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span class="hs-comment">-- | The 'Quote' class implements the minimal interface which is necessary for</span><span>
</span><span id="line-273"></span><span class="hs-comment">-- desugaring quotations.</span><span>
</span><span id="line-274"></span><span class="hs-comment">--</span><span>
</span><span id="line-275"></span><span class="hs-comment">-- * The @Monad m@ superclass is needed to stitch together the different</span><span>
</span><span id="line-276"></span><span class="hs-comment">-- AST fragments.</span><span>
</span><span id="line-277"></span><span class="hs-comment">-- * 'newName' is used when desugaring binding structures such as lambdas</span><span>
</span><span id="line-278"></span><span class="hs-comment">-- to generate fresh names.</span><span>
</span><span id="line-279"></span><span class="hs-comment">--</span><span>
</span><span id="line-280"></span><span class="hs-comment">-- Therefore the type of an untyped quotation in GHC is `Quote m =&gt; m Exp`</span><span>
</span><span id="line-281"></span><span class="hs-comment">--</span><span>
</span><span id="line-282"></span><span class="hs-comment">-- For many years the type of a quotation was fixed to be `Q Exp` but by</span><span>
</span><span id="line-283"></span><span class="hs-comment">-- more precisely specifying the minimal interface it enables the `Exp` to</span><span>
</span><span id="line-284"></span><span class="hs-comment">-- be extracted purely from the quotation without interacting with `Q`.</span><span>
</span><span id="line-285"></span><span class="hs-keyword">class</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679193324"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span id="Quote"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-var">Quote</span></a></span></span><span> </span><span id="local-6989586621679193324"><span class="annot"><a href="#local-6989586621679193324"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-286"></span><span>  </span><span class="hs-comment">{- |
  Generate a fresh name, which cannot be captured.

  For example, this:

  @f = $(do
    nm1 &lt;- newName \&quot;x\&quot;
    let nm2 = 'mkName' \&quot;x\&quot;
    return ('LamE' ['VarP' nm1] (LamE [VarP nm2] ('VarE' nm1)))
   )@

  will produce the splice

  &gt;f = \x0 -&gt; \x -&gt; x0

  In particular, the occurrence @VarE nm1@ refers to the binding @VarP nm1@,
  and is not captured by the binding @VarP nm2@.

  Although names generated by @newName@ cannot /be captured/, they can
  /capture/ other names. For example, this:

  &gt;g = $(do
  &gt;  nm1 &lt;- newName &quot;x&quot;
  &gt;  let nm2 = mkName &quot;x&quot;
  &gt;  return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
  &gt; )

  will produce the splice

  &gt;g = \x -&gt; \x0 -&gt; x0

  since the occurrence @VarE nm2@ is captured by the innermost binding
  of @x@, namely @VarP nm1@.
  -}</span><span>
</span><span id="line-320"></span><span>  </span><span id="newName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#newName"><span class="hs-identifier hs-type">newName</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193324"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-323"></span><span>  </span><span id="local-6989586621679196289"><span class="annot"><span class="annottext">newName :: FilePath -&gt; Q Name
</span><a href="Language.Haskell.TH.Syntax.html#newName"><span class="hs-identifier hs-var hs-var hs-var">newName</span></a></span></span><span> </span><span id="local-6989586621679196290"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196290"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m Name) -&gt; Q Name
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; m Name
forall (m :: * -&gt; *). Quasi m =&gt; FilePath -&gt; m Name
</span><a href="Language.Haskell.TH.Syntax.html#qNewName"><span class="hs-identifier hs-var">qNewName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196290"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-324"></span><span>
</span><span id="line-325"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-326"></span><span class="hs-comment">--</span><span>
</span><span id="line-327"></span><span class="hs-comment">--              The TExp type</span><span>
</span><span id="line-328"></span><span class="hs-comment">--</span><span>
</span><span id="line-329"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-330"></span><span>
</span><span id="line-331"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-type">TExp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193406"><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193406"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Type"><span class="hs-identifier hs-type">Kind.Type</span></a></span></span><span>
</span><span id="line-332"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">role</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-type">TExp</span></a></span><span> </span><span class="annot"><span class="hs-identifier">nominal</span></span><span>   </span><span class="hs-comment">-- See Note [Role of TExp]</span><span>
</span><span id="line-333"></span><span class="hs-keyword">newtype</span><span> </span><span id="TExp"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-var">TExp</span></a></span></span><span> </span><span id="local-6989586621679193407"><span class="annot"><a href="#local-6989586621679193407"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="TExp"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-var">TExp</span></a></span></span><span>
</span><span id="line-334"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="unType"><span class="annot"><span class="annottext">forall a. TExp a -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#unType"><span class="hs-identifier hs-var hs-var">unType</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Underlying untyped Template Haskell expression</span></span><span>
</span><span id="line-335"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-336"></span><span class="hs-comment">-- ^ Typed wrapper around an 'Exp'.</span><span>
</span><span id="line-337"></span><span class="hs-comment">--</span><span>
</span><span id="line-338"></span><span class="hs-comment">-- This is the typed representation of terms produced by typed quotes.</span><span>
</span><span id="line-339"></span><span class="hs-comment">--</span><span>
</span><span id="line-340"></span><span class="hs-comment">-- Representation-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-341"></span><span>
</span><span id="line-342"></span><span class="hs-comment">-- | Discard the type annotation and produce a plain Template Haskell</span><span>
</span><span id="line-343"></span><span class="hs-comment">-- expression</span><span>
</span><span id="line-344"></span><span class="hs-comment">--</span><span>
</span><span id="line-345"></span><span class="hs-comment">-- Representation-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-346"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#unTypeQ"><span class="hs-identifier hs-type">unTypeQ</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193411"><span class="annot"><a href="#local-6989586621679193411"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193413"><span class="annot"><a href="#local-6989586621679193413"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193411"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679193412"><span class="annot"><a href="#local-6989586621679193412"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193412"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193412"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-type">TExp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193413"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193412"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>
</span><span id="line-347"></span><span id="unTypeQ"><span class="annot"><span class="annottext">unTypeQ :: forall a (m :: * -&gt; *). Quote m =&gt; m (TExp a) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#unTypeQ"><span class="hs-identifier hs-var hs-var">unTypeQ</span></a></span></span><span> </span><span id="local-6989586621679196299"><span class="annot"><span class="annottext">m (TExp a)
</span><a href="#local-6989586621679196299"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-type">TExp</span></a></span><span> </span><span id="local-6989586621679196300"><span class="annot"><a href="#local-6989586621679196300"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (TExp a)
</span><a href="#local-6989586621679196299"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-348"></span><span>               </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><a href="#local-6989586621679196300"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-349"></span><span>
</span><span id="line-350"></span><span class="hs-comment">-- | Annotate the Template Haskell expression with a type</span><span>
</span><span id="line-351"></span><span class="hs-comment">--</span><span>
</span><span id="line-352"></span><span class="hs-comment">-- This is unsafe because GHC cannot check for you that the expression</span><span>
</span><span id="line-353"></span><span class="hs-comment">-- really does have the type you claim it has.</span><span>
</span><span id="line-354"></span><span class="hs-comment">--</span><span>
</span><span id="line-355"></span><span class="hs-comment">-- Representation-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-356"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#unsafeTExpCoerce"><span class="hs-identifier hs-type">unsafeTExpCoerce</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193417"><span class="annot"><a href="#local-6989586621679193417"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193419"><span class="annot"><a href="#local-6989586621679193419"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193417"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679193418"><span class="annot"><a href="#local-6989586621679193418"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span>
</span><span id="line-357"></span><span>                      </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193418"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193418"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193418"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-type">TExp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193419"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-358"></span><span id="unsafeTExpCoerce"><span class="annot"><span class="annottext">unsafeTExpCoerce :: forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; m (TExp a)
</span><a href="Language.Haskell.TH.Syntax.html#unsafeTExpCoerce"><span class="hs-identifier hs-var hs-var">unsafeTExpCoerce</span></a></span></span><span> </span><span id="local-6989586621679196306"><span class="annot"><span class="annottext">m Exp
</span><a href="#local-6989586621679196306"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621679196307"><span class="annot"><a href="#local-6989586621679196307"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Exp
</span><a href="#local-6989586621679196306"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-359"></span><span>                        </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-type">TExp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196307"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-360"></span><span>
</span><span id="line-361"></span><span class="hs-comment">{- Note [Role of TExp]
~~~~~~~~~~~~~~~~~~~~~~
TExp's argument must have a nominal role, not phantom as would
be inferred (#8459).  Consider

  e :: Code Q Age
  e = [|| MkAge 3 ||]

  foo = $(coerce e) + 4::Int

The splice will evaluate to (MkAge 3) and you can't add that to
4::Int. So you can't coerce a (Code Q Age) to a (Code Q Int). -}</span><span>
</span><span id="line-373"></span><span>
</span><span id="line-374"></span><span class="hs-comment">-- Code constructor</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 909
</span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Type"><span class="hs-identifier hs-type">Kind.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Type"><span class="hs-identifier hs-type">Kind.Type</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193423"><span class="annot"><a href="#local-6989586621679193423"><span class="hs-identifier hs-type">r</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193423"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Type"><span class="hs-identifier hs-type">Kind.Type</span></a></span><span>
</span><span id="line-377"></span><span>  </span><span class="hs-comment">-- See Note [Foralls to the right in Code]</span><span class="hs-cpp">
#else
</span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Kind.Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Kind.Type</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Kind.Type</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">role</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><span class="hs-identifier">representational</span></span><span> </span><span class="annot"><span class="hs-identifier">nominal</span></span><span>   </span><span class="hs-comment">-- See Note [Role of TExp]</span><span>
</span><span id="line-382"></span><span class="hs-keyword">newtype</span><span> </span><span id="Code"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-var">Code</span></a></span></span><span> </span><span id="local-6989586621679193424"><span class="annot"><a href="#local-6989586621679193424"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679193425"><span class="annot"><a href="#local-6989586621679193425"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Code"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-var">Code</span></a></span></span><span>
</span><span id="line-383"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="examineCode"><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Code m a -&gt; m (TExp a)
</span><a href="Language.Haskell.TH.Syntax.html#examineCode"><span class="hs-identifier hs-var hs-var">examineCode</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679193424"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-type">TExp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193425"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Underlying monadic value</span></span><span>
</span><span id="line-384"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-385"></span><span class="hs-comment">-- ^ Represents an expression which has type @a@, built in monadic context @m@. Built on top of 'TExp', typed</span><span>
</span><span id="line-386"></span><span class="hs-comment">-- expressions allow for type-safe splicing via:</span><span>
</span><span id="line-387"></span><span class="hs-comment">--</span><span>
</span><span id="line-388"></span><span class="hs-comment">--   - typed quotes, written as @[|| ... ||]@ where @...@ is an expression; if</span><span>
</span><span id="line-389"></span><span class="hs-comment">--     that expression has type @a@, then the quotation has type</span><span>
</span><span id="line-390"></span><span class="hs-comment">--     @Quote m =&gt; Code m a@</span><span>
</span><span id="line-391"></span><span class="hs-comment">--</span><span>
</span><span id="line-392"></span><span class="hs-comment">--   - typed splices inside of typed quotes, written as @$$(...)@ where @...@</span><span>
</span><span id="line-393"></span><span class="hs-comment">--     is an arbitrary expression of type @Quote m =&gt; Code m a@</span><span>
</span><span id="line-394"></span><span class="hs-comment">--</span><span>
</span><span id="line-395"></span><span class="hs-comment">-- Traditional expression quotes and splices let us construct ill-typed</span><span>
</span><span id="line-396"></span><span class="hs-comment">-- expressions:</span><span>
</span><span id="line-397"></span><span class="hs-comment">--</span><span>
</span><span id="line-398"></span><span class="hs-comment">-- &gt;&gt;&gt; fmap ppr $ runQ (unTypeCode [| True == $( [| &quot;foo&quot; |] ) |])</span><span>
</span><span id="line-399"></span><span class="hs-comment">-- GHC.Types.True GHC.Classes.== &quot;foo&quot;</span><span>
</span><span id="line-400"></span><span class="hs-comment">-- &gt;&gt;&gt; GHC.Types.True GHC.Classes.== &quot;foo&quot;</span><span>
</span><span id="line-401"></span><span class="hs-comment">-- &lt;interactive&gt; error:</span><span>
</span><span id="line-402"></span><span class="hs-comment">--     &#8226; Couldn't match expected type &#8216;Bool&#8217; with actual type &#8216;[Char]&#8217;</span><span>
</span><span id="line-403"></span><span class="hs-comment">--     &#8226; In the second argument of &#8216;(==)&#8217;, namely &#8216;&quot;foo&quot;&#8217;</span><span>
</span><span id="line-404"></span><span class="hs-comment">--       In the expression: True == &quot;foo&quot;</span><span>
</span><span id="line-405"></span><span class="hs-comment">--       In an equation for &#8216;it&#8217;: it = True == &quot;foo&quot;</span><span>
</span><span id="line-406"></span><span class="hs-comment">--</span><span>
</span><span id="line-407"></span><span class="hs-comment">-- With typed expressions, the type error occurs when /constructing/ the</span><span>
</span><span id="line-408"></span><span class="hs-comment">-- Template Haskell expression:</span><span>
</span><span id="line-409"></span><span class="hs-comment">--</span><span>
</span><span id="line-410"></span><span class="hs-comment">-- &gt;&gt;&gt; fmap ppr $ runQ (unTypeCode [|| True == $$( [|| &quot;foo&quot; ||] ) ||])</span><span>
</span><span id="line-411"></span><span class="hs-comment">-- &lt;interactive&gt; error:</span><span>
</span><span id="line-412"></span><span class="hs-comment">--     &#8226; Couldn't match type &#8216;[Char]&#8217; with &#8216;Bool&#8217;</span><span>
</span><span id="line-413"></span><span class="hs-comment">--       Expected type: Code Q Bool</span><span>
</span><span id="line-414"></span><span class="hs-comment">--         Actual type: Code Q [Char]</span><span>
</span><span id="line-415"></span><span class="hs-comment">--     &#8226; In the Template Haskell quotation [|| &quot;foo&quot; ||]</span><span>
</span><span id="line-416"></span><span class="hs-comment">--       In the expression: [|| &quot;foo&quot; ||]</span><span>
</span><span id="line-417"></span><span class="hs-comment">--       In the Template Haskell splice $$([|| &quot;foo&quot; ||])</span><span>
</span><span id="line-418"></span><span>
</span><span id="line-419"></span><span>
</span><span id="line-420"></span><span class="hs-comment">{- Note [Foralls to the right in Code]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Code has the following type signature:
   type Code :: (Kind.Type -&gt; Kind.Type) -&gt; forall r. TYPE r -&gt; Kind.Type

This allows us to write
   data T (f :: forall r . (TYPE r) -&gt; Type) = MkT (f Int) (f Int#)

   tcodeq :: T (Code Q)
   tcodeq = MkT [||5||] [||5#||]

If we used the slightly more straightforward signature
   type Code :: foral r. (Kind.Type -&gt; Kind.Type) -&gt; TYPE r -&gt; Kind.Type

then the example above would become ill-typed.  (See #23592 for some discussion.)
-}</span><span>
</span><span id="line-436"></span><span>
</span><span id="line-437"></span><span class="hs-comment">-- | Unsafely convert an untyped code representation into a typed code</span><span>
</span><span id="line-438"></span><span class="hs-comment">-- representation.</span><span>
</span><span id="line-439"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-type">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193429"><span class="annot"><a href="#local-6989586621679193429"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193431"><span class="annot"><a href="#local-6989586621679193431"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193429"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679193430"><span class="annot"><a href="#local-6989586621679193430"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span>
</span><span id="line-440"></span><span>                      </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193430"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193430"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193430"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193431"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-441"></span><span id="unsafeCodeCoerce"><span class="annot"><span class="annottext">unsafeCodeCoerce :: forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var hs-var">unsafeCodeCoerce</span></a></span></span><span> </span><span id="local-6989586621679196312"><span class="annot"><span class="annottext">m Exp
</span><a href="#local-6989586621679196312"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp a) -&gt; Code m a
forall (m :: * -&gt; *) a. m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-var">Code</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m Exp -&gt; m (TExp a)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; m (TExp a)
</span><a href="Language.Haskell.TH.Syntax.html#unsafeTExpCoerce"><span class="hs-identifier hs-var">unsafeTExpCoerce</span></a></span><span> </span><span class="annot"><span class="annottext">m Exp
</span><a href="#local-6989586621679196312"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-442"></span><span>
</span><span id="line-443"></span><span class="hs-comment">-- | Lift a monadic action producing code into the typed 'Code'</span><span>
</span><span id="line-444"></span><span class="hs-comment">-- representation</span><span>
</span><span id="line-445"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#liftCode"><span class="hs-identifier hs-type">liftCode</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193435"><span class="annot"><a href="#local-6989586621679193435"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193437"><span class="annot"><a href="#local-6989586621679193437"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193435"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679193436"><span class="annot"><a href="#local-6989586621679193436"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="#local-6989586621679193436"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TExp"><span class="hs-identifier hs-type">TExp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193437"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193436"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193437"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-446"></span><span id="liftCode"><span class="annot"><span class="annottext">liftCode :: forall a (m :: * -&gt; *). m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#liftCode"><span class="hs-identifier hs-var hs-var">liftCode</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp a) -&gt; Code m a
forall (m :: * -&gt; *) a. m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-var">Code</span></a></span><span>
</span><span id="line-447"></span><span>
</span><span id="line-448"></span><span class="annot"><span class="hs-comment">-- | Extract the untyped representation from the typed representation</span></span><span>
</span><span id="line-449"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#unTypeCode"><span class="hs-identifier hs-type">unTypeCode</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193441"><span class="annot"><a href="#local-6989586621679193441"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193443"><span class="annot"><a href="#local-6989586621679193443"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193441"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679193442"><span class="annot"><a href="#local-6989586621679193442"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193442"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-450"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193442"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193443"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193442"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>
</span><span id="line-451"></span><span id="unTypeCode"><span class="annot"><span class="annottext">unTypeCode :: forall a (m :: * -&gt; *). Quote m =&gt; Code m a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#unTypeCode"><span class="hs-identifier hs-var hs-var">unTypeCode</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp a) -&gt; m Exp
forall a (m :: * -&gt; *). Quote m =&gt; m (TExp a) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#unTypeQ"><span class="hs-identifier hs-var">unTypeQ</span></a></span><span> </span><span class="annot"><span class="annottext">(m (TExp a) -&gt; m Exp)
-&gt; (Code m a -&gt; m (TExp a)) -&gt; Code m a -&gt; m Exp
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Code m a -&gt; m (TExp a)
forall (m :: * -&gt; *) a. Code m a -&gt; m (TExp a)
</span><a href="Language.Haskell.TH.Syntax.html#examineCode"><span class="hs-identifier hs-var">examineCode</span></a></span><span>
</span><span id="line-452"></span><span>
</span><span id="line-453"></span><span class="hs-comment">-- | Modify the ambient monad used during code generation. For example, you</span><span>
</span><span id="line-454"></span><span class="hs-comment">-- can use `hoistCode` to handle a state effect:</span><span>
</span><span id="line-455"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-456"></span><span class="hs-comment">--  handleState :: Code (StateT Int Q) a -&gt; Code Q a</span><span>
</span><span id="line-457"></span><span class="hs-comment">--  handleState = hoistCode (flip runState 0)</span><span>
</span><span id="line-458"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-459"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#hoistCode"><span class="hs-identifier hs-type">hoistCode</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193451"><span class="annot"><a href="#local-6989586621679193451"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679193453"><span class="annot"><a href="#local-6989586621679193453"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193450"><span class="annot"><a href="#local-6989586621679193450"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193454"><span class="annot"><a href="#local-6989586621679193454"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193450"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679193451"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-460"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193452"><span class="annot"><a href="#local-6989586621679193452"><span class="hs-identifier hs-type">x</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="#local-6989586621679193451"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193452"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193453"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193452"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193451"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193454"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193453"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193454"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-461"></span><span id="hoistCode"><span class="annot"><span class="annottext">hoistCode :: forall (m :: * -&gt; *) (n :: * -&gt; *) a.
Monad m =&gt;
(forall x. m x -&gt; n x) -&gt; Code m a -&gt; Code n a
</span><a href="Language.Haskell.TH.Syntax.html#hoistCode"><span class="hs-identifier hs-var hs-var">hoistCode</span></a></span></span><span> </span><span id="local-6989586621679196319"><span class="annot"><span class="annottext">forall x. m x -&gt; n x
</span><a href="#local-6989586621679196319"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span id="local-6989586621679196320"><span class="annot"><span class="annottext">m (TExp a)
</span><a href="#local-6989586621679196320"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">n (TExp a) -&gt; Code n a
forall (m :: * -&gt; *) a. m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-var">Code</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m (TExp a) -&gt; n (TExp a)
forall x. m x -&gt; n x
</span><a href="#local-6989586621679196319"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">m (TExp a)
</span><a href="#local-6989586621679196320"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-462"></span><span>
</span><span id="line-463"></span><span>
</span><span id="line-464"></span><span class="hs-comment">-- | Variant of (&gt;&gt;=) which allows effectful computations to be injected</span><span>
</span><span id="line-465"></span><span class="hs-comment">-- into code generation.</span><span>
</span><span id="line-466"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#bindCode"><span class="hs-identifier hs-type">bindCode</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193460"><span class="annot"><a href="#local-6989586621679193460"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679193461"><span class="annot"><a href="#local-6989586621679193461"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193459"><span class="annot"><a href="#local-6989586621679193459"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193462"><span class="annot"><a href="#local-6989586621679193462"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193459"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679193460"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-467"></span><span>         </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193460"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193461"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193461"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193460"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193462"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193460"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193462"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-468"></span><span id="bindCode"><span class="annot"><span class="annottext">bindCode :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
m a -&gt; (a -&gt; Code m b) -&gt; Code m b
</span><a href="Language.Haskell.TH.Syntax.html#bindCode"><span class="hs-identifier hs-var hs-var">bindCode</span></a></span></span><span> </span><span id="local-6989586621679196324"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679196324"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621679196325"><span class="annot"><span class="annottext">a -&gt; Code m b
</span><a href="#local-6989586621679196325"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp b) -&gt; Code m b
forall a (m :: * -&gt; *). m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#liftCode"><span class="hs-identifier hs-var">liftCode</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679196324"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; (a -&gt; m (TExp b)) -&gt; m (TExp b)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Code m b -&gt; m (TExp b)
forall (m :: * -&gt; *) a. Code m a -&gt; m (TExp a)
</span><a href="Language.Haskell.TH.Syntax.html#examineCode"><span class="hs-identifier hs-var">examineCode</span></a></span><span> </span><span class="annot"><span class="annottext">(Code m b -&gt; m (TExp b)) -&gt; (a -&gt; Code m b) -&gt; a -&gt; m (TExp b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Code m b
</span><a href="#local-6989586621679196325"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-469"></span><span>
</span><span id="line-470"></span><span class="hs-comment">-- | Variant of (&gt;&gt;) which allows effectful computations to be injected</span><span>
</span><span id="line-471"></span><span class="hs-comment">-- into code generation.</span><span>
</span><span id="line-472"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#bindCode_"><span class="hs-identifier hs-type">bindCode_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193468"><span class="annot"><a href="#local-6989586621679193468"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679193469"><span class="annot"><a href="#local-6989586621679193469"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193467"><span class="annot"><a href="#local-6989586621679193467"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193470"><span class="annot"><a href="#local-6989586621679193470"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193467"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679193468"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-473"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193468"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193469"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193468"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193470"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193468"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193470"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-474"></span><span id="bindCode_"><span class="annot"><span class="annottext">bindCode_ :: forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; Code m b -&gt; Code m b
</span><a href="Language.Haskell.TH.Syntax.html#bindCode_"><span class="hs-identifier hs-var hs-var">bindCode_</span></a></span></span><span> </span><span id="local-6989586621679196329"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679196329"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621679196330"><span class="annot"><span class="annottext">Code m b
</span><a href="#local-6989586621679196330"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp b) -&gt; Code m b
forall a (m :: * -&gt; *). m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#liftCode"><span class="hs-identifier hs-var">liftCode</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679196329"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m (TExp b) -&gt; m (TExp b)
forall a b. m a -&gt; m b -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Code m b -&gt; m (TExp b)
forall (m :: * -&gt; *) a. Code m a -&gt; m (TExp a)
</span><a href="Language.Haskell.TH.Syntax.html#examineCode"><span class="hs-identifier hs-var">examineCode</span></a></span><span> </span><span class="annot"><span class="annottext">Code m b
</span><a href="#local-6989586621679196330"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-475"></span><span>
</span><span id="line-476"></span><span class="hs-comment">-- | A useful combinator for embedding monadic actions into 'Code'</span><span>
</span><span id="line-477"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-478"></span><span class="hs-comment">-- myCode :: ... =&gt; Code m a</span><span>
</span><span id="line-479"></span><span class="hs-comment">-- myCode = joinCode $ do</span><span>
</span><span id="line-480"></span><span class="hs-comment">--   x &lt;- someSideEffect</span><span>
</span><span id="line-481"></span><span class="hs-comment">--   return (makeCodeWith x)</span><span>
</span><span id="line-482"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-483"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#joinCode"><span class="hs-identifier hs-type">joinCode</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193476"><span class="annot"><a href="#local-6989586621679193476"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193475"><span class="annot"><a href="#local-6989586621679193475"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#RuntimeRep"><span class="hs-identifier hs-type">RuntimeRep</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193477"><span class="annot"><a href="#local-6989586621679193477"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193475"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679193476"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-484"></span><span>         </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193476"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193476"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193477"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193476"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193477"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-485"></span><span id="joinCode"><span class="annot"><span class="annottext">joinCode :: forall (m :: * -&gt; *) a. Monad m =&gt; m (Code m a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#joinCode"><span class="hs-identifier hs-var hs-var">joinCode</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(m (Code m a) -&gt; (Code m a -&gt; Code m a) -&gt; Code m a)
-&gt; (Code m a -&gt; Code m a) -&gt; m (Code m a) -&gt; Code m a
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">m (Code m a) -&gt; (Code m a -&gt; Code m a) -&gt; Code m a
forall (m :: * -&gt; *) a b.
Monad m =&gt;
m a -&gt; (a -&gt; Code m b) -&gt; Code m b
</span><a href="Language.Haskell.TH.Syntax.html#bindCode"><span class="hs-identifier hs-var">bindCode</span></a></span><span> </span><span class="annot"><span class="annottext">Code m a -&gt; Code m a
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-486"></span><span>
</span><span id="line-487"></span><span class="hs-comment">----------------------------------------------------</span><span>
</span><span id="line-488"></span><span class="hs-comment">-- Packaged versions for the programmer, hiding the Quasi-ness</span><span>
</span><span id="line-489"></span><span>
</span><span id="line-490"></span><span>
</span><span id="line-491"></span><span class="hs-comment">-- | Report an error (True) or warning (False),</span><span>
</span><span id="line-492"></span><span class="hs-comment">-- but carry on; use 'fail' to stop.</span><span>
</span><span id="line-493"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#report"><span class="hs-identifier hs-type">report</span></a></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-494"></span><span id="report"><span class="annot"><span class="annottext">report :: Bool -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#report"><span class="hs-identifier hs-var hs-var">report</span></a></span></span><span> </span><span id="local-6989586621679196336"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679196336"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679196337"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196337"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ()) -&gt; Q ()
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; m ()
forall (m :: * -&gt; *). Quasi m =&gt; Bool -&gt; FilePath -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qReport"><span class="hs-identifier hs-var">qReport</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679196336"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196337"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-495"></span><span class="hs-pragma">{-# DEPRECATED</span><span> </span><span class="hs-pragma">report</span><span> </span><span class="hs-pragma">&quot;Use reportError or reportWarning instead&quot;</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="hs-comment">-- deprecated in 7.6</span><span>
</span><span id="line-496"></span><span>
</span><span id="line-497"></span><span class="annot"><span class="hs-comment">-- | Report an error to the user, but allow the current splice's computation to carry on. To abort the computation, use 'fail'.</span></span><span>
</span><span id="line-498"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reportError"><span class="hs-identifier hs-type">reportError</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-499"></span><span id="reportError"><span class="annot"><span class="annottext">reportError :: FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#reportError"><span class="hs-identifier hs-var hs-var">reportError</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#report"><span class="hs-identifier hs-var">report</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-500"></span><span>
</span><span id="line-501"></span><span class="annot"><span class="hs-comment">-- | Report a warning to the user, and carry on.</span></span><span>
</span><span id="line-502"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reportWarning"><span class="hs-identifier hs-type">reportWarning</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-503"></span><span id="reportWarning"><span class="annot"><span class="annottext">reportWarning :: FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#reportWarning"><span class="hs-identifier hs-var hs-var">reportWarning</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#report"><span class="hs-identifier hs-var">report</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-504"></span><span>
</span><span id="line-505"></span><span class="annot"><span class="hs-comment">-- | Recover from errors raised by 'reportError' or 'fail'.</span></span><span>
</span><span id="line-506"></span><span id="local-6989586621679193486"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#recover"><span class="hs-identifier hs-type">recover</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193486"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ handler to invoke on failure</span></span><span>
</span><span id="line-507"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193486"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ computation to run</span></span><span>
</span><span id="line-508"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193486"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-509"></span><span id="recover"><span class="annot"><span class="annottext">recover :: forall a. Q a -&gt; Q a -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#recover"><span class="hs-identifier hs-var hs-var">recover</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196343"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196343"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span id="local-6989586621679196344"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196344"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a -&gt; m a -&gt; m a
forall a. m a -&gt; m a -&gt; m a
forall (m :: * -&gt; *) a. Quasi m =&gt; m a -&gt; m a -&gt; m a
</span><a href="Language.Haskell.TH.Syntax.html#qRecover"><span class="hs-identifier hs-var">qRecover</span></a></span><span> </span><span class="annot"><span class="annottext">m a
forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196343"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">m a
forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="#local-6989586621679196344"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-510"></span><span>
</span><span id="line-511"></span><span class="hs-comment">-- We don't export lookupName; the Bool isn't a great API</span><span>
</span><span id="line-512"></span><span class="hs-comment">-- Instead we export lookupTypeName, lookupValueName</span><span>
</span><span id="line-513"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lookupName"><span class="hs-identifier hs-type">lookupName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-514"></span><span id="lookupName"><span class="annot"><span class="annottext">lookupName :: Bool -&gt; FilePath -&gt; Q (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#lookupName"><span class="hs-identifier hs-var hs-var">lookupName</span></a></span></span><span> </span><span id="local-6989586621679196350"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679196350"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679196351"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196351"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m (Maybe Name)) -&gt; Q (Maybe Name)
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; m (Maybe Name)
forall (m :: * -&gt; *). Quasi m =&gt; Bool -&gt; FilePath -&gt; m (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#qLookupName"><span class="hs-identifier hs-var">qLookupName</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679196350"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196351"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-515"></span><span>
</span><span id="line-516"></span><span class="annot"><span class="hs-comment">-- | Look up the given name in the (type namespace of the) current splice's scope. See &quot;Language.Haskell.TH.Syntax#namelookup&quot; for more details.</span></span><span>
</span><span id="line-517"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lookupTypeName"><span class="hs-identifier hs-type">lookupTypeName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-518"></span><span id="lookupTypeName"><span class="annot"><span class="annottext">lookupTypeName :: FilePath -&gt; Q (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#lookupTypeName"><span class="hs-identifier hs-var hs-var">lookupTypeName</span></a></span></span><span>  </span><span id="local-6989586621679196355"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196355"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m (Maybe Name)) -&gt; Q (Maybe Name)
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; m (Maybe Name)
forall (m :: * -&gt; *). Quasi m =&gt; Bool -&gt; FilePath -&gt; m (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#qLookupName"><span class="hs-identifier hs-var">qLookupName</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196355"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-519"></span><span>
</span><span id="line-520"></span><span class="annot"><span class="hs-comment">-- | Look up the given name in the (value namespace of the) current splice's scope. See &quot;Language.Haskell.TH.Syntax#namelookup&quot; for more details.</span></span><span>
</span><span id="line-521"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lookupValueName"><span class="hs-identifier hs-type">lookupValueName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-522"></span><span id="lookupValueName"><span class="annot"><span class="annottext">lookupValueName :: FilePath -&gt; Q (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#lookupValueName"><span class="hs-identifier hs-var hs-var">lookupValueName</span></a></span></span><span> </span><span id="local-6989586621679196359"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196359"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m (Maybe Name)) -&gt; Q (Maybe Name)
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; m (Maybe Name)
forall (m :: * -&gt; *). Quasi m =&gt; Bool -&gt; FilePath -&gt; m (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#qLookupName"><span class="hs-identifier hs-var">qLookupName</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196359"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-523"></span><span>
</span><span id="line-524"></span><span class="hs-comment">{-
Note [Name lookup]
~~~~~~~~~~~~~~~~~~
-}</span><span>
</span><span id="line-528"></span><span class="annot"><span class="hs-comment">{- $namelookup #namelookup#
The functions 'lookupTypeName' and 'lookupValueName' provide
a way to query the current splice's context for what names
are in scope. The function 'lookupTypeName' queries the type
namespace, whereas 'lookupValueName' queries the value namespace,
but the functions are otherwise identical.

A call @lookupValueName s@ will check if there is a value
with name @s@ in scope at the current splice's location. If
there is, the @Name@ of this value is returned;
if not, then @Nothing@ is returned.

The returned name cannot be \&quot;captured\&quot;.
For example:

&gt; f = &quot;global&quot;
&gt; g = $( do
&gt;          Just nm &lt;- lookupValueName &quot;f&quot;
&gt;          [| let f = &quot;local&quot; in $( varE nm ) |]

In this case, @g = \&quot;global\&quot;@; the call to @lookupValueName@
returned the global @f@, and this name was /not/ captured by
the local definition of @f@.

The lookup is performed in the context of the /top-level/ splice
being run. For example:

&gt; f = &quot;global&quot;
&gt; g = $( [| let f = &quot;local&quot; in
&gt;            $(do
&gt;                Just nm &lt;- lookupValueName &quot;f&quot;
&gt;                varE nm
&gt;             ) |] )

Again in this example, @g = \&quot;global\&quot;@, because the call to
@lookupValueName@ queries the context of the outer-most @$(...)@.

Operators should be queried without any surrounding parentheses, like so:

&gt; lookupValueName &quot;+&quot;

Qualified names are also supported, like so:

&gt; lookupValueName &quot;Prelude.+&quot;
&gt; lookupValueName &quot;Prelude.map&quot;

-}</span></span><span>
</span><span id="line-575"></span><span>
</span><span id="line-576"></span><span>
</span><span id="line-577"></span><span class="annot"><span class="hs-comment">{- | 'reify' looks up information about the 'Name'. It will fail with
a compile error if the 'Name' is not visible. A 'Name' is visible if it is
imported or defined in a prior top-level declaration group. See the
documentation for 'newDeclarationGroup' for more details.

It is sometimes useful to construct the argument name using 'lookupTypeName' or 'lookupValueName'
to ensure that we are reifying from the right namespace. For instance, in this context:

&gt; data D = D

which @D@ does @reify (mkName \&quot;D\&quot;)@ return information about? (Answer: @D@-the-type, but don't rely on it.)
To ensure we get information about @D@-the-value, use 'lookupValueName':

&gt; do
&gt;   Just nm &lt;- lookupValueName &quot;D&quot;
&gt;   reify nm

and to get information about @D@-the-type, use 'lookupTypeName'.
-}</span></span><span>
</span><span id="line-596"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reify"><span class="hs-identifier hs-type">reify</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Info"><span class="hs-identifier hs-type">Info</span></a></span><span>
</span><span id="line-597"></span><span id="reify"><span class="annot"><span class="annottext">reify :: Name -&gt; Q Info
</span><a href="Language.Haskell.TH.Syntax.html#reify"><span class="hs-identifier hs-var hs-var">reify</span></a></span></span><span> </span><span id="local-6989586621679196365"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196365"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m Info) -&gt; Q Info
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; m Info
forall (m :: * -&gt; *). Quasi m =&gt; Name -&gt; m Info
</span><a href="Language.Haskell.TH.Syntax.html#qReify"><span class="hs-identifier hs-var">qReify</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196365"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-598"></span><span>
</span><span id="line-599"></span><span class="annot"><span class="hs-comment">{- | @reifyFixity nm@ attempts to find a fixity declaration for @nm@. For
example, if the function @foo@ has the fixity declaration @infixr 7 foo@, then
@reifyFixity 'foo@ would return @'Just' ('Fixity' 7 'InfixR')@. If the function
@bar@ does not have a fixity declaration, then @reifyFixity 'bar@ returns
'Nothing', so you may assume @bar@ has 'defaultFixity'.
-}</span></span><span>
</span><span id="line-605"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reifyFixity"><span class="hs-identifier hs-type">reifyFixity</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-606"></span><span id="reifyFixity"><span class="annot"><span class="annottext">reifyFixity :: Name -&gt; Q (Maybe Fixity)
</span><a href="Language.Haskell.TH.Syntax.html#reifyFixity"><span class="hs-identifier hs-var hs-var">reifyFixity</span></a></span></span><span> </span><span id="local-6989586621679196372"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196372"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m (Maybe Fixity))
-&gt; Q (Maybe Fixity)
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; m (Maybe Fixity)
forall (m :: * -&gt; *). Quasi m =&gt; Name -&gt; m (Maybe Fixity)
</span><a href="Language.Haskell.TH.Syntax.html#qReifyFixity"><span class="hs-identifier hs-var">qReifyFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196372"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-607"></span><span>
</span><span id="line-608"></span><span class="annot"><span class="hs-comment">{- | @reifyType nm@ attempts to find the type or kind of @nm@. For example,
@reifyType 'not@   returns @Bool -&gt; Bool@, and
@reifyType ''Bool@ returns @Type@.
This works even if there's no explicit signature and the type or kind is inferred.
-}</span></span><span>
</span><span id="line-613"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reifyType"><span class="hs-identifier hs-type">reifyType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-614"></span><span id="reifyType"><span class="annot"><span class="annottext">reifyType :: Name -&gt; Q Type
</span><a href="Language.Haskell.TH.Syntax.html#reifyType"><span class="hs-identifier hs-var hs-var">reifyType</span></a></span></span><span> </span><span id="local-6989586621679196376"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196376"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m Type) -&gt; Q Type
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; m Type
forall (m :: * -&gt; *). Quasi m =&gt; Name -&gt; m Type
</span><a href="Language.Haskell.TH.Syntax.html#qReifyType"><span class="hs-identifier hs-var">qReifyType</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196376"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-615"></span><span>
</span><span id="line-616"></span><span class="annot"><span class="hs-comment">{- | Template Haskell is capable of reifying information about types and
terms defined in previous declaration groups. Top-level declaration splices break up
declaration groups.

For an example, consider this  code block. We define a datatype @X@ and
then try to call 'reify' on the datatype.

@
module Check where

data X = X
    deriving Eq

$(do
    info &lt;- reify ''X
    runIO $ print info
 )
@

This code fails to compile, noting that @X@ is not available for reification at the site of 'reify'. We can fix this by creating a new declaration group using an empty top-level splice:

@
data X = X
    deriving Eq

$(pure [])

$(do
    info &lt;- reify ''X
    runIO $ print info
 )
@

We provide 'newDeclarationGroup' as a means of documenting this behavior
and providing a name for the pattern.

Since top level splices infer the presence of the @$( ... )@ brackets, we can also write:

@
data X = X
    deriving Eq

newDeclarationGroup

$(do
    info &lt;- reify ''X
    runIO $ print info
 )
@

-}</span></span><span>
</span><span id="line-667"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#newDeclarationGroup"><span class="hs-identifier hs-type">newDeclarationGroup</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-668"></span><span id="newDeclarationGroup"><span class="annot"><span class="annottext">newDeclarationGroup :: Q [Dec]
</span><a href="Language.Haskell.TH.Syntax.html#newDeclarationGroup"><span class="hs-identifier hs-var hs-var">newDeclarationGroup</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Dec] -&gt; Q [Dec]
forall a. a -&gt; Q a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-669"></span><span>
</span><span id="line-670"></span><span class="annot"><span class="hs-comment">{- | @reifyInstances nm tys@ returns a list of all visible instances (see below for &quot;visible&quot;)
of @nm tys@. That is,
if @nm@ is the name of a type class, then all instances of this class at the types @tys@
are returned. Alternatively, if @nm@ is the name of a data family or type family,
all instances of this family at the types @tys@ are returned.

Note that this is a \&quot;shallow\&quot; test; the declarations returned merely have
instance heads which unify with @nm tys@, they need not actually be satisfiable.

  - @reifyInstances ''Eq [ 'TupleT' 2 \``AppT`\` 'ConT' ''A \``AppT`\` 'ConT' ''B ]@ contains
    the @instance (Eq a, Eq b) =&gt; Eq (a, b)@ regardless of whether @A@ and
    @B@ themselves implement 'Eq'

  - @reifyInstances ''Show [ 'VarT' ('mkName' &quot;a&quot;) ]@ produces every available
    instance of 'Show'

There is one edge case: @reifyInstances ''Typeable tys@ currently always
produces an empty list (no matter what @tys@ are given).

In principle, the *visible* instances are
* all instances defined in a prior top-level declaration group
  (see docs on @newDeclarationGroup@), or
* all instances defined in any module transitively imported by the
  module being compiled

However, actually searching all modules transitively below the one being
compiled is unreasonably expensive, so @reifyInstances@ will report only the
instance for modules that GHC has had some cause to visit during this
compilation.  This is a shortcoming: @reifyInstances@ might fail to report
instances for a type that is otherwise unusued, or instances defined in a
different component.  You can work around this shortcoming by explicitly importing the modules
whose instances you want to be visible. GHC issue &lt;https://gitlab.haskell.org/ghc/ghc/-/issues/20529#note_388980 #20529&gt;
has some discussion around this.

-}</span></span><span>
</span><span id="line-705"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reifyInstances"><span class="hs-identifier hs-type">reifyInstances</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InstanceDec"><span class="hs-identifier hs-type">InstanceDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-706"></span><span id="reifyInstances"><span class="annot"><span class="annottext">reifyInstances :: Name -&gt; [Type] -&gt; Q [Dec]
</span><a href="Language.Haskell.TH.Syntax.html#reifyInstances"><span class="hs-identifier hs-var hs-var">reifyInstances</span></a></span></span><span> </span><span id="local-6989586621679196385"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196385"><span class="hs-identifier hs-var">cls</span></a></span></span><span> </span><span id="local-6989586621679196386"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679196386"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m [Dec]) -&gt; Q [Dec]
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; [Type] -&gt; m [Dec]
forall (m :: * -&gt; *). Quasi m =&gt; Name -&gt; [Type] -&gt; m [Dec]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyInstances"><span class="hs-identifier hs-var">qReifyInstances</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196385"><span class="hs-identifier hs-var">cls</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679196386"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-707"></span><span>
</span><span id="line-708"></span><span class="annot"><span class="hs-comment">{- | @reifyRoles nm@ returns the list of roles associated with the parameters
(both visible and invisible) of
the tycon @nm@. Fails if @nm@ cannot be found or is not a tycon.
The returned list should never contain 'InferR'.

An invisible parameter to a tycon is often a kind parameter. For example, if
we have

@
type Proxy :: forall k. k -&gt; Type
data Proxy a = MkProxy
@

and @reifyRoles Proxy@, we will get @['NominalR', 'PhantomR']@. The 'NominalR' is
the role of the invisible @k@ parameter. Kind parameters are always nominal.
-}</span></span><span>
</span><span id="line-724"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reifyRoles"><span class="hs-identifier hs-type">reifyRoles</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Role"><span class="hs-identifier hs-type">Role</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-725"></span><span id="reifyRoles"><span class="annot"><span class="annottext">reifyRoles :: Name -&gt; Q [Role]
</span><a href="Language.Haskell.TH.Syntax.html#reifyRoles"><span class="hs-identifier hs-var hs-var">reifyRoles</span></a></span></span><span> </span><span id="local-6989586621679196393"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196393"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m [Role]) -&gt; Q [Role]
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; m [Role]
forall (m :: * -&gt; *). Quasi m =&gt; Name -&gt; m [Role]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyRoles"><span class="hs-identifier hs-var">qReifyRoles</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196393"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-726"></span><span>
</span><span id="line-727"></span><span class="hs-comment">-- | @reifyAnnotations target@ returns the list of annotations</span><span>
</span><span id="line-728"></span><span class="hs-comment">-- associated with @target@.  Only the annotations that are</span><span>
</span><span id="line-729"></span><span class="hs-comment">-- appropriately typed is returned.  So if you have @Int@ and @String@</span><span>
</span><span id="line-730"></span><span class="hs-comment">-- annotations for the same target, you have to call this function twice.</span><span>
</span><span id="line-731"></span><span id="local-6989586621679193498"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reifyAnnotations"><span class="hs-identifier hs-type">reifyAnnotations</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193498"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnnLookup"><span class="hs-identifier hs-type">AnnLookup</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679193498"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-732"></span><span id="reifyAnnotations"><span class="annot"><span class="annottext">reifyAnnotations :: forall a. Data a =&gt; AnnLookup -&gt; Q [a]
</span><a href="Language.Haskell.TH.Syntax.html#reifyAnnotations"><span class="hs-identifier hs-var hs-var">reifyAnnotations</span></a></span></span><span> </span><span id="local-6989586621679196398"><span class="annot"><span class="annottext">AnnLookup
</span><a href="#local-6989586621679196398"><span class="hs-identifier hs-var">an</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m [a]) -&gt; Q [a]
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">AnnLookup -&gt; m [a]
forall a. Data a =&gt; AnnLookup -&gt; m [a]
forall (m :: * -&gt; *) a. (Quasi m, Data a) =&gt; AnnLookup -&gt; m [a]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyAnnotations"><span class="hs-identifier hs-var">qReifyAnnotations</span></a></span><span> </span><span class="annot"><span class="annottext">AnnLookup
</span><a href="#local-6989586621679196398"><span class="hs-identifier hs-var">an</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-733"></span><span>
</span><span id="line-734"></span><span class="hs-comment">-- | @reifyModule mod@ looks up information about module @mod@.  To</span><span>
</span><span id="line-735"></span><span class="hs-comment">-- look up the current module, call this function with the return</span><span>
</span><span id="line-736"></span><span class="hs-comment">-- value of 'Language.Haskell.TH.Lib.thisModule'.</span><span>
</span><span id="line-737"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reifyModule"><span class="hs-identifier hs-type">reifyModule</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModuleInfo"><span class="hs-identifier hs-type">ModuleInfo</span></a></span><span>
</span><span id="line-738"></span><span id="reifyModule"><span class="annot"><span class="annottext">reifyModule :: Module -&gt; Q ModuleInfo
</span><a href="Language.Haskell.TH.Syntax.html#reifyModule"><span class="hs-identifier hs-var hs-var">reifyModule</span></a></span></span><span> </span><span id="local-6989586621679196403"><span class="annot"><span class="annottext">Module
</span><a href="#local-6989586621679196403"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ModuleInfo) -&gt; Q ModuleInfo
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Module -&gt; m ModuleInfo
forall (m :: * -&gt; *). Quasi m =&gt; Module -&gt; m ModuleInfo
</span><a href="Language.Haskell.TH.Syntax.html#qReifyModule"><span class="hs-identifier hs-var">qReifyModule</span></a></span><span> </span><span class="annot"><span class="annottext">Module
</span><a href="#local-6989586621679196403"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-739"></span><span>
</span><span id="line-740"></span><span class="hs-comment">-- | @reifyConStrictness nm@ looks up the strictness information for the fields</span><span>
</span><span id="line-741"></span><span class="hs-comment">-- of the constructor with the name @nm@. Note that the strictness information</span><span>
</span><span id="line-742"></span><span class="hs-comment">-- that 'reifyConStrictness' returns may not correspond to what is written in</span><span>
</span><span id="line-743"></span><span class="hs-comment">-- the source code. For example, in the following data declaration:</span><span>
</span><span id="line-744"></span><span class="hs-comment">--</span><span>
</span><span id="line-745"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-746"></span><span class="hs-comment">-- data Pair a = Pair a a</span><span>
</span><span id="line-747"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-748"></span><span class="hs-comment">--</span><span>
</span><span id="line-749"></span><span class="hs-comment">-- 'reifyConStrictness' would return @['DecidedLazy', DecidedLazy]@ under most</span><span>
</span><span id="line-750"></span><span class="hs-comment">-- circumstances, but it would return @['DecidedStrict', DecidedStrict]@ if the</span><span>
</span><span id="line-751"></span><span class="hs-comment">-- @-XStrictData@ language extension was enabled.</span><span>
</span><span id="line-752"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#reifyConStrictness"><span class="hs-identifier hs-type">reifyConStrictness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DecidedStrictness"><span class="hs-identifier hs-type">DecidedStrictness</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-753"></span><span id="reifyConStrictness"><span class="annot"><span class="annottext">reifyConStrictness :: Name -&gt; Q [DecidedStrictness]
</span><a href="Language.Haskell.TH.Syntax.html#reifyConStrictness"><span class="hs-identifier hs-var hs-var">reifyConStrictness</span></a></span></span><span> </span><span id="local-6989586621679196409"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196409"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m [DecidedStrictness])
-&gt; Q [DecidedStrictness]
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; m [DecidedStrictness]
forall (m :: * -&gt; *). Quasi m =&gt; Name -&gt; m [DecidedStrictness]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyConStrictness"><span class="hs-identifier hs-var">qReifyConStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196409"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-754"></span><span>
</span><span id="line-755"></span><span class="hs-comment">-- | Is the list of instances returned by 'reifyInstances' nonempty?</span><span>
</span><span id="line-756"></span><span class="hs-comment">--</span><span>
</span><span id="line-757"></span><span class="hs-comment">-- If you're confused by an instance not being visible despite being</span><span>
</span><span id="line-758"></span><span class="hs-comment">-- defined in the same module and above the splice in question, see the</span><span>
</span><span id="line-759"></span><span class="hs-comment">-- docs for 'newDeclarationGroup' for a possible explanation.</span><span>
</span><span id="line-760"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#isInstance"><span class="hs-identifier hs-type">isInstance</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-761"></span><span id="isInstance"><span class="annot"><span class="annottext">isInstance :: Name -&gt; [Type] -&gt; Q Bool
</span><a href="Language.Haskell.TH.Syntax.html#isInstance"><span class="hs-identifier hs-var hs-var">isInstance</span></a></span></span><span> </span><span id="local-6989586621679196413"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196413"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span id="local-6989586621679196414"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679196414"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621679196415"><span class="annot"><a href="#local-6989586621679196415"><span class="hs-identifier hs-var">decs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Type] -&gt; Q [Dec]
</span><a href="Language.Haskell.TH.Syntax.html#reifyInstances"><span class="hs-identifier hs-var">reifyInstances</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679196413"><span class="hs-identifier hs-var">nm</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679196414"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-762"></span><span>                       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#not"><span class="hs-identifier hs-type">not</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">null</span></span><span> </span><span class="annot"><a href="#local-6989586621679196415"><span class="hs-identifier hs-type">decs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-763"></span><span>
</span><span id="line-764"></span><span class="annot"><span class="hs-comment">-- | The location at which this computation is spliced.</span></span><span>
</span><span id="line-765"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#location"><span class="hs-identifier hs-type">location</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Loc"><span class="hs-identifier hs-type">Loc</span></a></span><span>
</span><span id="line-766"></span><span id="location"><span class="annot"><span class="annottext">location :: Q Loc
</span><a href="Language.Haskell.TH.Syntax.html#location"><span class="hs-identifier hs-var hs-var">location</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m Loc) -&gt; Q Loc
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="annot"><span class="annottext">m Loc
forall (m :: * -&gt; *). Quasi m =&gt; m Loc
</span><a href="Language.Haskell.TH.Syntax.html#qLocation"><span class="hs-identifier hs-var">qLocation</span></a></span><span>
</span><span id="line-767"></span><span>
</span><span id="line-768"></span><span class="hs-comment">-- |The 'runIO' function lets you run an I\/O computation in the 'Q' monad.</span><span>
</span><span id="line-769"></span><span class="hs-comment">-- Take care: you are guaranteed the ordering of calls to 'runIO' within</span><span>
</span><span id="line-770"></span><span class="hs-comment">-- a single 'Q' computation, but not about the order in which splices are run.</span><span>
</span><span id="line-771"></span><span class="hs-comment">--</span><span>
</span><span id="line-772"></span><span class="hs-comment">-- Note: for various murky reasons, stdout and stderr handles are not</span><span>
</span><span id="line-773"></span><span class="hs-comment">-- necessarily flushed when the compiler finishes running, so you should</span><span>
</span><span id="line-774"></span><span class="hs-comment">-- flush them yourself.</span><span>
</span><span id="line-775"></span><span id="local-6989586621679193397"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#runIO"><span class="hs-identifier hs-type">runIO</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193397"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193397"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-776"></span><span id="runIO"><span class="annot"><span class="annottext">runIO :: forall a. IO a -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#runIO"><span class="hs-identifier hs-var hs-var">runIO</span></a></span></span><span> </span><span id="local-6989586621679196421"><span class="annot"><span class="annottext">IO a
</span><a href="#local-6989586621679196421"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IO a -&gt; m a
forall a. IO a -&gt; m a
forall (m :: * -&gt; *) a. Quasi m =&gt; IO a -&gt; m a
</span><a href="Language.Haskell.TH.Syntax.html#qRunIO"><span class="hs-identifier hs-var">qRunIO</span></a></span><span> </span><span class="annot"><span class="annottext">IO a
</span><a href="#local-6989586621679196421"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-777"></span><span>
</span><span id="line-778"></span><span class="hs-comment">-- | Get the package root for the current package which is being compiled.</span><span>
</span><span id="line-779"></span><span class="hs-comment">-- This can be set explicitly with the -package-root flag but is normally</span><span>
</span><span id="line-780"></span><span class="hs-comment">-- just the current working directory.</span><span>
</span><span id="line-781"></span><span class="hs-comment">--</span><span>
</span><span id="line-782"></span><span class="hs-comment">-- The motivation for this flag is to provide a principled means to remove the</span><span>
</span><span id="line-783"></span><span class="hs-comment">-- assumption from splices that they will be executed in the directory where the</span><span>
</span><span id="line-784"></span><span class="hs-comment">-- cabal file resides. Projects such as haskell-language-server can't and don't</span><span>
</span><span id="line-785"></span><span class="hs-comment">-- change directory when compiling files but instead set the -package-root flag</span><span>
</span><span id="line-786"></span><span class="hs-comment">-- appropriately.</span><span>
</span><span id="line-787"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#getPackageRoot"><span class="hs-identifier hs-type">getPackageRoot</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-788"></span><span id="getPackageRoot"><span class="annot"><span class="annottext">getPackageRoot :: Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#getPackageRoot"><span class="hs-identifier hs-var hs-var">getPackageRoot</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m FilePath) -&gt; Q FilePath
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="annot"><span class="annottext">m FilePath
forall (m :: * -&gt; *). Quasi m =&gt; m FilePath
</span><a href="Language.Haskell.TH.Syntax.html#qGetPackageRoot"><span class="hs-identifier hs-var">qGetPackageRoot</span></a></span><span>
</span><span id="line-789"></span><span>
</span><span id="line-790"></span><span class="annot"><span class="hs-comment">-- | The input is a filepath, which if relative is offset by the package root.</span></span><span>
</span><span id="line-791"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#makeRelativeToProject"><span class="hs-identifier hs-type">makeRelativeToProject</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-792"></span><span id="makeRelativeToProject"><span class="annot"><span class="annottext">makeRelativeToProject :: FilePath -&gt; Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#makeRelativeToProject"><span class="hs-identifier hs-var hs-var">makeRelativeToProject</span></a></span></span><span> </span><span id="local-6989586621679196428"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196428"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Bool
</span><a href="System.FilePath.Posix.html#isRelative"><span class="hs-identifier hs-var">isRelative</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196428"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-793"></span><span>  </span><span id="local-6989586621679196430"><span class="annot"><a href="#local-6989586621679196430"><span class="hs-identifier hs-var">root</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#getPackageRoot"><span class="hs-identifier hs-var">getPackageRoot</span></a></span><span>
</span><span id="line-794"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679196430"><span class="hs-identifier hs-type">root</span></a></span><span> </span><span class="annot"><a href="System.FilePath.Posix.html#%3C%2F%3E"><span class="hs-operator hs-type">&lt;/&gt;</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196428"><span class="hs-identifier hs-type">fp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-795"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#makeRelativeToProject"><span class="hs-identifier hs-var">makeRelativeToProject</span></a></span><span> </span><span id="local-6989586621679196432"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196432"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Q FilePath
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196432"><span class="hs-identifier hs-var">fp</span></a></span><span>
</span><span id="line-796"></span><span>
</span><span id="line-797"></span><span>
</span><span id="line-798"></span><span>
</span><span id="line-799"></span><span class="hs-comment">-- | Record external files that runIO is using (dependent upon).</span><span>
</span><span id="line-800"></span><span class="hs-comment">-- The compiler can then recognize that it should re-compile the Haskell file</span><span>
</span><span id="line-801"></span><span class="hs-comment">-- when an external file changes.</span><span>
</span><span id="line-802"></span><span class="hs-comment">--</span><span>
</span><span id="line-803"></span><span class="hs-comment">-- Expects an absolute file path.</span><span>
</span><span id="line-804"></span><span class="hs-comment">--</span><span>
</span><span id="line-805"></span><span class="hs-comment">-- Notes:</span><span>
</span><span id="line-806"></span><span class="hs-comment">--</span><span>
</span><span id="line-807"></span><span class="hs-comment">--   * ghc -M does not know about these dependencies - it does not execute TH.</span><span>
</span><span id="line-808"></span><span class="hs-comment">--</span><span>
</span><span id="line-809"></span><span class="hs-comment">--   * The dependency is based on file content, not a modification time</span><span>
</span><span id="line-810"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addDependentFile"><span class="hs-identifier hs-type">addDependentFile</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-811"></span><span id="addDependentFile"><span class="annot"><span class="annottext">addDependentFile :: FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addDependentFile"><span class="hs-identifier hs-var hs-var">addDependentFile</span></a></span></span><span> </span><span id="local-6989586621679196434"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196434"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ()) -&gt; Q ()
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; m ()
forall (m :: * -&gt; *). Quasi m =&gt; FilePath -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddDependentFile"><span class="hs-identifier hs-var">qAddDependentFile</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196434"><span class="hs-identifier hs-var">fp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-812"></span><span>
</span><span id="line-813"></span><span class="hs-comment">-- | Obtain a temporary file path with the given suffix. The compiler will</span><span>
</span><span id="line-814"></span><span class="hs-comment">-- delete this file after compilation.</span><span>
</span><span id="line-815"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addTempFile"><span class="hs-identifier hs-type">addTempFile</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-816"></span><span id="addTempFile"><span class="annot"><span class="annottext">addTempFile :: FilePath -&gt; Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#addTempFile"><span class="hs-identifier hs-var hs-var">addTempFile</span></a></span></span><span> </span><span id="local-6989586621679196438"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196438"><span class="hs-identifier hs-var">suffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m FilePath) -&gt; Q FilePath
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; m FilePath
forall (m :: * -&gt; *). Quasi m =&gt; FilePath -&gt; m FilePath
</span><a href="Language.Haskell.TH.Syntax.html#qAddTempFile"><span class="hs-identifier hs-var">qAddTempFile</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196438"><span class="hs-identifier hs-var">suffix</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-817"></span><span>
</span><span id="line-818"></span><span class="hs-comment">-- | Add additional top-level declarations. The added declarations will be type</span><span>
</span><span id="line-819"></span><span class="hs-comment">-- checked along with the current declaration group.</span><span>
</span><span id="line-820"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addTopDecls"><span class="hs-identifier hs-type">addTopDecls</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-821"></span><span id="addTopDecls"><span class="annot"><span class="annottext">addTopDecls :: [Dec] -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addTopDecls"><span class="hs-identifier hs-var hs-var">addTopDecls</span></a></span></span><span> </span><span id="local-6989586621679196442"><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679196442"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ()) -&gt; Q ()
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Dec] -&gt; m ()
forall (m :: * -&gt; *). Quasi m =&gt; [Dec] -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddTopDecls"><span class="hs-identifier hs-var">qAddTopDecls</span></a></span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679196442"><span class="hs-identifier hs-var">ds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-822"></span><span>
</span><span id="line-823"></span><span class="annot"><span class="hs-comment">-- |</span></span><span>
</span><span id="line-824"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addForeignFile"><span class="hs-identifier hs-type">addForeignFile</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#ForeignSrcLang"><span class="hs-identifier hs-type">ForeignSrcLang</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-825"></span><span id="addForeignFile"><span class="annot"><span class="annottext">addForeignFile :: ForeignSrcLang -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addForeignFile"><span class="hs-identifier hs-var hs-var">addForeignFile</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ForeignSrcLang -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addForeignSource"><span class="hs-identifier hs-var">addForeignSource</span></a></span><span>
</span><span id="line-826"></span><span class="hs-pragma">{-# DEPRECATED</span><span> </span><span class="hs-pragma">addForeignFile</span><span>
</span><span id="line-827"></span><span>               </span><span class="hs-pragma">&quot;Use 'Language.Haskell.TH.Syntax.addForeignSource' instead&quot;</span><span>
</span><span id="line-828"></span><span>  </span><span class="hs-pragma">#-}</span><span> </span><span class="hs-comment">-- deprecated in 8.6</span><span>
</span><span id="line-829"></span><span>
</span><span id="line-830"></span><span class="hs-comment">-- | Emit a foreign file which will be compiled and linked to the object for</span><span>
</span><span id="line-831"></span><span class="hs-comment">-- the current module. Currently only languages that can be compiled with</span><span>
</span><span id="line-832"></span><span class="hs-comment">-- the C compiler are supported, and the flags passed as part of -optc will</span><span>
</span><span id="line-833"></span><span class="hs-comment">-- be also applied to the C compiler invocation that will compile them.</span><span>
</span><span id="line-834"></span><span class="hs-comment">--</span><span>
</span><span id="line-835"></span><span class="hs-comment">-- Note that for non-C languages (for example C++) @extern &quot;C&quot;@ directives</span><span>
</span><span id="line-836"></span><span class="hs-comment">-- must be used to get symbols that we can access from Haskell.</span><span>
</span><span id="line-837"></span><span class="hs-comment">--</span><span>
</span><span id="line-838"></span><span class="hs-comment">-- To get better errors, it is recommended to use #line pragmas when</span><span>
</span><span id="line-839"></span><span class="hs-comment">-- emitting C files, e.g.</span><span>
</span><span id="line-840"></span><span class="hs-comment">--</span><span>
</span><span id="line-841"></span><span class="hs-comment">-- &gt; {-# LANGUAGE CPP #-}</span><span>
</span><span id="line-842"></span><span class="hs-comment">-- &gt; ...</span><span>
</span><span id="line-843"></span><span class="hs-comment">-- &gt; addForeignSource LangC $ unlines</span><span>
</span><span id="line-844"></span><span class="hs-comment">-- &gt;   [ &quot;#line &quot; ++ show (__LINE__ + 1) ++ &quot; &quot; ++ show __FILE__</span><span>
</span><span id="line-845"></span><span class="hs-comment">-- &gt;   , ...</span><span>
</span><span id="line-846"></span><span class="hs-comment">-- &gt;   ]</span><span>
</span><span id="line-847"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addForeignSource"><span class="hs-identifier hs-type">addForeignSource</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#ForeignSrcLang"><span class="hs-identifier hs-type">ForeignSrcLang</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-848"></span><span id="addForeignSource"><span class="annot"><span class="annottext">addForeignSource :: ForeignSrcLang -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addForeignSource"><span class="hs-identifier hs-var hs-var">addForeignSource</span></a></span></span><span> </span><span id="local-6989586621679196447"><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="#local-6989586621679196447"><span class="hs-identifier hs-var">lang</span></a></span></span><span> </span><span id="local-6989586621679196448"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196448"><span class="hs-identifier hs-var">src</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-849"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679196449"><span class="annot"><span class="annottext">suffix :: FilePath
</span><a href="#local-6989586621679196449"><span class="hs-identifier hs-var hs-var hs-var">suffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="#local-6989586621679196447"><span class="hs-identifier hs-var">lang</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-850"></span><span>                 </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#LangC"><span class="hs-identifier hs-var">LangC</span></a></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;c&quot;</span></span><span>
</span><span id="line-851"></span><span>                 </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#LangCxx"><span class="hs-identifier hs-var">LangCxx</span></a></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;cpp&quot;</span></span><span>
</span><span id="line-852"></span><span>                 </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#LangObjc"><span class="hs-identifier hs-var">LangObjc</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;m&quot;</span></span><span>
</span><span id="line-853"></span><span>                 </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#LangObjcxx"><span class="hs-identifier hs-var">LangObjcxx</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;mm&quot;</span></span><span>
</span><span id="line-854"></span><span>                 </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#LangAsm"><span class="hs-identifier hs-var">LangAsm</span></a></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;s&quot;</span></span><span>
</span><span id="line-855"></span><span>                 </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#LangJs"><span class="hs-identifier hs-var">LangJs</span></a></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;js&quot;</span></span><span>
</span><span id="line-856"></span><span>                 </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#RawObject"><span class="hs-identifier hs-var">RawObject</span></a></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-857"></span><span>  </span><span id="local-6989586621679196457"><span class="annot"><a href="#local-6989586621679196457"><span class="hs-identifier hs-var">path</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#addTempFile"><span class="hs-identifier hs-var">addTempFile</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196449"><span class="hs-identifier hs-var">suffix</span></a></span><span>
</span><span id="line-858"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#runIO"><span class="hs-identifier hs-type">runIO</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">writeFile</span></span><span> </span><span class="annot"><a href="#local-6989586621679196457"><span class="hs-identifier hs-type">path</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196448"><span class="hs-identifier hs-type">src</span></a></span><span>
</span><span id="line-859"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addForeignFilePath"><span class="hs-identifier hs-type">addForeignFilePath</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196447"><span class="hs-identifier hs-type">lang</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196457"><span class="hs-identifier hs-type">path</span></a></span><span>
</span><span id="line-860"></span><span>
</span><span id="line-861"></span><span class="hs-comment">-- | Same as 'addForeignSource', but expects to receive a path pointing to the</span><span>
</span><span id="line-862"></span><span class="hs-comment">-- foreign file instead of a 'String' of its contents. Consider using this in</span><span>
</span><span id="line-863"></span><span class="hs-comment">-- conjunction with 'addTempFile'.</span><span>
</span><span id="line-864"></span><span class="hs-comment">--</span><span>
</span><span id="line-865"></span><span class="hs-comment">-- This is a good alternative to 'addForeignSource' when you are trying to</span><span>
</span><span id="line-866"></span><span class="hs-comment">-- directly link in an object file.</span><span>
</span><span id="line-867"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addForeignFilePath"><span class="hs-identifier hs-type">addForeignFilePath</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.ForeignSrcLang.Type.html#ForeignSrcLang"><span class="hs-identifier hs-type">ForeignSrcLang</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-868"></span><span id="addForeignFilePath"><span class="annot"><span class="annottext">addForeignFilePath :: ForeignSrcLang -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addForeignFilePath"><span class="hs-identifier hs-var hs-var">addForeignFilePath</span></a></span></span><span> </span><span id="local-6989586621679196460"><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="#local-6989586621679196460"><span class="hs-identifier hs-var">lang</span></a></span></span><span> </span><span id="local-6989586621679196461"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196461"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ()) -&gt; Q ()
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ForeignSrcLang -&gt; FilePath -&gt; m ()
forall (m :: * -&gt; *). Quasi m =&gt; ForeignSrcLang -&gt; FilePath -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddForeignFilePath"><span class="hs-identifier hs-var">qAddForeignFilePath</span></a></span><span> </span><span class="annot"><span class="annottext">ForeignSrcLang
</span><a href="#local-6989586621679196460"><span class="hs-identifier hs-var">lang</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196461"><span class="hs-identifier hs-var">fp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-869"></span><span>
</span><span id="line-870"></span><span class="hs-comment">-- | Add a finalizer that will run in the Q monad after the current module has</span><span>
</span><span id="line-871"></span><span class="hs-comment">-- been type checked. This only makes sense when run within a top-level splice.</span><span>
</span><span id="line-872"></span><span class="hs-comment">--</span><span>
</span><span id="line-873"></span><span class="hs-comment">-- The finalizer is given the local type environment at the splice point. Thus</span><span>
</span><span id="line-874"></span><span class="hs-comment">-- 'reify' is able to find the local definitions when executed inside the</span><span>
</span><span id="line-875"></span><span class="hs-comment">-- finalizer.</span><span>
</span><span id="line-876"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addModFinalizer"><span class="hs-identifier hs-type">addModFinalizer</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-877"></span><span id="addModFinalizer"><span class="annot"><span class="annottext">addModFinalizer :: Q () -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addModFinalizer"><span class="hs-identifier hs-var hs-var">addModFinalizer</span></a></span></span><span> </span><span id="local-6989586621679196465"><span class="annot"><span class="annottext">Q ()
</span><a href="#local-6989586621679196465"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ()) -&gt; Q ()
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Q () -&gt; m ()
forall (m :: * -&gt; *). Quasi m =&gt; Q () -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddModFinalizer"><span class="hs-identifier hs-var">qAddModFinalizer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Q () -&gt; forall (m :: * -&gt; *). Quasi m =&gt; m ()
forall a. Q a -&gt; forall (m :: * -&gt; *). Quasi m =&gt; m a
</span><a href="Language.Haskell.TH.Syntax.html#unQ"><span class="hs-identifier hs-var">unQ</span></a></span><span> </span><span class="annot"><span class="annottext">Q ()
</span><a href="#local-6989586621679196465"><span class="hs-identifier hs-var">act</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-878"></span><span>
</span><span id="line-879"></span><span class="hs-comment">-- | Adds a core plugin to the compilation pipeline.</span><span>
</span><span id="line-880"></span><span class="hs-comment">--</span><span>
</span><span id="line-881"></span><span class="hs-comment">-- @addCorePlugin m@ has almost the same effect as passing @-fplugin=m@ to ghc</span><span>
</span><span id="line-882"></span><span class="hs-comment">-- in the command line. The major difference is that the plugin module @m@</span><span>
</span><span id="line-883"></span><span class="hs-comment">-- must not belong to the current package. When TH executes, it is too late</span><span>
</span><span id="line-884"></span><span class="hs-comment">-- to tell the compiler that we needed to compile first a plugin module in the</span><span>
</span><span id="line-885"></span><span class="hs-comment">-- current package.</span><span>
</span><span id="line-886"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addCorePlugin"><span class="hs-identifier hs-type">addCorePlugin</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-887"></span><span id="addCorePlugin"><span class="annot"><span class="annottext">addCorePlugin :: FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addCorePlugin"><span class="hs-identifier hs-var hs-var">addCorePlugin</span></a></span></span><span> </span><span id="local-6989586621679196471"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196471"><span class="hs-identifier hs-var">plugin</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ()) -&gt; Q ()
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; m ()
forall (m :: * -&gt; *). Quasi m =&gt; FilePath -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddCorePlugin"><span class="hs-identifier hs-var">qAddCorePlugin</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196471"><span class="hs-identifier hs-var">plugin</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-888"></span><span>
</span><span id="line-889"></span><span class="hs-comment">-- | Get state from the 'Q' monad. Note that the state is local to the</span><span>
</span><span id="line-890"></span><span class="hs-comment">-- Haskell module in which the Template Haskell expression is executed.</span><span>
</span><span id="line-891"></span><span id="local-6989586621679193519"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#getQ"><span class="hs-identifier hs-type">getQ</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621679193519"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679193519"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-892"></span><span id="getQ"><span class="annot"><span class="annottext">getQ :: forall a. Typeable a =&gt; Q (Maybe a)
</span><a href="Language.Haskell.TH.Syntax.html#getQ"><span class="hs-identifier hs-var hs-var">getQ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m (Maybe a)) -&gt; Q (Maybe a)
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
forall a. Typeable a =&gt; m (Maybe a)
forall (m :: * -&gt; *). Quasi m =&gt; m (Maybe a)
forall (m :: * -&gt; *) a. (Quasi m, Typeable a) =&gt; m (Maybe a)
</span><a href="Language.Haskell.TH.Syntax.html#qGetQ"><span class="hs-identifier hs-var">qGetQ</span></a></span><span>
</span><span id="line-893"></span><span>
</span><span id="line-894"></span><span class="hs-comment">-- | Replace the state in the 'Q' monad. Note that the state is local to the</span><span>
</span><span id="line-895"></span><span class="hs-comment">-- Haskell module in which the Template Haskell expression is executed.</span><span>
</span><span id="line-896"></span><span id="local-6989586621679193522"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#putQ"><span class="hs-identifier hs-type">putQ</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621679193522"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193522"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-897"></span><span id="putQ"><span class="annot"><span class="annottext">putQ :: forall a. Typeable a =&gt; a -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#putQ"><span class="hs-identifier hs-var hs-var">putQ</span></a></span></span><span> </span><span id="local-6989586621679196481"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679196481"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ()) -&gt; Q ()
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; m ()
forall a. Typeable a =&gt; a -&gt; m ()
forall (m :: * -&gt; *) a. (Quasi m, Typeable a) =&gt; a -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qPutQ"><span class="hs-identifier hs-var">qPutQ</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679196481"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-898"></span><span>
</span><span id="line-899"></span><span class="annot"><span class="hs-comment">-- | Determine whether the given language extension is enabled in the 'Q' monad.</span></span><span>
</span><span id="line-900"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#isExtEnabled"><span class="hs-identifier hs-type">isExtEnabled</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.LanguageExtensions.Type.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-901"></span><span id="isExtEnabled"><span class="annot"><span class="annottext">isExtEnabled :: Extension -&gt; Q Bool
</span><a href="Language.Haskell.TH.Syntax.html#isExtEnabled"><span class="hs-identifier hs-var hs-var">isExtEnabled</span></a></span></span><span> </span><span id="local-6989586621679196486"><span class="annot"><span class="annottext">Extension
</span><a href="#local-6989586621679196486"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m Bool) -&gt; Q Bool
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Extension -&gt; m Bool
forall (m :: * -&gt; *). Quasi m =&gt; Extension -&gt; m Bool
</span><a href="Language.Haskell.TH.Syntax.html#qIsExtEnabled"><span class="hs-identifier hs-var">qIsExtEnabled</span></a></span><span> </span><span class="annot"><span class="annottext">Extension
</span><a href="#local-6989586621679196486"><span class="hs-identifier hs-var">ext</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-902"></span><span>
</span><span id="line-903"></span><span class="annot"><span class="hs-comment">-- | List all enabled language extensions.</span></span><span>
</span><span id="line-904"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#extsEnabled"><span class="hs-identifier hs-type">extsEnabled</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.LanguageExtensions.Type.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-905"></span><span id="extsEnabled"><span class="annot"><span class="annottext">extsEnabled :: Q [Extension]
</span><a href="Language.Haskell.TH.Syntax.html#extsEnabled"><span class="hs-identifier hs-var hs-var">extsEnabled</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m [Extension]) -&gt; Q [Extension]
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="annot"><span class="annottext">m [Extension]
forall (m :: * -&gt; *). Quasi m =&gt; m [Extension]
</span><a href="Language.Haskell.TH.Syntax.html#qExtsEnabled"><span class="hs-identifier hs-var">qExtsEnabled</span></a></span><span>
</span><span id="line-906"></span><span>
</span><span id="line-907"></span><span class="hs-comment">-- | Add Haddock documentation to the specified location. This will overwrite</span><span>
</span><span id="line-908"></span><span class="hs-comment">-- any documentation at the location if it already exists. This will reify the</span><span>
</span><span id="line-909"></span><span class="hs-comment">-- specified name, so it must be in scope when you call it. If you want to add</span><span>
</span><span id="line-910"></span><span class="hs-comment">-- documentation to something that you are currently splicing, you can use</span><span>
</span><span id="line-911"></span><span class="hs-comment">-- 'addModFinalizer' e.g.</span><span>
</span><span id="line-912"></span><span class="hs-comment">--</span><span>
</span><span id="line-913"></span><span class="hs-comment">-- &gt; do</span><span>
</span><span id="line-914"></span><span class="hs-comment">-- &gt;   let nm = mkName &quot;x&quot;</span><span>
</span><span id="line-915"></span><span class="hs-comment">-- &gt;   addModFinalizer $ putDoc (DeclDoc nm) &quot;Hello&quot;</span><span>
</span><span id="line-916"></span><span class="hs-comment">-- &gt;   [d| $(varP nm) = 42 |]</span><span>
</span><span id="line-917"></span><span class="hs-comment">--</span><span>
</span><span id="line-918"></span><span class="hs-comment">-- The helper functions 'withDecDoc' and 'withDecsDoc' will do this for you, as</span><span>
</span><span id="line-919"></span><span class="hs-comment">-- will the 'funD_doc' and other @_doc@ combinators.</span><span>
</span><span id="line-920"></span><span class="hs-comment">-- You most likely want to have the @-haddock@ flag turned on when using this.</span><span>
</span><span id="line-921"></span><span class="hs-comment">-- Adding documentation to anything outside of the current module will cause an</span><span>
</span><span id="line-922"></span><span class="hs-comment">-- error.</span><span>
</span><span id="line-923"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#putDoc"><span class="hs-identifier hs-type">putDoc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DocLoc"><span class="hs-identifier hs-type">DocLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-924"></span><span id="putDoc"><span class="annot"><span class="annottext">putDoc :: DocLoc -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#putDoc"><span class="hs-identifier hs-var hs-var">putDoc</span></a></span></span><span> </span><span id="local-6989586621679196493"><span class="annot"><span class="annottext">DocLoc
</span><a href="#local-6989586621679196493"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679196494"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196494"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m ()) -&gt; Q ()
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DocLoc -&gt; FilePath -&gt; m ()
forall (m :: * -&gt; *). Quasi m =&gt; DocLoc -&gt; FilePath -&gt; m ()
</span><a href="Language.Haskell.TH.Syntax.html#qPutDoc"><span class="hs-identifier hs-var">qPutDoc</span></a></span><span> </span><span class="annot"><span class="annottext">DocLoc
</span><a href="#local-6989586621679196493"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679196494"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-925"></span><span>
</span><span id="line-926"></span><span class="hs-comment">-- | Retrieves the Haddock documentation at the specified location, if one</span><span>
</span><span id="line-927"></span><span class="hs-comment">-- exists.</span><span>
</span><span id="line-928"></span><span class="hs-comment">-- It can be used to read documentation on things defined outside of the current</span><span>
</span><span id="line-929"></span><span class="hs-comment">-- module, provided that those modules were compiled with the @-haddock@ flag.</span><span>
</span><span id="line-930"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#getDoc"><span class="hs-identifier hs-type">getDoc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DocLoc"><span class="hs-identifier hs-type">DocLoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span>
</span><span id="line-931"></span><span id="getDoc"><span class="annot"><span class="annottext">getDoc :: DocLoc -&gt; Q (Maybe FilePath)
</span><a href="Language.Haskell.TH.Syntax.html#getDoc"><span class="hs-identifier hs-var hs-var">getDoc</span></a></span></span><span> </span><span id="local-6989586621679196498"><span class="annot"><span class="annottext">DocLoc
</span><a href="#local-6989586621679196498"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall (m :: * -&gt; *). Quasi m =&gt; m (Maybe FilePath))
-&gt; Q (Maybe FilePath)
forall a. (forall (m :: * -&gt; *). Quasi m =&gt; m a) -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-var">Q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DocLoc -&gt; m (Maybe FilePath)
forall (m :: * -&gt; *). Quasi m =&gt; DocLoc -&gt; m (Maybe FilePath)
</span><a href="Language.Haskell.TH.Syntax.html#qGetDoc"><span class="hs-identifier hs-var">qGetDoc</span></a></span><span> </span><span class="annot"><span class="annottext">DocLoc
</span><a href="#local-6989586621679196498"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-932"></span><span>
</span><span id="line-933"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Control.Monad.IO.Class.html#MonadIO"><span class="hs-identifier hs-type">MonadIO</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-934"></span><span>  </span><span id="local-6989586621679196506"><span class="annot"><span class="annottext">liftIO :: forall a. IO a -&gt; Q a
</span><a href="../../base-4.20.1.0-inplace/src/Control.Monad.IO.Class.html#liftIO"><span class="hs-identifier hs-var hs-var hs-var">liftIO</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IO a -&gt; Q a
forall a. IO a -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#runIO"><span class="hs-identifier hs-var">runIO</span></a></span><span>
</span><span id="line-935"></span><span>
</span><span id="line-936"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679196525"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quasi"><span class="hs-identifier hs-type">Quasi</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Q"><span class="hs-identifier hs-type">Q</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-937"></span><span>  </span><span id="local-6989586621679196541"><span class="annot"><span class="annottext">qNewName :: FilePath -&gt; Q Name
</span><a href="Language.Haskell.TH.Syntax.html#qNewName"><span class="hs-identifier hs-var hs-var hs-var">qNewName</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Q Name
forall (m :: * -&gt; *). Quote m =&gt; FilePath -&gt; m Name
</span><a href="Language.Haskell.TH.Syntax.html#newName"><span class="hs-identifier hs-var">newName</span></a></span><span>
</span><span id="line-938"></span><span>  </span><span id="local-6989586621679196542"><span class="annot"><span class="annottext">qReport :: Bool -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#qReport"><span class="hs-identifier hs-var hs-var hs-var">qReport</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#report"><span class="hs-identifier hs-var">report</span></a></span><span>
</span><span id="line-939"></span><span>  </span><span id="local-6989586621679196543"><span class="annot"><span class="annottext">qRecover :: forall a. Q a -&gt; Q a -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#qRecover"><span class="hs-identifier hs-var hs-var hs-var">qRecover</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q a -&gt; Q a -&gt; Q a
forall a. Q a -&gt; Q a -&gt; Q a
</span><a href="Language.Haskell.TH.Syntax.html#recover"><span class="hs-identifier hs-var">recover</span></a></span><span>
</span><span id="line-940"></span><span>  </span><span id="local-6989586621679196544"><span class="annot"><span class="annottext">qReify :: Name -&gt; Q Info
</span><a href="Language.Haskell.TH.Syntax.html#qReify"><span class="hs-identifier hs-var hs-var hs-var">qReify</span></a></span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Info
</span><a href="Language.Haskell.TH.Syntax.html#reify"><span class="hs-identifier hs-var">reify</span></a></span><span>
</span><span id="line-941"></span><span>  </span><span id="local-6989586621679196545"><span class="annot"><span class="annottext">qReifyFixity :: Name -&gt; Q (Maybe Fixity)
</span><a href="Language.Haskell.TH.Syntax.html#qReifyFixity"><span class="hs-identifier hs-var hs-var hs-var">qReifyFixity</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Fixity)
</span><a href="Language.Haskell.TH.Syntax.html#reifyFixity"><span class="hs-identifier hs-var">reifyFixity</span></a></span><span>
</span><span id="line-942"></span><span>  </span><span id="local-6989586621679196546"><span class="annot"><span class="annottext">qReifyType :: Name -&gt; Q Type
</span><a href="Language.Haskell.TH.Syntax.html#qReifyType"><span class="hs-identifier hs-var hs-var hs-var">qReifyType</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
</span><a href="Language.Haskell.TH.Syntax.html#reifyType"><span class="hs-identifier hs-var">reifyType</span></a></span><span>
</span><span id="line-943"></span><span>  </span><span id="local-6989586621679196547"><span class="annot"><span class="annottext">qReifyInstances :: Name -&gt; [Type] -&gt; Q [Dec]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyInstances"><span class="hs-identifier hs-var hs-var hs-var">qReifyInstances</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Type] -&gt; Q [Dec]
</span><a href="Language.Haskell.TH.Syntax.html#reifyInstances"><span class="hs-identifier hs-var">reifyInstances</span></a></span><span>
</span><span id="line-944"></span><span>  </span><span id="local-6989586621679196548"><span class="annot"><span class="annottext">qReifyRoles :: Name -&gt; Q [Role]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyRoles"><span class="hs-identifier hs-var hs-var hs-var">qReifyRoles</span></a></span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q [Role]
</span><a href="Language.Haskell.TH.Syntax.html#reifyRoles"><span class="hs-identifier hs-var">reifyRoles</span></a></span><span>
</span><span id="line-945"></span><span>  </span><span id="local-6989586621679196551"><span class="annot"><span class="annottext">qReifyAnnotations :: forall a. Data a =&gt; AnnLookup -&gt; Q [a]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyAnnotations"><span class="hs-identifier hs-var hs-var hs-var">qReifyAnnotations</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">AnnLookup -&gt; Q [a]
forall a. Data a =&gt; AnnLookup -&gt; Q [a]
</span><a href="Language.Haskell.TH.Syntax.html#reifyAnnotations"><span class="hs-identifier hs-var">reifyAnnotations</span></a></span><span>
</span><span id="line-946"></span><span>  </span><span id="local-6989586621679196552"><span class="annot"><span class="annottext">qReifyModule :: Module -&gt; Q ModuleInfo
</span><a href="Language.Haskell.TH.Syntax.html#qReifyModule"><span class="hs-identifier hs-var hs-var hs-var">qReifyModule</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Module -&gt; Q ModuleInfo
</span><a href="Language.Haskell.TH.Syntax.html#reifyModule"><span class="hs-identifier hs-var">reifyModule</span></a></span><span>
</span><span id="line-947"></span><span>  </span><span id="local-6989586621679196553"><span class="annot"><span class="annottext">qReifyConStrictness :: Name -&gt; Q [DecidedStrictness]
</span><a href="Language.Haskell.TH.Syntax.html#qReifyConStrictness"><span class="hs-identifier hs-var hs-var hs-var">qReifyConStrictness</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q [DecidedStrictness]
</span><a href="Language.Haskell.TH.Syntax.html#reifyConStrictness"><span class="hs-identifier hs-var">reifyConStrictness</span></a></span><span>
</span><span id="line-948"></span><span>  </span><span id="local-6989586621679196554"><span class="annot"><span class="annottext">qLookupName :: Bool -&gt; FilePath -&gt; Q (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#qLookupName"><span class="hs-identifier hs-var hs-var hs-var">qLookupName</span></a></span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; FilePath -&gt; Q (Maybe Name)
</span><a href="Language.Haskell.TH.Syntax.html#lookupName"><span class="hs-identifier hs-var">lookupName</span></a></span><span>
</span><span id="line-949"></span><span>  </span><span id="local-6989586621679196555"><span class="annot"><span class="annottext">qLocation :: Q Loc
</span><a href="Language.Haskell.TH.Syntax.html#qLocation"><span class="hs-identifier hs-var hs-var hs-var">qLocation</span></a></span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q Loc
</span><a href="Language.Haskell.TH.Syntax.html#location"><span class="hs-identifier hs-var">location</span></a></span><span>
</span><span id="line-950"></span><span>  </span><span id="local-6989586621679196556"><span class="annot"><span class="annottext">qGetPackageRoot :: Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#qGetPackageRoot"><span class="hs-identifier hs-var hs-var hs-var">qGetPackageRoot</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#getPackageRoot"><span class="hs-identifier hs-var">getPackageRoot</span></a></span><span>
</span><span id="line-951"></span><span>  </span><span id="local-6989586621679196557"><span class="annot"><span class="annottext">qAddDependentFile :: FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddDependentFile"><span class="hs-identifier hs-var hs-var hs-var">qAddDependentFile</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addDependentFile"><span class="hs-identifier hs-var">addDependentFile</span></a></span><span>
</span><span id="line-952"></span><span>  </span><span id="local-6989586621679196558"><span class="annot"><span class="annottext">qAddTempFile :: FilePath -&gt; Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#qAddTempFile"><span class="hs-identifier hs-var hs-var hs-var">qAddTempFile</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Q FilePath
</span><a href="Language.Haskell.TH.Syntax.html#addTempFile"><span class="hs-identifier hs-var">addTempFile</span></a></span><span>
</span><span id="line-953"></span><span>  </span><span id="local-6989586621679196559"><span class="annot"><span class="annottext">qAddTopDecls :: [Dec] -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddTopDecls"><span class="hs-identifier hs-var hs-var hs-var">qAddTopDecls</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Dec] -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addTopDecls"><span class="hs-identifier hs-var">addTopDecls</span></a></span><span>
</span><span id="line-954"></span><span>  </span><span id="local-6989586621679196560"><span class="annot"><span class="annottext">qAddForeignFilePath :: ForeignSrcLang -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddForeignFilePath"><span class="hs-identifier hs-var hs-var hs-var">qAddForeignFilePath</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ForeignSrcLang -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addForeignFilePath"><span class="hs-identifier hs-var">addForeignFilePath</span></a></span><span>
</span><span id="line-955"></span><span>  </span><span id="local-6989586621679196561"><span class="annot"><span class="annottext">qAddModFinalizer :: Q () -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddModFinalizer"><span class="hs-identifier hs-var hs-var hs-var">qAddModFinalizer</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q () -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addModFinalizer"><span class="hs-identifier hs-var">addModFinalizer</span></a></span><span>
</span><span id="line-956"></span><span>  </span><span id="local-6989586621679196562"><span class="annot"><span class="annottext">qAddCorePlugin :: FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#qAddCorePlugin"><span class="hs-identifier hs-var hs-var hs-var">qAddCorePlugin</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#addCorePlugin"><span class="hs-identifier hs-var">addCorePlugin</span></a></span><span>
</span><span id="line-957"></span><span>  </span><span id="local-6989586621679196565"><span class="annot"><span class="annottext">qGetQ :: forall a. Typeable a =&gt; Q (Maybe a)
</span><a href="Language.Haskell.TH.Syntax.html#qGetQ"><span class="hs-identifier hs-var hs-var hs-var">qGetQ</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q (Maybe a)
forall a. Typeable a =&gt; Q (Maybe a)
</span><a href="Language.Haskell.TH.Syntax.html#getQ"><span class="hs-identifier hs-var">getQ</span></a></span><span>
</span><span id="line-958"></span><span>  </span><span id="local-6989586621679196568"><span class="annot"><span class="annottext">qPutQ :: forall a. Typeable a =&gt; a -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#qPutQ"><span class="hs-identifier hs-var hs-var hs-var">qPutQ</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Q ()
forall a. Typeable a =&gt; a -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#putQ"><span class="hs-identifier hs-var">putQ</span></a></span><span>
</span><span id="line-959"></span><span>  </span><span id="local-6989586621679196569"><span class="annot"><span class="annottext">qIsExtEnabled :: Extension -&gt; Q Bool
</span><a href="Language.Haskell.TH.Syntax.html#qIsExtEnabled"><span class="hs-identifier hs-var hs-var hs-var">qIsExtEnabled</span></a></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Extension -&gt; Q Bool
</span><a href="Language.Haskell.TH.Syntax.html#isExtEnabled"><span class="hs-identifier hs-var">isExtEnabled</span></a></span><span>
</span><span id="line-960"></span><span>  </span><span id="local-6989586621679196570"><span class="annot"><span class="annottext">qExtsEnabled :: Q [Extension]
</span><a href="Language.Haskell.TH.Syntax.html#qExtsEnabled"><span class="hs-identifier hs-var hs-var hs-var">qExtsEnabled</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q [Extension]
</span><a href="Language.Haskell.TH.Syntax.html#extsEnabled"><span class="hs-identifier hs-var">extsEnabled</span></a></span><span>
</span><span id="line-961"></span><span>  </span><span id="local-6989586621679196571"><span class="annot"><span class="annottext">qPutDoc :: DocLoc -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#qPutDoc"><span class="hs-identifier hs-var hs-var hs-var">qPutDoc</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DocLoc -&gt; FilePath -&gt; Q ()
</span><a href="Language.Haskell.TH.Syntax.html#putDoc"><span class="hs-identifier hs-var">putDoc</span></a></span><span>
</span><span id="line-962"></span><span>  </span><span id="local-6989586621679196572"><span class="annot"><span class="annottext">qGetDoc :: DocLoc -&gt; Q (Maybe FilePath)
</span><a href="Language.Haskell.TH.Syntax.html#qGetDoc"><span class="hs-identifier hs-var hs-var hs-var">qGetDoc</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DocLoc -&gt; Q (Maybe FilePath)
</span><a href="Language.Haskell.TH.Syntax.html#getDoc"><span class="hs-identifier hs-var">getDoc</span></a></span><span>
</span><span id="line-963"></span><span>
</span><span id="line-964"></span><span>
</span><span id="line-965"></span><span class="hs-comment">----------------------------------------------------</span><span>
</span><span id="line-966"></span><span class="hs-comment">-- The following operations are used solely in GHC.HsToCore.Quote when</span><span>
</span><span id="line-967"></span><span class="hs-comment">-- desugaring brackets. They are not necessary for the user, who can use</span><span>
</span><span id="line-968"></span><span class="hs-comment">-- ordinary return and (&gt;&gt;=) etc</span><span>
</span><span id="line-969"></span><span>
</span><span id="line-970"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#sequenceQ"><span class="hs-identifier hs-type">sequenceQ</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193534"><span class="annot"><a href="#local-6989586621679193534"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679193534"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193535"><span class="annot"><a href="#local-6989586621679193535"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679193534"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193535"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193534"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679193535"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-971"></span><span id="sequenceQ"><span class="annot"><span class="annottext">sequenceQ :: forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><a href="Language.Haskell.TH.Syntax.html#sequenceQ"><span class="hs-identifier hs-var hs-var">sequenceQ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[m a] -&gt; m [a]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span>
</span><span id="line-972"></span><span>
</span><span id="line-973"></span><span>
</span><span id="line-974"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-975"></span><span class="hs-comment">--</span><span>
</span><span id="line-976"></span><span class="hs-comment">--              The Lift class</span><span>
</span><span id="line-977"></span><span class="hs-comment">--</span><span>
</span><span id="line-978"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-979"></span><span>
</span><span id="line-980"></span><span class="hs-comment">-- | A 'Lift' instance can have any of its values turned into a Template</span><span>
</span><span id="line-981"></span><span class="hs-comment">-- Haskell expression. This is needed when a value used within a Template</span><span>
</span><span id="line-982"></span><span class="hs-comment">-- Haskell quotation is bound outside the Oxford brackets (@[| ... |]@ or</span><span>
</span><span id="line-983"></span><span class="hs-comment">-- @[|| ... ||]@) but not at the top level. As an example:</span><span>
</span><span id="line-984"></span><span class="hs-comment">--</span><span>
</span><span id="line-985"></span><span class="hs-comment">-- &gt; add1 :: Int -&gt; Code Q Int</span><span>
</span><span id="line-986"></span><span class="hs-comment">-- &gt; add1 x = [|| x + 1 ||]</span><span>
</span><span id="line-987"></span><span class="hs-comment">--</span><span>
</span><span id="line-988"></span><span class="hs-comment">-- Template Haskell has no way of knowing what value @x@ will take on at</span><span>
</span><span id="line-989"></span><span class="hs-comment">-- splice-time, so it requires the type of @x@ to be an instance of 'Lift'.</span><span>
</span><span id="line-990"></span><span class="hs-comment">--</span><span>
</span><span id="line-991"></span><span class="hs-comment">-- A 'Lift' instance must satisfy @$(lift x) &#8801; x@ and @$$(liftTyped x) &#8801; x@</span><span>
</span><span id="line-992"></span><span class="hs-comment">-- for all @x@, where @$(...)@ and @$$(...)@ are Template Haskell splices.</span><span>
</span><span id="line-993"></span><span class="hs-comment">-- It is additionally expected that @'lift' x &#8801; 'unTypeCode' ('liftTyped' x)@.</span><span>
</span><span id="line-994"></span><span class="hs-comment">--</span><span>
</span><span id="line-995"></span><span class="hs-comment">-- 'Lift' instances can be derived automatically by use of the @-XDeriveLift@</span><span>
</span><span id="line-996"></span><span class="hs-comment">-- GHC language extension:</span><span>
</span><span id="line-997"></span><span class="hs-comment">--</span><span>
</span><span id="line-998"></span><span class="hs-comment">-- &gt; {-# LANGUAGE DeriveLift #-}</span><span>
</span><span id="line-999"></span><span class="hs-comment">-- &gt; module Foo where</span><span>
</span><span id="line-1000"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1001"></span><span class="hs-comment">-- &gt; import Language.Haskell.TH.Syntax</span><span>
</span><span id="line-1002"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1003"></span><span class="hs-comment">-- &gt; data Bar a = Bar1 a (Bar a) | Bar2 String</span><span>
</span><span id="line-1004"></span><span class="hs-comment">-- &gt;   deriving Lift</span><span>
</span><span id="line-1005"></span><span class="hs-comment">--</span><span>
</span><span id="line-1006"></span><span class="hs-comment">-- Representation-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-1007"></span><span class="hs-keyword">class</span><span> </span><span id="Lift"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-var">Lift</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679193541"><span id="local-6989586621679193543"><span class="annot"><a href="#local-6989586621679193543"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#TYPE"><span class="hs-identifier hs-type">TYPE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193541"><span class="hs-identifier hs-type">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1008"></span><span>  </span><span class="hs-comment">-- | Turn a value into a Template Haskell expression, suitable for use in</span><span>
</span><span id="line-1009"></span><span>  </span><span class="hs-comment">-- a splice.</span><span>
</span><span id="line-1010"></span><span>  </span><span id="lift"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-type">lift</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193548"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193548"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193543"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193548"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span></span><span>
</span><span id="line-1011"></span><span>  </span><span class="hs-keyword">default</span><span> </span><span id="lift"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-type">lift</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193542"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193541"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#~"><span class="hs-operator hs-type">~</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">'</span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#BoxedRep"><span class="hs-identifier hs-type">BoxedRep</span></a></span><span> </span><span class="hs-special">'</span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Lifted"><span class="hs-identifier hs-type">Lifted</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193542"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193543"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193542"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span></span><span>
</span><span id="line-1012"></span><span>  </span><span id="local-6989586621679196579"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var">lift</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Code m t -&gt; m Exp
forall a (m :: * -&gt; *). Quote m =&gt; Code m a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#unTypeCode"><span class="hs-identifier hs-var">unTypeCode</span></a></span><span> </span><span class="annot"><span class="annottext">(Code m t -&gt; m Exp) -&gt; (t -&gt; Code m t) -&gt; t -&gt; m Exp
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">t -&gt; Code m t
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; Code m t
forall (m :: * -&gt; *). Quote m =&gt; t -&gt; Code m t
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var">liftTyped</span></a></span></span><span>
</span><span id="line-1013"></span><span>
</span><span id="line-1014"></span><span>  </span><span class="hs-comment">-- | Turn a value into a Template Haskell typed expression, suitable for use</span><span>
</span><span id="line-1015"></span><span>  </span><span class="hs-comment">-- in a typed splice.</span><span>
</span><span id="line-1016"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1017"></span><span>  </span><span class="hs-comment">-- @since 2.16.0.0</span><span>
</span><span id="line-1018"></span><span>  </span><span id="liftTyped"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-type">liftTyped</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679193547"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193547"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193543"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193547"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193543"><span class="hs-identifier hs-type">t</span></a></span></span><span>
</span><span id="line-1019"></span><span>
</span><span id="line-1020"></span><span>
</span><span id="line-1021"></span><span class="hs-comment">-- If you add any instances here, consider updating test th/TH_Lift</span><span>
</span><span id="line-1022"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1023"></span><span>  </span><span id="local-6989586621679196595"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Uniq -&gt; Code m Uniq
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196596"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196596"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Uniq
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Uniq -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196596"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1024"></span><span>  </span><span id="local-6989586621679196600"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Uniq -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196601"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196601"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196601"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1025"></span><span>
</span><span id="line-1026"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1027"></span><span>  </span><span id="local-6989586621679196611"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Int -&gt; Code m Int
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196612"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679196612"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Int
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Int -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679196612"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1028"></span><span>  </span><span id="local-6989586621679196619"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Int -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196620"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679196620"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679196620"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1029"></span><span>
</span><span id="line-1030"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1031"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Int%23"><span class="hs-identifier hs-type">Int#</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1032"></span><span>  </span><span id="local-6989586621679196628"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Int# -&gt; Code m Int#
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196629"><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679196629"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Int#
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int# -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Int# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679196629"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1033"></span><span>  </span><span id="local-6989586621679196635"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Int# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196636"><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679196636"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntPrimL"><span class="hs-identifier hs-var">IntPrimL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int# -&gt; Int
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#I%23"><span class="hs-identifier hs-var">I#</span></a></span><span> </span><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679196636"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1034"></span><span>
</span><span id="line-1035"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int8</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1036"></span><span>  </span><span id="local-6989586621679196645"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Int8 -&gt; Code m Int8
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196646"><span class="annot"><span class="annottext">Int8
</span><a href="#local-6989586621679196646"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Int8
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int8 -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Int8 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Int8
</span><a href="#local-6989586621679196646"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1037"></span><span>  </span><span id="local-6989586621679196653"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Int8 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196654"><span class="annot"><span class="annottext">Int8
</span><a href="#local-6989586621679196654"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int8 -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Int8
</span><a href="#local-6989586621679196654"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1038"></span><span>
</span><span id="line-1039"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int16</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1040"></span><span>  </span><span id="local-6989586621679196662"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Int16 -&gt; Code m Int16
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196663"><span class="annot"><span class="annottext">Int16
</span><a href="#local-6989586621679196663"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Int16
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int16 -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Int16 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Int16
</span><a href="#local-6989586621679196663"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1041"></span><span>  </span><span id="local-6989586621679196670"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Int16 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196671"><span class="annot"><span class="annottext">Int16
</span><a href="#local-6989586621679196671"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int16 -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Int16
</span><a href="#local-6989586621679196671"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1042"></span><span>
</span><span id="line-1043"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int32</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1044"></span><span>  </span><span id="local-6989586621679196679"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Int32 -&gt; Code m Int32
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196680"><span class="annot"><span class="annottext">Int32
</span><a href="#local-6989586621679196680"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Int32
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int32 -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Int32 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Int32
</span><a href="#local-6989586621679196680"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1045"></span><span>  </span><span id="local-6989586621679196687"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Int32 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196688"><span class="annot"><span class="annottext">Int32
</span><a href="#local-6989586621679196688"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int32 -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Int32
</span><a href="#local-6989586621679196688"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1046"></span><span>
</span><span id="line-1047"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int64</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1048"></span><span>  </span><span id="local-6989586621679196696"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Int64 -&gt; Code m Int64
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196697"><span class="annot"><span class="annottext">Int64
</span><a href="#local-6989586621679196697"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Int64
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int64 -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Int64 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Int64
</span><a href="#local-6989586621679196697"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1049"></span><span>  </span><span id="local-6989586621679196704"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Int64 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196705"><span class="annot"><span class="annottext">Int64
</span><a href="#local-6989586621679196705"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int64 -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Int64
</span><a href="#local-6989586621679196705"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1050"></span><span>
</span><span id="line-1051"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1052"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Word%23"><span class="hs-identifier hs-type">Word#</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1053"></span><span>  </span><span id="local-6989586621679196713"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Word# -&gt; Code m Word#
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196714"><span class="annot"><span class="annottext">Word#
</span><a href="#local-6989586621679196714"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Word#
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word# -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Word# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Word#
</span><a href="#local-6989586621679196714"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1054"></span><span>  </span><span id="local-6989586621679196720"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Word# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196721"><span class="annot"><span class="annottext">Word#
</span><a href="#local-6989586621679196721"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#WordPrimL"><span class="hs-identifier hs-var">WordPrimL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word# -&gt; Word
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#W%23"><span class="hs-identifier hs-var">W#</span></a></span><span> </span><span class="annot"><span class="annottext">Word#
</span><a href="#local-6989586621679196721"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1055"></span><span>
</span><span id="line-1056"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Word"><span class="hs-identifier hs-type">Word</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1057"></span><span>  </span><span id="local-6989586621679196730"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Word -&gt; Code m Word
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196731"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679196731"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Word
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Word -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679196731"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1058"></span><span>  </span><span id="local-6989586621679196737"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Word -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196738"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679196738"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679196738"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1059"></span><span>
</span><span id="line-1060"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1061"></span><span>  </span><span id="local-6989586621679196746"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Word8 -&gt; Code m Word8
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196747"><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621679196747"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Word8
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word8 -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Word8 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621679196747"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1062"></span><span>  </span><span id="local-6989586621679196754"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Word8 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196755"><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621679196755"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word8 -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word8
</span><a href="#local-6989586621679196755"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1063"></span><span>
</span><span id="line-1064"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word16</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1065"></span><span>  </span><span id="local-6989586621679196763"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Word16 -&gt; Code m Word16
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196764"><span class="annot"><span class="annottext">Word16
</span><a href="#local-6989586621679196764"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Word16
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word16 -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Word16 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Word16
</span><a href="#local-6989586621679196764"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1066"></span><span>  </span><span id="local-6989586621679196771"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Word16 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196772"><span class="annot"><span class="annottext">Word16
</span><a href="#local-6989586621679196772"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word16 -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word16
</span><a href="#local-6989586621679196772"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1067"></span><span>
</span><span id="line-1068"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word32</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1069"></span><span>  </span><span id="local-6989586621679196780"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Word32 -&gt; Code m Word32
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196781"><span class="annot"><span class="annottext">Word32
</span><a href="#local-6989586621679196781"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Word32
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word32 -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Word32 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Word32
</span><a href="#local-6989586621679196781"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1070"></span><span>  </span><span id="local-6989586621679196788"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Word32 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196789"><span class="annot"><span class="annottext">Word32
</span><a href="#local-6989586621679196789"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word32 -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word32
</span><a href="#local-6989586621679196789"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1071"></span><span>
</span><span id="line-1072"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word64</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1073"></span><span>  </span><span id="local-6989586621679196797"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Word64 -&gt; Code m Word64
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196798"><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679196798"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Word64
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word64 -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Word64 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679196798"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1074"></span><span>  </span><span id="local-6989586621679196805"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Word64 -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196806"><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679196806"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word64 -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679196806"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1075"></span><span>
</span><span id="line-1076"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1077"></span><span>  </span><span id="local-6989586621679196814"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Natural -&gt; Code m Natural
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196815"><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679196815"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Natural
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Natural -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679196815"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1078"></span><span>  </span><span id="local-6989586621679196822"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Natural -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196823"><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679196823"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679196823"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1079"></span><span>
</span><span id="line-1080"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193584"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Fixed.html#Fixed"><span class="hs-identifier hs-type">Fixed.Fixed</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193584"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1081"></span><span>  </span><span id="local-6989586621679196831"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Fixed a -&gt; Code m (Fixed a)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196832"><span class="annot"><span class="annottext">Fixed a
</span><a href="#local-6989586621679196832"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (Fixed a)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Fixed a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Fixed a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Fixed a
</span><a href="#local-6989586621679196832"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1082"></span><span>  </span><span id="local-6989586621679196839"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Fixed a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Fixed.html#MkFixed"><span class="hs-identifier hs-type">Fixed.MkFixed</span></a></span><span> </span><span id="local-6989586621679196841"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196841"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1083"></span><span>    </span><span id="local-6989586621679196842"><span class="annot"><a href="#local-6989586621679196842"><span class="hs-identifier hs-var">ex</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Uniq -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Uniq -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679196841"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1084"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-type">ConE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196844"><span class="hs-identifier hs-type">mkFixedName</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AppE"><span class="hs-operator hs-type">`AppE`</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679196842"><span class="hs-identifier hs-type">ex</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1085"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-1086"></span><span>      </span><span id="local-6989586621679196844"><span class="annot"><span class="annottext">mkFixedName :: Name
</span><a href="#local-6989586621679196844"><span class="hs-identifier hs-var hs-var">mkFixedName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Fixed.MkFixed</span><span>
</span><span id="line-1087"></span><span>
</span><span id="line-1088"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193588"><span class="annot"><span class="hs-identifier hs-type">Integral</span></span><span> </span><span class="annot"><a href="#local-6989586621679193588"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ratio</span></span><span> </span><span class="annot"><a href="#local-6989586621679193588"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1089"></span><span>  </span><span id="local-6989586621679196854"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Ratio a -&gt; Code m (Ratio a)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196855"><span class="annot"><span class="annottext">Ratio a
</span><a href="#local-6989586621679196855"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (Ratio a)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ratio a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Ratio a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Ratio a
</span><a href="#local-6989586621679196855"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1090"></span><span>  </span><span id="local-6989586621679196861"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Ratio a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196862"><span class="annot"><span class="annottext">Ratio a
</span><a href="#local-6989586621679196862"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Rational -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#RationalL"><span class="hs-identifier hs-var">RationalL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ratio a -&gt; Rational
forall a. Real a =&gt; a -&gt; Rational
</span><span class="hs-identifier hs-var">toRational</span></span><span> </span><span class="annot"><span class="annottext">Ratio a
</span><a href="#local-6989586621679196862"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1091"></span><span>
</span><span id="line-1092"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Float"><span class="hs-identifier hs-type">Float</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1093"></span><span>  </span><span id="local-6989586621679196871"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Float -&gt; Code m Float
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196872"><span class="annot"><span class="annottext">Float
</span><a href="#local-6989586621679196872"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Float
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Float -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Float -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Float
</span><a href="#local-6989586621679196872"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1094"></span><span>  </span><span id="local-6989586621679196878"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Float -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196879"><span class="annot"><span class="annottext">Float
</span><a href="#local-6989586621679196879"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Rational -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#RationalL"><span class="hs-identifier hs-var">RationalL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Float -&gt; Rational
forall a. Real a =&gt; a -&gt; Rational
</span><span class="hs-identifier hs-var">toRational</span></span><span> </span><span class="annot"><span class="annottext">Float
</span><a href="#local-6989586621679196879"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1095"></span><span>
</span><span id="line-1096"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1097"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Float%23"><span class="hs-identifier hs-type">Float#</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1098"></span><span>  </span><span id="local-6989586621679196887"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Float# -&gt; Code m Float#
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196888"><span class="annot"><span class="annottext">Float#
</span><a href="#local-6989586621679196888"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Float#
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Float# -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Float# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Float#
</span><a href="#local-6989586621679196888"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1099"></span><span>  </span><span id="local-6989586621679196893"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Float# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196894"><span class="annot"><span class="annottext">Float#
</span><a href="#local-6989586621679196894"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Rational -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#FloatPrimL"><span class="hs-identifier hs-var">FloatPrimL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Float -&gt; Rational
forall a. Real a =&gt; a -&gt; Rational
</span><span class="hs-identifier hs-var">toRational</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Float# -&gt; Float
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#F%23"><span class="hs-identifier hs-var">F#</span></a></span><span> </span><span class="annot"><span class="annottext">Float#
</span><a href="#local-6989586621679196894"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1100"></span><span>
</span><span id="line-1101"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Double"><span class="hs-identifier hs-type">Double</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1102"></span><span>  </span><span id="local-6989586621679196903"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Double -&gt; Code m Double
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196904"><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621679196904"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Double
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Double -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Double -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621679196904"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1103"></span><span>  </span><span id="local-6989586621679196910"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Double -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196911"><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621679196911"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Rational -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#RationalL"><span class="hs-identifier hs-var">RationalL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Double -&gt; Rational
forall a. Real a =&gt; a -&gt; Rational
</span><span class="hs-identifier hs-var">toRational</span></span><span> </span><span class="annot"><span class="annottext">Double
</span><a href="#local-6989586621679196911"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1104"></span><span>
</span><span id="line-1105"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1106"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Double%23"><span class="hs-identifier hs-type">Double#</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1107"></span><span>  </span><span id="local-6989586621679196919"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Double# -&gt; Code m Double#
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196920"><span class="annot"><span class="annottext">Double#
</span><a href="#local-6989586621679196920"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Double#
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Double# -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Double# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Double#
</span><a href="#local-6989586621679196920"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1108"></span><span>  </span><span id="local-6989586621679196925"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Double# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196926"><span class="annot"><span class="annottext">Double#
</span><a href="#local-6989586621679196926"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Rational -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#DoublePrimL"><span class="hs-identifier hs-var">DoublePrimL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Double -&gt; Rational
forall a. Real a =&gt; a -&gt; Rational
</span><span class="hs-identifier hs-var">toRational</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Double# -&gt; Double
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#D%23"><span class="hs-identifier hs-var">D#</span></a></span><span> </span><span class="annot"><span class="annottext">Double#
</span><a href="#local-6989586621679196926"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1109"></span><span>
</span><span id="line-1110"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Char"><span class="hs-identifier hs-type">Char</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1111"></span><span>  </span><span id="local-6989586621679196935"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Char -&gt; Code m Char
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196936"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679196936"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Char
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Char -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679196936"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1112"></span><span>  </span><span id="local-6989586621679196940"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Char -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196941"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679196941"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#CharL"><span class="hs-identifier hs-var">CharL</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679196941"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1113"></span><span>
</span><span id="line-1114"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1115"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Char%23"><span class="hs-identifier hs-type">Char#</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1116"></span><span>  </span><span id="local-6989586621679196950"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Char# -&gt; Code m Char#
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196951"><span class="annot"><span class="annottext">Char#
</span><a href="#local-6989586621679196951"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Char#
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char# -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Char# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Char#
</span><a href="#local-6989586621679196951"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1117"></span><span>  </span><span id="local-6989586621679196955"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Char# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196956"><span class="annot"><span class="annottext">Char#
</span><a href="#local-6989586621679196956"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#CharPrimL"><span class="hs-identifier hs-var">CharPrimL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char# -&gt; Char
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#C%23"><span class="hs-identifier hs-var">C#</span></a></span><span> </span><span class="annot"><span class="annottext">Char#
</span><a href="#local-6989586621679196956"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1118"></span><span>
</span><span id="line-1119"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1120"></span><span>  </span><span id="local-6989586621679196965"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Bool -&gt; Code m Bool
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196966"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679196966"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Bool
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Bool -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679196966"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1121"></span><span>
</span><span id="line-1122"></span><span>  </span><span id="local-6989586621679196971"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Bool -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Syntax.html#trueName"><span class="hs-identifier hs-var">trueName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1123"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Syntax.html#falseName"><span class="hs-identifier hs-var">falseName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1124"></span><span>
</span><span id="line-1125"></span><span class="hs-comment">-- | Produces an 'Addr#' literal from the NUL-terminated C-string starting at</span><span>
</span><span id="line-1126"></span><span class="hs-comment">-- the given memory address.</span><span>
</span><span id="line-1127"></span><span class="hs-comment">--</span><span>
</span><span id="line-1128"></span><span class="hs-comment">-- @since 2.16.0.0</span><span>
</span><span id="line-1129"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Addr%23"><span class="hs-identifier hs-type">Addr#</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1130"></span><span>  </span><span id="local-6989586621679196981"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Addr# -&gt; Code m Addr#
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679196982"><span class="annot"><span class="annottext">Addr#
</span><a href="#local-6989586621679196982"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m Addr#
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Addr# -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Addr# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Addr#
</span><a href="#local-6989586621679196982"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1131"></span><span>  </span><span id="local-6989586621679196989"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Addr# -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679196990"><span class="annot"><span class="annottext">Addr#
</span><a href="#local-6989586621679196990"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-1132"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Word8] -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#StringPrimL"><span class="hs-identifier hs-var">StringPrimL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Char -&gt; Word8) -&gt; FilePath -&gt; [Word8]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Word8
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; Word8) -&gt; (Char -&gt; Int) -&gt; Char -&gt; Word8
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Int
</span><span class="hs-identifier hs-var">ord</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Addr# -&gt; FilePath
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.CString.html#unpackCString%23"><span class="hs-identifier hs-var">unpackCString#</span></a></span><span> </span><span class="annot"><span class="annottext">Addr#
</span><a href="#local-6989586621679196990"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1133"></span><span>
</span><span id="line-1134"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-1135"></span><span class="hs-comment">-- @since 2.19.0.0</span><span>
</span><span id="line-1136"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html#ByteArray"><span class="hs-identifier hs-type">ByteArray</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1137"></span><span>  </span><span id="local-6989586621679196999"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; ByteArray -&gt; Code m ByteArray
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197000"><span class="annot"><span class="annottext">ByteArray
</span><a href="#local-6989586621679197000"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m ByteArray
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ByteArray -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; ByteArray -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">ByteArray
</span><a href="#local-6989586621679197000"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1138"></span><span>  </span><span id="local-6989586621679197008"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; ByteArray -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html#ByteArray"><span class="hs-identifier hs-type">ByteArray</span></a></span><span> </span><span id="local-6989586621679197010"><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197010"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span>
</span><span id="line-1139"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Exp -&gt; Exp -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#AppE"><span class="hs-identifier hs-var">AppE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Exp -&gt; Exp -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#AppE"><span class="hs-identifier hs-var">AppE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#VarE"><span class="hs-identifier hs-var">VarE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Syntax.html#addrToByteArrayName"><span class="hs-identifier hs-var">addrToByteArrayName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Uniq
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679197013"><span class="hs-identifier hs-var">len</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1140"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bytes -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#BytesPrimL"><span class="hs-identifier hs-var">BytesPrimL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ForeignPtr Word8 -&gt; Word -&gt; Word -&gt; Bytes
</span><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-var">Bytes</span></a></span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679197016"><span class="hs-identifier hs-var">ptr</span></a></span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Word
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679197013"><span class="hs-identifier hs-var">len</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1141"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-1142"></span><span>      </span><span id="local-6989586621679197017"><span class="annot"><span class="annottext">len# :: Int#
</span><a href="#local-6989586621679197017"><span class="hs-identifier hs-var hs-var">len#</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ByteArray# -&gt; Int#
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#sizeofByteArray%23"><span class="hs-identifier hs-var">sizeofByteArray#</span></a></span><span> </span><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197010"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1143"></span><span>      </span><span id="local-6989586621679197013"><span class="annot"><span class="annottext">len :: Int
</span><a href="#local-6989586621679197013"><span class="hs-identifier hs-var hs-var">len</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int# -&gt; Int
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#I%23"><span class="hs-identifier hs-var">I#</span></a></span><span> </span><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679197017"><span class="hs-identifier hs-var">len#</span></a></span><span>
</span><span id="line-1144"></span><span>      </span><span class="annot"><a href="#local-6989586621679197018"><span class="hs-identifier hs-type">pb</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#ByteArray%23"><span class="hs-identifier hs-type">ByteArray#</span></a></span><span>
</span><span id="line-1145"></span><span>      </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html#ByteArray"><span class="hs-identifier hs-type">ByteArray</span></a></span><span> </span><span id="local-6989586621679197018"><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197018"><span class="hs-identifier hs-var">pb</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1146"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int# -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#isTrue%23"><span class="hs-identifier hs-var">isTrue#</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ByteArray# -&gt; Int#
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#isByteArrayPinned%23"><span class="hs-identifier hs-var">isByteArrayPinned#</span></a></span><span> </span><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197010"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ByteArray# -&gt; ByteArray
</span><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html#ByteArray"><span class="hs-identifier hs-var">ByteArray</span></a></span><span> </span><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197010"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1147"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall s. ST s ByteArray) -&gt; ByteArray
forall a. (forall s. ST s a) -&gt; a
</span><span class="hs-identifier hs-var">runST</span></span><span> </span><span class="annot"><span class="annottext">((forall s. ST s ByteArray) -&gt; ByteArray)
-&gt; (forall s. ST s ByteArray) -&gt; ByteArray
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">STRep s ByteArray -&gt; ST s ByteArray
forall s a. STRep s a -&gt; ST s a
</span><span class="hs-identifier hs-var">ST</span></span><span> </span><span class="annot"><span class="annottext">(STRep s ByteArray -&gt; ST s ByteArray)
-&gt; STRep s ByteArray -&gt; ST s ByteArray
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1148"></span><span>          </span><span class="hs-glyph">\</span><span id="local-6989586621679197020"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197020"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Int# -&gt; State# s -&gt; (# State# s, MutableByteArray# s #)
forall d. Int# -&gt; State# d -&gt; (# State# d, MutableByteArray# d #)
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#newPinnedByteArray%23"><span class="hs-identifier hs-var">newPinnedByteArray#</span></a></span><span> </span><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679197017"><span class="hs-identifier hs-var">len#</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197020"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1149"></span><span>            </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197021"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197021"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197022"><span class="annot"><span class="annottext">MutableByteArray# s
</span><a href="#local-6989586621679197022"><span class="hs-identifier hs-var">mb</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ByteArray#
-&gt; Int#
-&gt; MutableByteArray# s
-&gt; Int#
-&gt; Int#
-&gt; State# s
-&gt; State# s
forall d.
ByteArray#
-&gt; Int#
-&gt; MutableByteArray# d
-&gt; Int#
-&gt; Int#
-&gt; State# d
-&gt; State# d
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#copyByteArray%23"><span class="hs-identifier hs-var">copyByteArray#</span></a></span><span> </span><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197010"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Int#
</span><span class="hs-number">0#</span></span><span> </span><span class="annot"><span class="annottext">MutableByteArray# s
</span><a href="#local-6989586621679197022"><span class="hs-identifier hs-var">mb</span></a></span><span> </span><span class="annot"><span class="annottext">Int#
</span><span class="hs-number">0#</span></span><span> </span><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679197017"><span class="hs-identifier hs-var">len#</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197021"><span class="hs-identifier hs-var">s'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1150"></span><span>              </span><span id="local-6989586621679197023"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197023"><span class="hs-identifier hs-var">s''</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">MutableByteArray# s -&gt; State# s -&gt; (# State# s, ByteArray# #)
forall d.
MutableByteArray# d -&gt; State# d -&gt; (# State# d, ByteArray# #)
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#unsafeFreezeByteArray%23"><span class="hs-identifier hs-var">unsafeFreezeByteArray#</span></a></span><span> </span><span class="annot"><span class="annottext">MutableByteArray# s
</span><a href="#local-6989586621679197022"><span class="hs-identifier hs-var">mb</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197023"><span class="hs-identifier hs-var">s''</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1151"></span><span>                </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197024"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197024"><span class="hs-identifier hs-var">s'''</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197025"><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197025"><span class="hs-identifier hs-var">ret</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197024"><span class="hs-identifier hs-var">s'''</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ByteArray# -&gt; ByteArray
</span><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html#ByteArray"><span class="hs-identifier hs-var">ByteArray</span></a></span><span> </span><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197025"><span class="hs-identifier hs-var">ret</span></a></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1152"></span><span>      </span><span class="annot"><a href="#local-6989586621679197016"><span class="hs-identifier hs-type">ptr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ForeignPtr</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span>
</span><span id="line-1153"></span><span>      </span><span id="local-6989586621679197016"><span class="annot"><span class="annottext">ptr :: ForeignPtr Word8
</span><a href="#local-6989586621679197016"><span class="hs-identifier hs-var hs-var">ptr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Addr# -&gt; ForeignPtrContents -&gt; ForeignPtr Word8
forall a. Addr# -&gt; ForeignPtrContents -&gt; ForeignPtr a
</span><span class="hs-identifier hs-var">ForeignPtr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ByteArray# -&gt; Addr#
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#byteArrayContents%23"><span class="hs-identifier hs-var">byteArrayContents#</span></a></span><span> </span><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197018"><span class="hs-identifier hs-var">pb</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MutableByteArray# RealWorld -&gt; ForeignPtrContents
</span><span class="hs-identifier hs-var">PlainPtr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ByteArray# -&gt; MutableByteArray# RealWorld
forall a b. a -&gt; b
</span><span class="hs-identifier hs-var">unsafeCoerce#</span></span><span> </span><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197018"><span class="hs-identifier hs-var">pb</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1154"></span><span>
</span><span id="line-1155"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addrToByteArrayName"><span class="hs-identifier hs-type">addrToByteArrayName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1156"></span><span id="addrToByteArrayName"><span class="annot"><span class="annottext">addrToByteArrayName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#addrToByteArrayName"><span class="hs-identifier hs-var hs-var">addrToByteArrayName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">addrToByteArray</span><span>
</span><span id="line-1157"></span><span>
</span><span id="line-1158"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#addrToByteArray"><span class="hs-identifier hs-type">addrToByteArray</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#Addr%23"><span class="hs-identifier hs-type">Addr#</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html#ByteArray"><span class="hs-identifier hs-type">ByteArray</span></a></span><span>
</span><span id="line-1159"></span><span id="addrToByteArray"><span class="annot"><span class="annottext">addrToByteArray :: Int -&gt; Addr# -&gt; ByteArray
</span><a href="Language.Haskell.TH.Syntax.html#addrToByteArray"><span class="hs-identifier hs-var hs-var">addrToByteArray</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#I%23"><span class="hs-identifier hs-type">I#</span></a></span><span> </span><span id="local-6989586621679197029"><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679197029"><span class="hs-identifier hs-var">len</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679197030"><span class="annot"><span class="annottext">Addr#
</span><a href="#local-6989586621679197030"><span class="hs-identifier hs-var">addr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall s. ST s ByteArray) -&gt; ByteArray
forall a. (forall s. ST s a) -&gt; a
</span><span class="hs-identifier hs-var">runST</span></span><span> </span><span class="annot"><span class="annottext">((forall s. ST s ByteArray) -&gt; ByteArray)
-&gt; (forall s. ST s ByteArray) -&gt; ByteArray
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">STRep s ByteArray -&gt; ST s ByteArray
forall s a. STRep s a -&gt; ST s a
</span><span class="hs-identifier hs-var">ST</span></span><span> </span><span class="annot"><span class="annottext">(STRep s ByteArray -&gt; ST s ByteArray)
-&gt; STRep s ByteArray -&gt; ST s ByteArray
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1160"></span><span>  </span><span class="hs-glyph">\</span><span id="local-6989586621679197031"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197031"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Int# -&gt; State# s -&gt; (# State# s, MutableByteArray# s #)
forall d. Int# -&gt; State# d -&gt; (# State# d, MutableByteArray# d #)
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#newByteArray%23"><span class="hs-identifier hs-var">newByteArray#</span></a></span><span> </span><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679197029"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197031"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1161"></span><span>    </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197032"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197032"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197033"><span class="annot"><span class="annottext">MutableByteArray# s
</span><a href="#local-6989586621679197033"><span class="hs-identifier hs-var">mb</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Addr#
-&gt; MutableByteArray# s -&gt; Int# -&gt; Int# -&gt; State# s -&gt; State# s
forall d.
Addr#
-&gt; MutableByteArray# d -&gt; Int# -&gt; Int# -&gt; State# d -&gt; State# d
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#copyAddrToByteArray%23"><span class="hs-identifier hs-var">copyAddrToByteArray#</span></a></span><span> </span><span class="annot"><span class="annottext">Addr#
</span><a href="#local-6989586621679197030"><span class="hs-identifier hs-var">addr</span></a></span><span> </span><span class="annot"><span class="annottext">MutableByteArray# s
</span><a href="#local-6989586621679197033"><span class="hs-identifier hs-var">mb</span></a></span><span> </span><span class="annot"><span class="annottext">Int#
</span><span class="hs-number">0#</span></span><span> </span><span class="annot"><span class="annottext">Int#
</span><a href="#local-6989586621679197029"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197032"><span class="hs-identifier hs-var">s'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1162"></span><span>      </span><span id="local-6989586621679197034"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197034"><span class="hs-identifier hs-var">s''</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">MutableByteArray# s -&gt; State# s -&gt; (# State# s, ByteArray# #)
forall d.
MutableByteArray# d -&gt; State# d -&gt; (# State# d, ByteArray# #)
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Prim.html#unsafeFreezeByteArray%23"><span class="hs-identifier hs-var">unsafeFreezeByteArray#</span></a></span><span> </span><span class="annot"><span class="annottext">MutableByteArray# s
</span><a href="#local-6989586621679197033"><span class="hs-identifier hs-var">mb</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197034"><span class="hs-identifier hs-var">s''</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1163"></span><span>        </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197035"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197035"><span class="hs-identifier hs-var">s'''</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197036"><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197036"><span class="hs-identifier hs-var">ret</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679197035"><span class="hs-identifier hs-var">s'''</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ByteArray# -&gt; ByteArray
</span><a href="../../base-4.20.1.0-inplace/src/Data.Array.Byte.html#ByteArray"><span class="hs-identifier hs-var">ByteArray</span></a></span><span> </span><span class="annot"><span class="annottext">ByteArray#
</span><a href="#local-6989586621679197036"><span class="hs-identifier hs-var">ret</span></a></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1164"></span><span>
</span><span id="line-1165"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193631"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193631"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679193631"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1166"></span><span>  </span><span id="local-6989586621679197045"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Maybe a -&gt; Code m (Maybe a)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197046"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679197046"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (Maybe a)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Maybe a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679197046"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1167"></span><span>
</span><span id="line-1168"></span><span>  </span><span id="local-6989586621679197053"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Maybe a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Syntax.html#nothingName"><span class="hs-identifier hs-var">nothingName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1169"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679197055"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197055"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Exp) -&gt; m Exp -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Syntax.html#justName"><span class="hs-identifier hs-var">justName</span></a></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Exp -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#AppE"><span class="hs-operator hs-var">`AppE`</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197055"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1170"></span><span>
</span><span id="line-1171"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193639"><span id="local-6989586621679193640"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193639"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193640"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679193639"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193640"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1172"></span><span>  </span><span id="local-6989586621679197066"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Either a b -&gt; Code m (Either a b)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197067"><span class="annot"><span class="annottext">Either a b
</span><a href="#local-6989586621679197067"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (Either a b)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Either a b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; Either a b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">Either a b
</span><a href="#local-6989586621679197067"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1173"></span><span>
</span><span id="line-1174"></span><span>  </span><span id="local-6989586621679197076"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Either a b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679197077"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197077"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Exp) -&gt; m Exp -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Syntax.html#leftName"><span class="hs-identifier hs-var">leftName</span></a></span><span>  </span><span class="annot"><span class="annottext">Exp -&gt; Exp -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#AppE"><span class="hs-operator hs-var">`AppE`</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197077"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1175"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679197079"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197079"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Exp) -&gt; m Exp -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Syntax.html#rightName"><span class="hs-identifier hs-var">rightName</span></a></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Exp -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#AppE"><span class="hs-operator hs-var">`AppE`</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197079"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1176"></span><span>
</span><span id="line-1177"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193644"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193644"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679193644"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1178"></span><span>  </span><span id="local-6989586621679197089"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; [a] -&gt; Code m [a]
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197090"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679197090"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m [a]
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a] -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; [a] -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679197090"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1179"></span><span>  </span><span id="local-6989586621679197099"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; [a] -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679197100"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679197100"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621679197101"><span class="annot"><a href="#local-6989586621679197101"><span class="hs-identifier hs-var">xs'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m Exp) -&gt; [a] -&gt; m [Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679197100"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ListE"><span class="hs-identifier hs-type">ListE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679197101"><span class="hs-identifier hs-type">xs'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1180"></span><span>
</span><span id="line-1181"></span><span id="local-6989586621679193650"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#liftString"><span class="hs-identifier hs-type">liftString</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193650"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193650"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span></span><span>
</span><span id="line-1182"></span><span class="hs-comment">-- Used in GHC.Tc.Gen.Expr to short-circuit the lifting for strings</span><span>
</span><span id="line-1183"></span><span id="liftString"><span class="annot"><span class="annottext">liftString :: forall (m :: * -&gt; *). Quote m =&gt; FilePath -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#liftString"><span class="hs-identifier hs-var hs-var">liftString</span></a></span></span><span> </span><span id="local-6989586621679197107"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679197107"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#StringL"><span class="hs-identifier hs-var">StringL</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679197107"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1184"></span><span>
</span><span id="line-1185"></span><span class="annot"><span class="hs-comment">-- | @since 2.15.0.0</span></span><span>
</span><span id="line-1186"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193653"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193653"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><a href="#local-6989586621679193653"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1187"></span><span>  </span><span id="local-6989586621679197117"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; NonEmpty a -&gt; Code m (NonEmpty a)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197118"><span class="annot"><span class="annottext">NonEmpty a
</span><a href="#local-6989586621679197118"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (NonEmpty a)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; NonEmpty a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty a
</span><a href="#local-6989586621679197118"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1188"></span><span>
</span><span id="line-1189"></span><span>  </span><span id="local-6989586621679197128"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; NonEmpty a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679197129"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197129"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span id="local-6989586621679197131"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679197131"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1190"></span><span>    </span><span id="local-6989586621679197132"><span class="annot"><a href="#local-6989586621679197132"><span class="hs-identifier hs-var">x'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197129"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1191"></span><span>    </span><span id="local-6989586621679197133"><span class="annot"><a href="#local-6989586621679197133"><span class="hs-identifier hs-var">xs'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-type">lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679197131"><span class="hs-identifier hs-type">xs</span></a></span><span>
</span><span id="line-1192"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixE"><span class="hs-identifier hs-type">InfixE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621679197132"><span class="hs-identifier hs-type">x'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-type">ConE</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nonemptyName"><span class="hs-identifier hs-type">nonemptyName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><a href="#local-6989586621679197133"><span class="hs-identifier hs-type">xs'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1193"></span><span>
</span><span id="line-1194"></span><span class="annot"><span class="hs-comment">-- | @since 2.15.0.0</span></span><span>
</span><span id="line-1195"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1196"></span><span>  </span><span id="local-6989586621679197140"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; Void -&gt; Code m Void
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp Void) -&gt; Code m Void
forall a (m :: * -&gt; *). m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#liftCode"><span class="hs-identifier hs-var">liftCode</span></a></span><span> </span><span class="annot"><span class="annottext">(m (TExp Void) -&gt; Code m Void)
-&gt; (Void -&gt; m (TExp Void)) -&gt; Void -&gt; Code m Void
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Void -&gt; m (TExp Void)
forall a. Void -&gt; a
</span><span class="hs-identifier hs-var">absurd</span></span><span>
</span><span id="line-1197"></span><span>  </span><span id="local-6989586621679197145"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; Void -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; m Exp) -&gt; (Void -&gt; Exp) -&gt; Void -&gt; m Exp
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Void -&gt; Exp
forall a. Void -&gt; a
</span><span class="hs-identifier hs-var">absurd</span></span><span>
</span><span id="line-1198"></span><span>
</span><span id="line-1199"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1200"></span><span>  </span><span id="local-6989586621679197153"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; () -&gt; Code m ()
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197154"><span class="annot"><span class="annottext">()
</span><a href="#local-6989586621679197154"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m ()
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; () -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">()
</span><a href="#local-6989586621679197154"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1201"></span><span>  </span><span id="local-6989586621679197158"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; () -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#tupleDataName"><span class="hs-identifier hs-var">tupleDataName</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1202"></span><span>
</span><span id="line-1203"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193663"><span id="local-6989586621679193664"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193663"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193664"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193663"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193664"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1204"></span><span>  </span><span id="local-6989586621679197169"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; (a, b) -&gt; Code m (a, b)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197170"><span class="annot"><span class="annottext">(a, b)
</span><a href="#local-6989586621679197170"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (a, b)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, b) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (a, b) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(a, b)
</span><a href="#local-6989586621679197170"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1205"></span><span>  </span><span id="local-6989586621679197183"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (a, b) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679197184"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197184"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197185"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197185"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1206"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#TupE"><span class="hs-identifier hs-var">TupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197184"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197185"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1207"></span><span>
</span><span id="line-1208"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193670"><span id="local-6989586621679193671"><span id="local-6989586621679193672"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193670"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193671"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193672"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193670"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193671"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193672"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1209"></span><span>  </span><span id="local-6989586621679197197"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; (a, b, c) -&gt; Code m (a, b, c)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197198"><span class="annot"><span class="annottext">(a, b, c)
</span><a href="#local-6989586621679197198"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (a, b, c)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, b, c) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (a, b, c) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(a, b, c)
</span><a href="#local-6989586621679197198"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1210"></span><span>  </span><span id="local-6989586621679197213"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (a, b, c) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679197214"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197214"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197215"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197215"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197216"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197216"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1211"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#TupE"><span class="hs-identifier hs-var">TupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197214"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197215"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197216"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1212"></span><span>
</span><span id="line-1213"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193679"><span id="local-6989586621679193680"><span id="local-6989586621679193681"><span id="local-6989586621679193682"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193679"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193680"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193681"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193682"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193679"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193680"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193681"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193682"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1214"></span><span>  </span><span id="local-6989586621679197228"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(a, b, c, d) -&gt; Code m (a, b, c, d)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197229"><span class="annot"><span class="annottext">(a, b, c, d)
</span><a href="#local-6989586621679197229"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (a, b, c, d)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, b, c, d) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (a, b, c, d) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(a, b, c, d)
</span><a href="#local-6989586621679197229"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1215"></span><span>  </span><span id="local-6989586621679197246"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (a, b, c, d) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679197247"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197247"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197248"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197248"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197249"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197249"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197250"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197250"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1216"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#TupE"><span class="hs-identifier hs-var">TupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197247"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197248"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197249"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197250"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1217"></span><span>
</span><span id="line-1218"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193690"><span id="local-6989586621679193691"><span id="local-6989586621679193692"><span id="local-6989586621679193693"><span id="local-6989586621679193694"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193690"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193691"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193692"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193693"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193694"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1219"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193690"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193691"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193692"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193693"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193694"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">)</span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1220"></span><span>  </span><span id="local-6989586621679197263"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(a, b, c, d, e) -&gt; Code m (a, b, c, d, e)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197264"><span class="annot"><span class="annottext">(a, b, c, d, e)
</span><a href="#local-6989586621679197264"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (a, b, c, d, e)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, b, c, d, e) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (a, b, c, d, e) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(a, b, c, d, e)
</span><a href="#local-6989586621679197264"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1221"></span><span>  </span><span id="local-6989586621679197283"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (a, b, c, d, e) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679197284"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197284"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197285"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197285"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197286"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197286"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197287"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197287"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197288"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197288"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1222"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#TupE"><span class="hs-identifier hs-var">TupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197284"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197285"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1223"></span><span>                                              </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197286"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197287"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197288"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1224"></span><span>
</span><span id="line-1225"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193703"><span id="local-6989586621679193704"><span id="local-6989586621679193705"><span id="local-6989586621679193706"><span id="local-6989586621679193707"><span id="local-6989586621679193708"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193703"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193704"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193705"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193706"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193707"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193708"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1226"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193703"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193704"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193705"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193706"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193707"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193708"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1227"></span><span>  </span><span id="local-6989586621679197302"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(a, b, c, d, e, f) -&gt; Code m (a, b, c, d, e, f)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197303"><span class="annot"><span class="annottext">(a, b, c, d, e, f)
</span><a href="#local-6989586621679197303"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (a, b, c, d, e, f)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, b, c, d, e, f) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (a, b, c, d, e, f) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(a, b, c, d, e, f)
</span><a href="#local-6989586621679197303"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1228"></span><span>  </span><span id="local-6989586621679197324"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (a, b, c, d, e, f) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679197325"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197325"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197326"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197326"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197327"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197327"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197328"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197328"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197329"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197329"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197330"><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197330"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1229"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#TupE"><span class="hs-identifier hs-var">TupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197325"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197326"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197327"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1230"></span><span>                                              </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197328"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197329"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">f -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; f -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197330"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1231"></span><span>
</span><span id="line-1232"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193718"><span id="local-6989586621679193719"><span id="local-6989586621679193720"><span id="local-6989586621679193721"><span id="local-6989586621679193722"><span id="local-6989586621679193723"><span id="local-6989586621679193724"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193718"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193719"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193720"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193721"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193722"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193723"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193724"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1233"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193718"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193719"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193720"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193721"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193722"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193723"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193724"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1234"></span><span>  </span><span id="local-6989586621679197345"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(a, b, c, d, e, f, g) -&gt; Code m (a, b, c, d, e, f, g)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197346"><span class="annot"><span class="annottext">(a, b, c, d, e, f, g)
</span><a href="#local-6989586621679197346"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (a, b, c, d, e, f, g)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, b, c, d, e, f, g) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (a, b, c, d, e, f, g) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(a, b, c, d, e, f, g)
</span><a href="#local-6989586621679197346"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1235"></span><span>  </span><span id="local-6989586621679197369"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (a, b, c, d, e, f, g) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679197370"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197370"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197371"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197371"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197372"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197372"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197373"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197373"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197374"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197374"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197375"><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197375"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197376"><span class="annot"><span class="annottext">g
</span><a href="#local-6989586621679197376"><span class="hs-identifier hs-var">g</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1236"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#TupE"><span class="hs-identifier hs-var">TupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197370"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197371"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197372"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1237"></span><span>                                              </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197373"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197374"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">f -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; f -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197375"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">g -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; g -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">g
</span><a href="#local-6989586621679197376"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1238"></span><span>
</span><span id="line-1239"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1240"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1241"></span><span>  </span><span id="local-6989586621679197384"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; (# #) -&gt; Code m (# #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197385"><span class="annot"><span class="annottext">(# #)
</span><a href="#local-6989586621679197385"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# #)
</span><a href="#local-6989586621679197385"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1242"></span><span>  </span><span id="local-6989586621679197389"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(#</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#unboxedTupleTypeName"><span class="hs-identifier hs-var">unboxedTupleTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1243"></span><span>
</span><span id="line-1244"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1245"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193730"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193730"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193730"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">#)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1246"></span><span>  </span><span id="local-6989586621679197399"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; (# a #) -&gt; Code m (# a #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197400"><span class="annot"><span class="annottext">(# a #)
</span><a href="#local-6989586621679197400"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a #)
</span><a href="#local-6989586621679197400"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1247"></span><span>  </span><span id="local-6989586621679197411"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197412"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197412"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1248"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedTupE"><span class="hs-identifier hs-var">UnboxedTupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197412"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1249"></span><span>
</span><span id="line-1250"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1251"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193735"><span id="local-6989586621679193736"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193735"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193736"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193735"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193736"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-special">#)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1252"></span><span>  </span><span id="local-6989586621679197423"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; (# a, b #) -&gt; Code m (# a, b #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197424"><span class="annot"><span class="annottext">(# a, b #)
</span><a href="#local-6989586621679197424"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a, b #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a, b #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a, b #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a, b #)
</span><a href="#local-6989586621679197424"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1253"></span><span>  </span><span id="local-6989586621679197437"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a, b #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197438"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197438"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197439"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197439"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1254"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedTupE"><span class="hs-identifier hs-var">UnboxedTupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197438"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197439"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1255"></span><span>
</span><span id="line-1256"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1257"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193742"><span id="local-6989586621679193743"><span id="local-6989586621679193744"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193742"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193743"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193744"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1258"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193742"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193743"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193744"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1259"></span><span>  </span><span id="local-6989586621679197450"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a, b, c #) -&gt; Code m (# a, b, c #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197451"><span class="annot"><span class="annottext">(# a, b, c #)
</span><a href="#local-6989586621679197451"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a, b, c #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a, b, c #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a, b, c #)
</span><a href="#local-6989586621679197451"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1260"></span><span>  </span><span id="local-6989586621679197466"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197467"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197467"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197468"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197468"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197469"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197469"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1261"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedTupE"><span class="hs-identifier hs-var">UnboxedTupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197467"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197468"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197469"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1262"></span><span>
</span><span id="line-1263"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1264"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193751"><span id="local-6989586621679193752"><span id="local-6989586621679193753"><span id="local-6989586621679193754"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193751"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193752"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193753"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193754"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1265"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193751"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193752"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193753"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193754"><span class="hs-identifier hs-type">d</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1266"></span><span>  </span><span id="local-6989586621679197481"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a, b, c, d #) -&gt; Code m (# a, b, c, d #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197482"><span class="annot"><span class="annottext">(# a, b, c, d #)
</span><a href="#local-6989586621679197482"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a, b, c, d #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a, b, c, d #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c, d #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a, b, c, d #)
</span><a href="#local-6989586621679197482"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1267"></span><span>  </span><span id="local-6989586621679197499"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c, d #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197500"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197500"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197501"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197501"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197502"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197502"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197503"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197503"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1268"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedTupE"><span class="hs-identifier hs-var">UnboxedTupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197500"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197501"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1269"></span><span>                                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197502"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197503"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1270"></span><span>
</span><span id="line-1271"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1272"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193762"><span id="local-6989586621679193763"><span id="local-6989586621679193764"><span id="local-6989586621679193765"><span id="local-6989586621679193766"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193762"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193763"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193764"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193765"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193766"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1273"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193762"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193763"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193764"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193765"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193766"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1274"></span><span>  </span><span id="local-6989586621679197516"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a, b, c, d, e #) -&gt; Code m (# a, b, c, d, e #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197517"><span class="annot"><span class="annottext">(# a, b, c, d, e #)
</span><a href="#local-6989586621679197517"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a, b, c, d, e #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a, b, c, d, e #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c, d, e #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a, b, c, d, e #)
</span><a href="#local-6989586621679197517"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1275"></span><span>  </span><span id="local-6989586621679197536"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c, d, e #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197537"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197537"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197538"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197538"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197539"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197539"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197540"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197540"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197541"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197541"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1276"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedTupE"><span class="hs-identifier hs-var">UnboxedTupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197537"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197538"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1277"></span><span>                                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197539"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197540"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197541"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1278"></span><span>
</span><span id="line-1279"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1280"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193775"><span id="local-6989586621679193776"><span id="local-6989586621679193777"><span id="local-6989586621679193778"><span id="local-6989586621679193779"><span id="local-6989586621679193780"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193775"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193776"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193777"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193778"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193779"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193780"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1281"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193775"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193776"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193777"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193778"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193779"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193780"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1282"></span><span>  </span><span id="local-6989586621679197555"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a, b, c, d, e, f #) -&gt; Code m (# a, b, c, d, e, f #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197556"><span class="annot"><span class="annottext">(# a, b, c, d, e, f #)
</span><a href="#local-6989586621679197556"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a, b, c, d, e, f #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a, b, c, d, e, f #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c, d, e, f #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a, b, c, d, e, f #)
</span><a href="#local-6989586621679197556"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1283"></span><span>  </span><span id="local-6989586621679197577"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c, d, e, f #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197578"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197578"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197579"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197579"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197580"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197580"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197581"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197581"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197582"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197582"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197583"><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197583"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1284"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedTupE"><span class="hs-identifier hs-var">UnboxedTupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197578"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197579"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197580"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1285"></span><span>                                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197581"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197582"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">f -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; f -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197583"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1286"></span><span>
</span><span id="line-1287"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1288"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193790"><span id="local-6989586621679193791"><span id="local-6989586621679193792"><span id="local-6989586621679193793"><span id="local-6989586621679193794"><span id="local-6989586621679193795"><span id="local-6989586621679193796"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193790"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193791"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193792"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193793"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193794"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193795"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193796"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1289"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193790"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193791"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193792"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193793"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193794"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193795"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679193796"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1290"></span><span>  </span><span id="local-6989586621679197598"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a, b, c, d, e, f, g #) -&gt; Code m (# a, b, c, d, e, f, g #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197599"><span class="annot"><span class="annottext">(# a, b, c, d, e, f, g #)
</span><a href="#local-6989586621679197599"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a, b, c, d, e, f, g #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a, b, c, d, e, f, g #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c, d, e, f, g #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a, b, c, d, e, f, g #)
</span><a href="#local-6989586621679197599"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1291"></span><span>  </span><span id="local-6989586621679197622"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a, b, c, d, e, f, g #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197623"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197623"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197624"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197624"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197625"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197625"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197626"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197626"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197627"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197627"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197628"><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197628"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679197629"><span class="annot"><span class="annottext">g
</span><a href="#local-6989586621679197629"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-1292"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe Exp] -&gt; Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[Maybe Exp] -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedTupE"><span class="hs-identifier hs-var">UnboxedTupE</span></a></span><span> </span><span class="annot"><span class="annottext">(m [Maybe Exp] -&gt; m Exp) -&gt; m [Maybe Exp] -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[m (Maybe Exp)] -&gt; m [Maybe Exp]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">([m (Maybe Exp)] -&gt; m [Maybe Exp])
-&gt; [m (Maybe Exp)] -&gt; m [Maybe Exp]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; m (Maybe Exp)) -&gt; [m Exp] -&gt; [m (Maybe Exp)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Exp -&gt; Maybe Exp) -&gt; m Exp -&gt; m (Maybe Exp)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Maybe Exp
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197623"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197624"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197625"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1293"></span><span>                                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197626"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197627"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">f -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; f -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197628"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-1294"></span><span>                                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">g -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; g -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">g
</span><a href="#local-6989586621679197629"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1295"></span><span>
</span><span id="line-1296"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1297"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193801"><span id="local-6989586621679193802"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193801"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193802"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193801"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193802"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-special">#)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1298"></span><span>  </span><span id="local-6989586621679197639"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *). Quote m =&gt; (# a | b #) -&gt; Code m (# a | b #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197640"><span class="annot"><span class="annottext">(# a | b #)
</span><a href="#local-6989586621679197640"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a | b #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a | b #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a | b #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a | b #)
</span><a href="#local-6989586621679197640"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1299"></span><span>  </span><span id="local-6989586621679197663"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a | b #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679197664"><span class="annot"><span class="annottext">(# a | b #)
</span><a href="#local-6989586621679197664"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-1300"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(# a | b #)
</span><a href="#local-6989586621679197664"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1301"></span><span>        </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197665"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197665"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197665"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span>
</span><span id="line-1302"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197668"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197668"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197668"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span>
</span><span id="line-1303"></span><span>
</span><span id="line-1304"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1305"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193811"><span id="local-6989586621679193812"><span id="local-6989586621679193813"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193811"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193812"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193813"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1306"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193811"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193812"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193813"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1307"></span><span>  </span><span id="local-6989586621679197679"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c #) -&gt; Code m (# a | b | c #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197680"><span class="annot"><span class="annottext">(# a | b | c #)
</span><a href="#local-6989586621679197680"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a | b | c #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a | b | c #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a | b | c #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a | b | c #)
</span><a href="#local-6989586621679197680"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1308"></span><span>  </span><span id="local-6989586621679197712"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a | b | c #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679197713"><span class="annot"><span class="annottext">(# a | b | c #)
</span><a href="#local-6989586621679197713"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-1309"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(# a | b | c #)
</span><a href="#local-6989586621679197713"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1310"></span><span>        </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197714"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197714"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197714"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span>
</span><span id="line-1311"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197715"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197715"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197715"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span>
</span><span id="line-1312"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197716"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197716"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197716"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span>
</span><span id="line-1313"></span><span>
</span><span id="line-1314"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1315"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193820"><span id="local-6989586621679193821"><span id="local-6989586621679193822"><span id="local-6989586621679193823"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193820"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193821"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193822"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193823"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1316"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193820"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193821"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193822"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193823"><span class="hs-identifier hs-type">d</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1317"></span><span>  </span><span id="local-6989586621679197728"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c | d #) -&gt; Code m (# a | b | c | d #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197729"><span class="annot"><span class="annottext">(# a | b | c | d #)
</span><a href="#local-6989586621679197729"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a | b | c | d #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a | b | c | d #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a | b | c | d #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a | b | c | d #)
</span><a href="#local-6989586621679197729"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1318"></span><span>  </span><span id="local-6989586621679197770"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a | b | c | d #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679197771"><span class="annot"><span class="annottext">(# a | b | c | d #)
</span><a href="#local-6989586621679197771"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-1319"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(# a | b | c | d #)
</span><a href="#local-6989586621679197771"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1320"></span><span>        </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197772"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197772"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197772"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">4</span></span><span>
</span><span id="line-1321"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197773"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197773"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197773"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">4</span></span><span>
</span><span id="line-1322"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197774"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197774"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197774"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">4</span></span><span>
</span><span id="line-1323"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197775"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197775"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197775"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">4</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">4</span></span><span>
</span><span id="line-1324"></span><span>
</span><span id="line-1325"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1326"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193831"><span id="local-6989586621679193832"><span id="local-6989586621679193833"><span id="local-6989586621679193834"><span id="local-6989586621679193835"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193831"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193832"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193833"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193834"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193835"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1327"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193831"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193832"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193833"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193834"><span class="hs-identifier hs-type">d</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193835"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1328"></span><span>  </span><span id="local-6989586621679197788"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c | d | e #) -&gt; Code m (# a | b | c | d | e #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197789"><span class="annot"><span class="annottext">(# a | b | c | d | e #)
</span><a href="#local-6989586621679197789"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a | b | c | d | e #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a | b | c | d | e #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; (# a | b | c | d | e #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a | b | c | d | e #)
</span><a href="#local-6989586621679197789"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1329"></span><span>  </span><span id="local-6989586621679197839"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *). Quote m =&gt; (# a | b | c | d | e #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679197840"><span class="annot"><span class="annottext">(# a | b | c | d | e #)
</span><a href="#local-6989586621679197840"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-1330"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(# a | b | c | d | e #)
</span><a href="#local-6989586621679197840"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1331"></span><span>        </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197841"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197841"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197841"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">5</span></span><span>
</span><span id="line-1332"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197842"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197842"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197842"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">5</span></span><span>
</span><span id="line-1333"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197843"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197843"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197843"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">5</span></span><span>
</span><span id="line-1334"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197844"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197844"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197844"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">4</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">5</span></span><span>
</span><span id="line-1335"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197845"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197845"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197845"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">5</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">5</span></span><span>
</span><span id="line-1336"></span><span>
</span><span id="line-1337"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1338"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193844"><span id="local-6989586621679193845"><span id="local-6989586621679193846"><span id="local-6989586621679193847"><span id="local-6989586621679193848"><span id="local-6989586621679193849"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193844"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193845"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193846"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193847"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193848"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193849"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1339"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193844"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193845"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193846"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193847"><span class="hs-identifier hs-type">d</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193848"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193849"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1340"></span><span>  </span><span id="local-6989586621679197859"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c | d | e | f #) -&gt; Code m (# a | b | c | d | e | f #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197860"><span class="annot"><span class="annottext">(# a | b | c | d | e | f #)
</span><a href="#local-6989586621679197860"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a | b | c | d | e | f #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a | b | c | d | e | f #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c | d | e | f #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a | b | c | d | e | f #)
</span><a href="#local-6989586621679197860"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1341"></span><span>  </span><span id="local-6989586621679197919"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c | d | e | f #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679197920"><span class="annot"><span class="annottext">(# a | b | c | d | e | f #)
</span><a href="#local-6989586621679197920"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-1342"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(# a | b | c | d | e | f #)
</span><a href="#local-6989586621679197920"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1343"></span><span>        </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679197921"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197921"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679197921"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">6</span></span><span>
</span><span id="line-1344"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197922"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197922"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679197922"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">6</span></span><span>
</span><span id="line-1345"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197923"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197923"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679197923"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">6</span></span><span>
</span><span id="line-1346"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197924"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197924"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679197924"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">4</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">6</span></span><span>
</span><span id="line-1347"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197925"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197925"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679197925"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">5</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">6</span></span><span>
</span><span id="line-1348"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679197926"><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197926"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; f -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679197926"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">6</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">6</span></span><span>
</span><span id="line-1349"></span><span>
</span><span id="line-1350"></span><span class="annot"><span class="hs-comment">-- | @since 2.16.0.0</span></span><span>
</span><span id="line-1351"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679193859"><span id="local-6989586621679193860"><span id="local-6989586621679193861"><span id="local-6989586621679193862"><span id="local-6989586621679193863"><span id="local-6989586621679193864"><span id="local-6989586621679193865"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193859"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193860"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193861"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193862"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193863"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193864"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193865"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1352"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lift"><span class="hs-identifier hs-type">Lift</span></a></span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><a href="#local-6989586621679193859"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193860"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193861"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193862"><span class="hs-identifier hs-type">d</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193863"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193864"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679193865"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="hs-special">#)</span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1353"></span><span>  </span><span id="local-6989586621679197941"><span class="annot"><span class="annottext">liftTyped :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c | d | e | f | g #)
-&gt; Code m (# a | b | c | d | e | f | g #)
</span><a href="Language.Haskell.TH.Syntax.html#liftTyped"><span class="hs-identifier hs-var hs-var hs-var">liftTyped</span></a></span></span><span> </span><span id="local-6989586621679197942"><span class="annot"><span class="annottext">(# a | b | c | d | e | f | g #)
</span><a href="#local-6989586621679197942"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m (# a | b | c | d | e | f | g #)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.html#unsafeCodeCoerce"><span class="hs-identifier hs-var">unsafeCodeCoerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(# a | b | c | d | e | f | g #) -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c | d | e | f | g #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">(# a | b | c | d | e | f | g #)
</span><a href="#local-6989586621679197942"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1354"></span><span>  </span><span id="local-6989586621679198010"><span class="annot"><span class="annottext">lift :: forall (m :: * -&gt; *).
Quote m =&gt;
(# a | b | c | d | e | f | g #) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var hs-var hs-var">lift</span></a></span></span><span> </span><span id="local-6989586621679198011"><span class="annot"><span class="annottext">(# a | b | c | d | e | f | g #)
</span><a href="#local-6989586621679198011"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-1355"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(# a | b | c | d | e | f | g #)
</span><a href="#local-6989586621679198011"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1356"></span><span>        </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679198012"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679198012"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679198012"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span>
</span><span id="line-1357"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679198013"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679198013"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; b -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679198013"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span>
</span><span id="line-1358"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679198014"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679198014"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">c -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; c -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679198014"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">3</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span>
</span><span id="line-1359"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679198015"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679198015"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">d -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; d -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679198015"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">4</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span>
</span><span id="line-1360"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679198016"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679198016"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">e -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; e -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679198016"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">5</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span>
</span><span id="line-1361"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679198017"><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679198017"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; f -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">f
</span><a href="#local-6989586621679198017"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">6</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span>
</span><span id="line-1362"></span><span>        </span><span class="hs-special">(#</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679198018"><span class="annot"><span class="annottext">g
</span><a href="#local-6989586621679198018"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; Int -&gt; Int -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span><span> </span><span class="annot"><span class="annottext">(Exp -&gt; Int -&gt; Int -&gt; Exp) -&gt; m Exp -&gt; m (Int -&gt; Int -&gt; Exp)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">g -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; g -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-identifier hs-var">lift</span></a></span><span> </span><span class="annot"><span class="annottext">g
</span><a href="#local-6989586621679198018"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Int -&gt; Exp) -&gt; m Int -&gt; m (Int -&gt; Exp)
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span> </span><span class="annot"><span class="annottext">m (Int -&gt; Exp) -&gt; m Int -&gt; m Exp
forall a b. m (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; m Int
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">7</span></span><span>
</span><span id="line-1363"></span><span>
</span><span id="line-1364"></span><span class="hs-comment">-- TH has a special form for literal strings,</span><span>
</span><span id="line-1365"></span><span class="hs-comment">-- which we should take advantage of.</span><span>
</span><span id="line-1366"></span><span class="hs-comment">-- NB: the lhs of the rule has no args, so that</span><span>
</span><span id="line-1367"></span><span class="hs-comment">--     the rule will apply to a 'lift' all on its own</span><span>
</span><span id="line-1368"></span><span class="hs-comment">--     which happens to be the way the type checker</span><span>
</span><span id="line-1369"></span><span class="hs-comment">--     creates it.</span><span>
</span><span id="line-1370"></span><span class="hs-pragma">{-# RULES</span><span> </span><span class="annot"><span class="hs-pragma">&quot;TH:liftString&quot;</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#lift"><span class="hs-pragma hs-type">lift</span></a></span><span> </span><span class="hs-pragma">=</span><span> </span><span class="hs-pragma">\</span><span id="local-6989586621679198019"><span class="annot"><a href="#local-6989586621679198019"><span class="hs-pragma hs-var">s</span></a></span></span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><span class="hs-pragma hs-type">return</span></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-pragma hs-type">LitE</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StringL"><span class="hs-pragma hs-type">StringL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679198019"><span class="hs-pragma hs-type">s</span></a></span><span class="hs-pragma">)</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1371"></span><span>
</span><span id="line-1372"></span><span>
</span><span id="line-1373"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#trueName"><span class="hs-identifier hs-type">trueName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#falseName"><span class="hs-identifier hs-type">falseName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1374"></span><span id="trueName"><span class="annot"><span class="annottext">trueName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#trueName"><span class="hs-identifier hs-var hs-var">trueName</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">True</span><span>
</span><span id="line-1375"></span><span id="falseName"><span class="annot"><span class="annottext">falseName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#falseName"><span class="hs-identifier hs-var hs-var">falseName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">False</span><span>
</span><span id="line-1376"></span><span>
</span><span id="line-1377"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nothingName"><span class="hs-identifier hs-type">nothingName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#justName"><span class="hs-identifier hs-type">justName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1378"></span><span id="nothingName"><span class="annot"><span class="annottext">nothingName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#nothingName"><span class="hs-identifier hs-var hs-var">nothingName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-1379"></span><span id="justName"><span class="annot"><span class="annottext">justName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#justName"><span class="hs-identifier hs-var hs-var">justName</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Just</span><span>
</span><span id="line-1380"></span><span>
</span><span id="line-1381"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#leftName"><span class="hs-identifier hs-type">leftName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#rightName"><span class="hs-identifier hs-type">rightName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1382"></span><span id="leftName"><span class="annot"><span class="annottext">leftName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#leftName"><span class="hs-identifier hs-var hs-var">leftName</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Left</span><span>
</span><span id="line-1383"></span><span id="rightName"><span class="annot"><span class="annottext">rightName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#rightName"><span class="hs-identifier hs-var hs-var">rightName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Right</span><span>
</span><span id="line-1384"></span><span>
</span><span id="line-1385"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nonemptyName"><span class="hs-identifier hs-type">nonemptyName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1386"></span><span id="nonemptyName"><span class="annot"><span class="annottext">nonemptyName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#nonemptyName"><span class="hs-identifier hs-var hs-var">nonemptyName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-special">(</span><span class="hs-operator">:|</span><span class="hs-special">)</span><span>
</span><span id="line-1387"></span><span>
</span><span id="line-1388"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#oneName"><span class="hs-identifier hs-type">oneName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#manyName"><span class="hs-identifier hs-type">manyName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1389"></span><span id="oneName"><span class="annot"><span class="annottext">oneName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#oneName"><span class="hs-identifier hs-var hs-var">oneName</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">One</span><span>
</span><span id="line-1390"></span><span id="manyName"><span class="annot"><span class="annottext">manyName :: Name
</span><a href="Language.Haskell.TH.Syntax.html#manyName"><span class="hs-identifier hs-var hs-var">manyName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Many</span><span>
</span><span id="line-1391"></span><span>
</span><span id="line-1392"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1393"></span><span class="hs-comment">--</span><span>
</span><span id="line-1394"></span><span class="hs-comment">--              Generic Lift implementations</span><span>
</span><span id="line-1395"></span><span class="hs-comment">--</span><span>
</span><span id="line-1396"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1397"></span><span>
</span><span id="line-1398"></span><span class="hs-comment">-- | 'dataToQa' is an internal utility function for constructing generic</span><span>
</span><span id="line-1399"></span><span class="hs-comment">-- conversion functions from types with 'Data' instances to various</span><span>
</span><span id="line-1400"></span><span class="hs-comment">-- quasi-quoting representations.  See the source of 'dataToExpQ' and</span><span>
</span><span id="line-1401"></span><span class="hs-comment">-- 'dataToPatQ' for two example usages: @mkCon@, @mkLit@</span><span>
</span><span id="line-1402"></span><span class="hs-comment">-- and @appQ@ are overloadable to account for different syntax for</span><span>
</span><span id="line-1403"></span><span class="hs-comment">-- expressions and patterns; @antiQ@ allows you to override type-specific</span><span>
</span><span id="line-1404"></span><span class="hs-comment">-- cases, a common usage is just @const Nothing@, which results in</span><span>
</span><span id="line-1405"></span><span class="hs-comment">-- no overloading.</span><span>
</span><span id="line-1406"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#dataToQa"><span class="hs-identifier hs-type">dataToQa</span></a></span><span>  </span><span class="hs-glyph">::</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193868"><span class="annot"><a href="#local-6989586621679193868"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679193869"><span class="annot"><a href="#local-6989586621679193869"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679193870"><span class="annot"><a href="#local-6989586621679193870"><span class="hs-identifier hs-type">k</span></a></span></span><span> </span><span id="local-6989586621679193871"><span class="annot"><a href="#local-6989586621679193871"><span class="hs-identifier hs-type">q</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193868"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193869"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1407"></span><span>          </span><span class="hs-glyph">=&gt;</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193870"><span class="hs-identifier hs-type">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1408"></span><span>          </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193871"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1409"></span><span>          </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193870"><span class="hs-identifier hs-type">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679193868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193871"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193871"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1410"></span><span>          </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193872"><span class="annot"><a href="#local-6989586621679193872"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193872"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193872"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193871"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1411"></span><span>          </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="annot"><a href="#local-6989586621679193869"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-1412"></span><span>          </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="annot"><a href="#local-6989586621679193868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193871"><span class="hs-identifier hs-type">q</span></a></span><span>
</span><span id="line-1413"></span><span id="dataToQa"><span class="annot"><span class="annottext">dataToQa :: forall (m :: * -&gt; *) a k q.
(Quote m, Data a) =&gt;
(Name -&gt; k)
-&gt; (Lit -&gt; m q)
-&gt; (k -&gt; [m q] -&gt; m q)
-&gt; (forall b. Data b =&gt; b -&gt; Maybe (m q))
-&gt; a
-&gt; m q
</span><a href="Language.Haskell.TH.Syntax.html#dataToQa"><span class="hs-identifier hs-var hs-var">dataToQa</span></a></span></span><span> </span><span id="local-6989586621679198033"><span class="annot"><span class="annottext">Name -&gt; k
</span><a href="#local-6989586621679198033"><span class="hs-identifier hs-var">mkCon</span></a></span></span><span> </span><span id="local-6989586621679198034"><span class="annot"><span class="annottext">Lit -&gt; m q
</span><a href="#local-6989586621679198034"><span class="hs-identifier hs-var">mkLit</span></a></span></span><span> </span><span id="local-6989586621679198035"><span class="annot"><span class="annottext">k -&gt; [m q] -&gt; m q
</span><a href="#local-6989586621679198035"><span class="hs-identifier hs-var">appCon</span></a></span></span><span> </span><span id="local-6989586621679198036"><span class="annot"><span class="annottext">forall b. Data b =&gt; b -&gt; Maybe (m q)
</span><a href="#local-6989586621679198036"><span class="hs-identifier hs-var">antiQ</span></a></span></span><span> </span><span id="local-6989586621679198037"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679198037"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1414"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe (m q)
forall b. Data b =&gt; b -&gt; Maybe (m q)
</span><a href="#local-6989586621679198036"><span class="hs-identifier hs-var">antiQ</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679198037"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1415"></span><span>      </span><span class="annot"><span class="annottext">Maybe (m q)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1416"></span><span>          </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Constr -&gt; ConstrRep
</span><span class="hs-identifier hs-var">constrRep</span></span><span> </span><span class="annot"><span class="annottext">Constr
</span><a href="#local-6989586621679198039"><span class="hs-identifier hs-var">constr</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1417"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">AlgConstr</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1418"></span><span>                </span><span class="annot"><span class="annottext">k -&gt; [m q] -&gt; m q
</span><a href="#local-6989586621679198035"><span class="hs-identifier hs-var">appCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; k
</span><a href="#local-6989586621679198033"><span class="hs-identifier hs-var">mkCon</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198041"><span class="hs-identifier hs-var">funOrConName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[m q]
</span><a href="#local-6989586621679198042"><span class="hs-identifier hs-var">conArgs</span></a></span><span>
</span><span id="line-1419"></span><span>              </span><span class="hs-keyword">where</span><span>
</span><span id="line-1420"></span><span>                </span><span class="annot"><a href="#local-6989586621679198041"><span class="hs-identifier hs-type">funOrConName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1421"></span><span>                </span><span id="local-6989586621679198041"><span class="annot"><span class="annottext">funOrConName :: Name
</span><a href="#local-6989586621679198041"><span class="hs-identifier hs-var hs-var">funOrConName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1422"></span><span>                    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Constr -&gt; FilePath
</span><span class="hs-identifier hs-var">showConstr</span></span><span> </span><span class="annot"><span class="annottext">Constr
</span><a href="#local-6989586621679198039"><span class="hs-identifier hs-var">constr</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1423"></span><span>                      </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;(:)&quot;</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;:&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1424"></span><span>                                          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSpace -&gt; PkgName -&gt; ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-var">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span>
</span><span id="line-1425"></span><span>                                                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-var">mkPkgName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;ghc-prim&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1426"></span><span>                                                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;GHC.Types&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1427"></span><span>                      </span><span id="local-6989586621679198048"><span class="annot"><span class="annottext">con :: FilePath
</span><a href="#local-6989586621679198048"><span class="hs-identifier hs-var">con</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;[]&quot;</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198048"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1428"></span><span>                                          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSpace -&gt; PkgName -&gt; ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-var">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span>
</span><span id="line-1429"></span><span>                                                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-var">mkPkgName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;ghc-prim&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1430"></span><span>                                                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;GHC.Types&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1431"></span><span>                      </span><span id="local-6989586621679198049"><span class="annot"><span class="annottext">con :: FilePath
</span><a href="#local-6989586621679198049"><span class="hs-identifier hs-var">con</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'('</span></span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-type">:</span></a></span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198049"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1432"></span><span>                                          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSpace -&gt; PkgName -&gt; ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-var">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span>
</span><span id="line-1433"></span><span>                                                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-var">mkPkgName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;ghc-prim&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1434"></span><span>                                                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;GHC.Tuple&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1435"></span><span>
</span><span id="line-1436"></span><span>                      </span><span class="hs-comment">-- Tricky case: see Note [Data for non-algebraic types]</span><span>
</span><span id="line-1437"></span><span>                      </span><span id="local-6989586621679198050"><span class="annot"><span class="annottext">fun :: FilePath
</span><a href="#local-6989586621679198050"><span class="hs-identifier hs-var">fun</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621679198051"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679198051"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-type">:</span></a></span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.Lexeme.html#startsVarSym"><span class="hs-identifier hs-var">startsVarSym</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679198051"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%7C%7C"><span class="hs-operator hs-var">||</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><a href="../../ghc-boot-th-9.10.2-inplace/src/GHC.Lexeme.html#startsVarId"><span class="hs-identifier hs-var">startsVarId</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679198051"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1438"></span><span>                                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG_v"><span class="hs-identifier hs-var">mkNameG_v</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198053"><span class="hs-identifier hs-var">tyconPkg</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198054"><span class="hs-identifier hs-var">tyconMod</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198050"><span class="hs-identifier hs-var">fun</span></a></span><span>
</span><span id="line-1439"></span><span>                      </span><span id="local-6989586621679198055"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198055"><span class="hs-identifier hs-var">con</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG_d"><span class="hs-identifier hs-var">mkNameG_d</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198053"><span class="hs-identifier hs-var">tyconPkg</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198054"><span class="hs-identifier hs-var">tyconMod</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198055"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-1440"></span><span>
</span><span id="line-1441"></span><span>                  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1442"></span><span>                    </span><span class="annot"><a href="#local-6989586621679198056"><span class="hs-identifier hs-type">tycon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#TyCon"><span class="hs-identifier hs-type">TyCon</span></a></span><span>
</span><span id="line-1443"></span><span>                    </span><span id="local-6989586621679198056"><span class="annot"><span class="annottext">tycon :: TyCon
</span><a href="#local-6989586621679198056"><span class="hs-identifier hs-var hs-var">tycon</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypeRep -&gt; TyCon
</span><span class="hs-identifier hs-var">typeRepTyCon</span></span><span> </span><span class="annot"><span class="annottext">(TypeRep -&gt; TyCon) -&gt; (a -&gt; TypeRep) -&gt; a -&gt; TyCon
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; TypeRep
forall a. Typeable a =&gt; a -&gt; TypeRep
</span><span class="hs-identifier hs-var">typeOf</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679198037"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1444"></span><span>
</span><span id="line-1445"></span><span>                    </span><span class="annot"><a href="#local-6989586621679198053"><span class="hs-identifier hs-type">tyconPkg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679198054"><span class="hs-identifier hs-type">tyconMod</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1446"></span><span>                    </span><span id="local-6989586621679198053"><span class="annot"><span class="annottext">tyconPkg :: FilePath
</span><a href="#local-6989586621679198053"><span class="hs-identifier hs-var hs-var">tyconPkg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; FilePath
</span><span class="hs-identifier hs-var">tyConPackage</span></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679198056"><span class="hs-identifier hs-var">tycon</span></a></span><span>
</span><span id="line-1447"></span><span>                    </span><span id="local-6989586621679198054"><span class="annot"><span class="annottext">tyconMod :: FilePath
</span><a href="#local-6989586621679198054"><span class="hs-identifier hs-var hs-var">tyconMod</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; FilePath
</span><span class="hs-identifier hs-var">tyConModule</span></span><span>  </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621679198056"><span class="hs-identifier hs-var">tycon</span></a></span><span>
</span><span id="line-1448"></span><span>
</span><span id="line-1449"></span><span>                </span><span class="annot"><a href="#local-6989586621679198042"><span class="hs-identifier hs-type">conArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679193868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193871"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1450"></span><span>                </span><span id="local-6989586621679198042"><span class="annot"><span class="annottext">conArgs :: [m q]
</span><a href="#local-6989586621679198042"><span class="hs-identifier hs-var hs-var">conArgs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall d. Data d =&gt; d -&gt; m q) -&gt; a -&gt; [m q]
forall a u. Data a =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u]
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u]
</span><span class="hs-identifier hs-var">gmapQ</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; k)
-&gt; (Lit -&gt; m q)
-&gt; (k -&gt; [m q] -&gt; m q)
-&gt; (forall b. Data b =&gt; b -&gt; Maybe (m q))
-&gt; d
-&gt; m q
forall (m :: * -&gt; *) a k q.
(Quote m, Data a) =&gt;
(Name -&gt; k)
-&gt; (Lit -&gt; m q)
-&gt; (k -&gt; [m q] -&gt; m q)
-&gt; (forall b. Data b =&gt; b -&gt; Maybe (m q))
-&gt; a
-&gt; m q
</span><a href="Language.Haskell.TH.Syntax.html#dataToQa"><span class="hs-identifier hs-var">dataToQa</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; k
</span><a href="#local-6989586621679198033"><span class="hs-identifier hs-var">mkCon</span></a></span><span> </span><span class="annot"><span class="annottext">Lit -&gt; m q
</span><a href="#local-6989586621679198034"><span class="hs-identifier hs-var">mkLit</span></a></span><span> </span><span class="annot"><span class="annottext">k -&gt; [m q] -&gt; m q
</span><a href="#local-6989586621679198035"><span class="hs-identifier hs-var">appCon</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; Maybe (m q)
forall b. Data b =&gt; b -&gt; Maybe (m q)
</span><a href="#local-6989586621679198036"><span class="hs-identifier hs-var">antiQ</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679198037"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1451"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">IntConstr</span></span><span> </span><span id="local-6989586621679198068"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679198068"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1452"></span><span>                </span><span class="annot"><span class="annottext">Lit -&gt; m q
</span><a href="#local-6989586621679198034"><span class="hs-identifier hs-var">mkLit</span></a></span><span> </span><span class="annot"><span class="annottext">(Lit -&gt; m q) -&gt; Lit -&gt; m q
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Uniq -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679198068"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1453"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">FloatConstr</span></span><span> </span><span id="local-6989586621679198070"><span class="annot"><span class="annottext">Rational
</span><a href="#local-6989586621679198070"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1454"></span><span>                </span><span class="annot"><span class="annottext">Lit -&gt; m q
</span><a href="#local-6989586621679198034"><span class="hs-identifier hs-var">mkLit</span></a></span><span> </span><span class="annot"><span class="annottext">(Lit -&gt; m q) -&gt; Lit -&gt; m q
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Rational -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#RationalL"><span class="hs-identifier hs-var">RationalL</span></a></span><span> </span><span class="annot"><span class="annottext">Rational
</span><a href="#local-6989586621679198070"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1455"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">CharConstr</span></span><span> </span><span id="local-6989586621679198072"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679198072"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1456"></span><span>                </span><span class="annot"><span class="annottext">Lit -&gt; m q
</span><a href="#local-6989586621679198034"><span class="hs-identifier hs-var">mkLit</span></a></span><span> </span><span class="annot"><span class="annottext">(Lit -&gt; m q) -&gt; Lit -&gt; m q
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Lit
</span><a href="Language.Haskell.TH.Syntax.html#CharL"><span class="hs-identifier hs-var">CharL</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679198072"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1457"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-1458"></span><span>          </span><span class="annot"><a href="#local-6989586621679198039"><span class="hs-identifier hs-type">constr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Constr</span></span><span>
</span><span id="line-1459"></span><span>          </span><span id="local-6989586621679198039"><span class="annot"><span class="annottext">constr :: Constr
</span><a href="#local-6989586621679198039"><span class="hs-identifier hs-var hs-var">constr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Constr
forall a. Data a =&gt; a -&gt; Constr
</span><span class="hs-identifier hs-var">toConstr</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679198037"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1460"></span><span>
</span><span id="line-1461"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679198074"><span class="annot"><span class="annottext">m q
</span><a href="#local-6989586621679198074"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m q
</span><a href="#local-6989586621679198074"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-1462"></span><span>
</span><span id="line-1463"></span><span>
</span><span id="line-1464"></span><span class="hs-comment">{- Note [Data for non-algebraic types]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Class Data was originally intended for algebraic data types.  But
it is possible to use it for abstract types too.  For example, in
package `text` we find

  instance Data Text where
    ...
    toConstr _ = packConstr

  packConstr :: Constr
  packConstr = mkConstr textDataType &quot;pack&quot; [] Prefix

Here `packConstr` isn't a real data constructor, it's an ordinary
function.  Two complications

* In such a case, we must take care to build the Name using
  mkNameG_v (for values), not mkNameG_d (for data constructors).
  See #10796.

* The pseudo-constructor is named only by its string, here &quot;pack&quot;.
  But 'dataToQa' needs the TyCon of its defining module, and has
  to assume it's defined in the same module as the TyCon itself.
  But nothing enforces that; #12596 shows what goes wrong if
  &quot;pack&quot; is defined in a different module than the data type &quot;Text&quot;.
  -}</span><span>
</span><span id="line-1490"></span><span>
</span><span id="line-1491"></span><span class="hs-comment">-- | 'dataToExpQ' converts a value to a 'Exp' representation of the</span><span>
</span><span id="line-1492"></span><span class="hs-comment">-- same value, in the SYB style. It is generalized to take a function</span><span>
</span><span id="line-1493"></span><span class="hs-comment">-- override type-specific cases; see 'liftData' for a more commonly</span><span>
</span><span id="line-1494"></span><span class="hs-comment">-- used variant.</span><span>
</span><span id="line-1495"></span><span id="local-6989586621679193888"><span id="local-6989586621679193889"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#dataToExpQ"><span class="hs-identifier hs-type">dataToExpQ</span></a></span><span>  </span><span class="hs-glyph">::</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193888"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193889"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1496"></span><span>            </span><span class="hs-glyph">=&gt;</span><span>  </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193890"><span class="annot"><a href="#local-6989586621679193890"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193890"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193890"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193888"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1497"></span><span>            </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="annot"><a href="#local-6989586621679193889"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-1498"></span><span>            </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="annot"><a href="#local-6989586621679193888"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span></span></span><span>
</span><span id="line-1499"></span><span id="dataToExpQ"><span class="annot"><span class="annottext">dataToExpQ :: forall (m :: * -&gt; *) a.
(Quote m, Data a) =&gt;
(forall b. Data b =&gt; b -&gt; Maybe (m Exp)) -&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#dataToExpQ"><span class="hs-identifier hs-var hs-var">dataToExpQ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; m Exp)
-&gt; (Lit -&gt; m Exp)
-&gt; (m Exp -&gt; [m Exp] -&gt; m Exp)
-&gt; (forall b. Data b =&gt; b -&gt; Maybe (m Exp))
-&gt; a
-&gt; m Exp
forall (m :: * -&gt; *) a k q.
(Quote m, Data a) =&gt;
(Name -&gt; k)
-&gt; (Lit -&gt; m q)
-&gt; (k -&gt; [m q] -&gt; m q)
-&gt; (forall b. Data b =&gt; b -&gt; Maybe (m q))
-&gt; a
-&gt; m q
</span><a href="Language.Haskell.TH.Syntax.html#dataToQa"><span class="hs-identifier hs-var">dataToQa</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; m Exp
forall {m :: * -&gt; *}. Monad m =&gt; Name -&gt; m Exp
</span><a href="#local-6989586621679198087"><span class="hs-identifier hs-var">varOrConE</span></a></span><span> </span><span class="annot"><span class="annottext">Lit -&gt; m Exp
forall {m :: * -&gt; *}. Monad m =&gt; Lit -&gt; m Exp
</span><a href="#local-6989586621679198088"><span class="hs-identifier hs-var">litE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(m Exp -&gt; m Exp -&gt; m Exp) -&gt; m Exp -&gt; [m Exp] -&gt; m Exp
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; m Exp -&gt; m Exp
forall {m :: * -&gt; *}. Monad m =&gt; m Exp -&gt; m Exp -&gt; m Exp
</span><a href="#local-6989586621679198090"><span class="hs-identifier hs-var">appE</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1500"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-1501"></span><span>          </span><span class="hs-comment">-- Make sure that VarE is used if the Constr value relies on a</span><span>
</span><span id="line-1502"></span><span>          </span><span class="hs-comment">-- function underneath the surface (instead of a constructor).</span><span>
</span><span id="line-1503"></span><span>          </span><span class="hs-comment">-- See #10796.</span><span>
</span><span id="line-1504"></span><span>          </span><span id="local-6989586621679198087"><span class="annot"><span class="annottext">varOrConE :: Name -&gt; m Exp
</span><a href="#local-6989586621679198087"><span class="hs-identifier hs-var hs-var">varOrConE</span></a></span></span><span> </span><span id="local-6989586621679198101"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198101"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1505"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#nameSpace"><span class="hs-identifier hs-var">nameSpace</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198101"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1506"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#VarName"><span class="hs-identifier hs-var">VarName</span></a></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#VarE"><span class="hs-identifier hs-var">VarE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198101"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1507"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FldName"><span class="hs-identifier hs-type">FldName</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#VarE"><span class="hs-identifier hs-var">VarE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198101"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1508"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198101"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1509"></span><span>                 </span><span class="annot"><span class="annottext">Maybe NameSpace
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; m Exp
forall a. HasCallStack =&gt; FilePath -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; m Exp) -&gt; FilePath -&gt; m Exp
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Can't construct an expression from name &quot;</span></span><span>
</span><span id="line-1510"></span><span>                           </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#showName"><span class="hs-identifier hs-var">showName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198101"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1511"></span><span>          </span><span id="local-6989586621679198090"><span class="annot"><span class="annottext">appE :: m Exp -&gt; m Exp -&gt; m Exp
</span><a href="#local-6989586621679198090"><span class="hs-identifier hs-var hs-var">appE</span></a></span></span><span> </span><span id="local-6989586621679198115"><span class="annot"><span class="annottext">m Exp
</span><a href="#local-6989586621679198115"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679198116"><span class="annot"><span class="annottext">m Exp
</span><a href="#local-6989586621679198116"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span id="local-6989586621679198117"><span class="annot"><a href="#local-6989586621679198117"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Exp
</span><a href="#local-6989586621679198115"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">;</span><span> </span><span id="local-6989586621679198118"><span class="annot"><a href="#local-6989586621679198118"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="#local-6989586621679198116"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AppE"><span class="hs-identifier hs-type">AppE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679198117"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679198118"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">}</span><span>
</span><span id="line-1512"></span><span>          </span><span id="local-6989586621679198088"><span class="annot"><span class="annottext">litE :: Lit -&gt; m Exp
</span><a href="#local-6989586621679198088"><span class="hs-identifier hs-var hs-var">litE</span></a></span></span><span> </span><span id="local-6989586621679198125"><span class="annot"><span class="annottext">Lit
</span><a href="#local-6989586621679198125"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; m Exp
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Exp
</span><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span><span> </span><span class="annot"><span class="annottext">Lit
</span><a href="#local-6989586621679198125"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1513"></span><span>
</span><span id="line-1514"></span><span class="hs-comment">-- | 'liftData' is a variant of 'lift' in the 'Lift' type class which</span><span>
</span><span id="line-1515"></span><span class="hs-comment">-- works for any type with a 'Data' instance.</span><span>
</span><span id="line-1516"></span><span id="local-6989586621679193901"><span id="local-6989586621679193902"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#liftData"><span class="hs-identifier hs-type">liftData</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193901"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193902"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193902"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193901"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span></span></span><span>
</span><span id="line-1517"></span><span id="liftData"><span class="annot"><span class="annottext">liftData :: forall (m :: * -&gt; *) a. (Quote m, Data a) =&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#liftData"><span class="hs-identifier hs-var hs-var">liftData</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall b. Data b =&gt; b -&gt; Maybe (m Exp)) -&gt; a -&gt; m Exp
forall (m :: * -&gt; *) a.
(Quote m, Data a) =&gt;
(forall b. Data b =&gt; b -&gt; Maybe (m Exp)) -&gt; a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.html#dataToExpQ"><span class="hs-identifier hs-var">dataToExpQ</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (m Exp) -&gt; b -&gt; Maybe (m Exp)
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">Maybe (m Exp)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-1518"></span><span>
</span><span id="line-1519"></span><span class="hs-comment">-- | 'dataToPatQ' converts a value to a 'Pat' representation of the same</span><span>
</span><span id="line-1520"></span><span class="hs-comment">-- value, in the SYB style. It takes a function to handle type-specific cases,</span><span>
</span><span id="line-1521"></span><span class="hs-comment">-- alternatively, pass @const Nothing@ to get default behavior.</span><span>
</span><span id="line-1522"></span><span id="local-6989586621679193908"><span id="local-6989586621679193909"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#dataToPatQ"><span class="hs-identifier hs-type">dataToPatQ</span></a></span><span>  </span><span class="hs-glyph">::</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Quote"><span class="hs-identifier hs-type">Quote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679193908"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193909"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1523"></span><span>            </span><span class="hs-glyph">=&gt;</span><span>  </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679193910"><span class="annot"><a href="#local-6989586621679193910"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679193910"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679193910"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679193908"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1524"></span><span>            </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="annot"><a href="#local-6989586621679193909"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-1525"></span><span>            </span><span class="hs-glyph">-&gt;</span><span>  </span><span class="annot"><a href="#local-6989586621679193908"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span></span></span><span>
</span><span id="line-1526"></span><span id="dataToPatQ"><span class="annot"><span class="annottext">dataToPatQ :: forall (m :: * -&gt; *) a.
(Quote m, Data a) =&gt;
(forall b. Data b =&gt; b -&gt; Maybe (m Pat)) -&gt; a -&gt; m Pat
</span><a href="Language.Haskell.TH.Syntax.html#dataToPatQ"><span class="hs-identifier hs-var hs-var">dataToPatQ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Name)
-&gt; (Lit -&gt; m Pat)
-&gt; (Name -&gt; [m Pat] -&gt; m Pat)
-&gt; (forall b. Data b =&gt; b -&gt; Maybe (m Pat))
-&gt; a
-&gt; m Pat
forall (m :: * -&gt; *) a k q.
(Quote m, Data a) =&gt;
(Name -&gt; k)
-&gt; (Lit -&gt; m q)
-&gt; (k -&gt; [m q] -&gt; m q)
-&gt; (forall b. Data b =&gt; b -&gt; Maybe (m q))
-&gt; a
-&gt; m q
</span><a href="Language.Haskell.TH.Syntax.html#dataToQa"><span class="hs-identifier hs-var">dataToQa</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span> </span><span class="annot"><span class="annottext">Lit -&gt; m Pat
forall {m :: * -&gt; *}. Monad m =&gt; Lit -&gt; m Pat
</span><a href="#local-6989586621679198141"><span class="hs-identifier hs-var">litP</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [m Pat] -&gt; m Pat
forall {m :: * -&gt; *}. Monad m =&gt; Name -&gt; [m Pat] -&gt; m Pat
</span><a href="#local-6989586621679198142"><span class="hs-identifier hs-var">conP</span></a></span><span>
</span><span id="line-1527"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679198141"><span class="annot"><span class="annottext">litP :: Lit -&gt; m Pat
</span><a href="#local-6989586621679198141"><span class="hs-identifier hs-var hs-var">litP</span></a></span></span><span> </span><span id="local-6989586621679198149"><span class="annot"><span class="annottext">Lit
</span><a href="#local-6989586621679198149"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; m Pat
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Lit -&gt; Pat
</span><a href="Language.Haskell.TH.Syntax.html#LitP"><span class="hs-identifier hs-var">LitP</span></a></span><span> </span><span class="annot"><span class="annottext">Lit
</span><a href="#local-6989586621679198149"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1528"></span><span>          </span><span id="local-6989586621679198142"><span class="annot"><span class="annottext">conP :: Name -&gt; [m Pat] -&gt; m Pat
</span><a href="#local-6989586621679198142"><span class="hs-identifier hs-var hs-var">conP</span></a></span></span><span> </span><span id="local-6989586621679198162"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198162"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679198163"><span class="annot"><span class="annottext">[m Pat]
</span><a href="#local-6989586621679198163"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1529"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#nameSpace"><span class="hs-identifier hs-var">nameSpace</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198162"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1530"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1531"></span><span>                    </span><span id="local-6989586621679198164"><span class="annot"><a href="#local-6989586621679198164"><span class="hs-identifier hs-var">ps'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[m Pat] -&gt; m [Pat]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
forall (m :: * -&gt; *) a. Monad m =&gt; [m a] -&gt; m [a]
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">[m Pat]
</span><a href="#local-6989586621679198163"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1532"></span><span>                    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679198162"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><a href="#local-6989586621679198164"><span class="hs-identifier hs-type">ps'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1533"></span><span>                </span><span class="annot"><span class="annottext">Maybe NameSpace
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; m Pat
forall a. HasCallStack =&gt; FilePath -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; m Pat) -&gt; FilePath -&gt; m Pat
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Can't construct a pattern from name &quot;</span></span><span>
</span><span id="line-1534"></span><span>                          </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#showName"><span class="hs-identifier hs-var">showName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679198162"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1535"></span><span>
</span><span id="line-1536"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1537"></span><span class="hs-comment">--              Names and uniques</span><span>
</span><span id="line-1538"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1539"></span><span>
</span><span id="line-1540"></span><span class="hs-keyword">newtype</span><span> </span><span id="ModName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-var">ModName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ModName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-var">ModName</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>        </span><span class="hs-comment">-- Module name</span><span>
</span><span id="line-1541"></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679198168"><span id="local-6989586621679198174"><span id="local-6989586621679198178"><span class="annot"><span class="annottext">Int -&gt; ModName -&gt; FilePath -&gt; FilePath
[ModName] -&gt; FilePath -&gt; FilePath
ModName -&gt; FilePath
(Int -&gt; ModName -&gt; FilePath -&gt; FilePath)
-&gt; (ModName -&gt; FilePath)
-&gt; ([ModName] -&gt; FilePath -&gt; FilePath)
-&gt; Show ModName
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; ModName -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; ModName -&gt; FilePath -&gt; FilePath
$cshow :: ModName -&gt; FilePath
show :: ModName -&gt; FilePath
$cshowList :: [ModName] -&gt; FilePath -&gt; FilePath
showList :: [ModName] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198184"><span id="local-6989586621679198190"><span class="annot"><span class="annottext">ModName -&gt; ModName -&gt; Bool
(ModName -&gt; ModName -&gt; Bool)
-&gt; (ModName -&gt; ModName -&gt; Bool) -&gt; Eq ModName
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: ModName -&gt; ModName -&gt; Bool
== :: ModName -&gt; ModName -&gt; Bool
$c/= :: ModName -&gt; ModName -&gt; Bool
/= :: ModName -&gt; ModName -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198201"><span id="local-6989586621679198207"><span id="local-6989586621679198212"><span id="local-6989586621679198217"><span id="local-6989586621679198222"><span id="local-6989586621679198227"><span id="local-6989586621679198232"><span class="annot"><span class="annottext">Eq ModName
Eq ModName =&gt;
(ModName -&gt; ModName -&gt; Ordering)
-&gt; (ModName -&gt; ModName -&gt; Bool)
-&gt; (ModName -&gt; ModName -&gt; Bool)
-&gt; (ModName -&gt; ModName -&gt; Bool)
-&gt; (ModName -&gt; ModName -&gt; Bool)
-&gt; (ModName -&gt; ModName -&gt; ModName)
-&gt; (ModName -&gt; ModName -&gt; ModName)
-&gt; Ord ModName
ModName -&gt; ModName -&gt; Bool
ModName -&gt; ModName -&gt; Ordering
ModName -&gt; ModName -&gt; ModName
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: ModName -&gt; ModName -&gt; Ordering
compare :: ModName -&gt; ModName -&gt; Ordering
$c&lt; :: ModName -&gt; ModName -&gt; Bool
&lt; :: ModName -&gt; ModName -&gt; Bool
$c&lt;= :: ModName -&gt; ModName -&gt; Bool
&lt;= :: ModName -&gt; ModName -&gt; Bool
$c&gt; :: ModName -&gt; ModName -&gt; Bool
&gt; :: ModName -&gt; ModName -&gt; Bool
$c&gt;= :: ModName -&gt; ModName -&gt; Bool
&gt;= :: ModName -&gt; ModName -&gt; Bool
$cmax :: ModName -&gt; ModName -&gt; ModName
max :: ModName -&gt; ModName -&gt; ModName
$cmin :: ModName -&gt; ModName -&gt; ModName
min :: ModName -&gt; ModName -&gt; ModName
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198248"><span id="local-6989586621679198253"><span id="local-6989586621679198257"><span id="local-6989586621679198259"><span id="local-6989586621679198261"><span id="local-6989586621679198267"><span id="local-6989586621679198272"><span id="local-6989586621679198275"><span id="local-6989586621679198278"><span id="local-6989586621679198281"><span id="local-6989586621679198284"><span id="local-6989586621679198287"><span id="local-6989586621679198292"><span id="local-6989586621679198297"><span class="annot"><span class="annottext">Typeable ModName
Typeable ModName =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; ModName -&gt; c ModName)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ModName)
-&gt; (ModName -&gt; Constr)
-&gt; (ModName -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ModName))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c ModName))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; ModName -&gt; ModName)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModName -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModName -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModName -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModName -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName)
-&gt; Data ModName
ModName -&gt; Constr
ModName -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; ModName -&gt; ModName
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModName -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModName -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModName -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModName -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ModName
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModName -&gt; c ModName
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ModName)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c ModName)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModName -&gt; c ModName
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModName -&gt; c ModName
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ModName
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ModName
$ctoConstr :: ModName -&gt; Constr
toConstr :: ModName -&gt; Constr
$cdataTypeOf :: ModName -&gt; DataType
dataTypeOf :: ModName -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ModName)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ModName)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c ModName)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c ModName)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ModName -&gt; ModName
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ModName -&gt; ModName
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModName -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModName -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModName -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModName -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModName -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModName -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModName -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModName -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModName -&gt; m ModName
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198307"><span id="local-6989586621679198309"><span class="annot"><span class="annottext">(forall x. ModName -&gt; Rep ModName x)
-&gt; (forall x. Rep ModName x -&gt; ModName) -&gt; Generic ModName
forall x. Rep ModName x -&gt; ModName
forall x. ModName -&gt; Rep ModName x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. ModName -&gt; Rep ModName x
from :: forall x. ModName -&gt; Rep ModName x
$cto :: forall x. Rep ModName x -&gt; ModName
to :: forall x. Rep ModName x -&gt; ModName
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-1542"></span><span>
</span><span id="line-1543"></span><span class="hs-keyword">newtype</span><span> </span><span id="PkgName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PkgName"><span class="hs-identifier hs-var">PkgName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="PkgName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PkgName"><span class="hs-identifier hs-var">PkgName</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>        </span><span class="hs-comment">-- package name</span><span>
</span><span id="line-1544"></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679198316"><span id="local-6989586621679198321"><span id="local-6989586621679198325"><span class="annot"><span class="annottext">Int -&gt; PkgName -&gt; FilePath -&gt; FilePath
[PkgName] -&gt; FilePath -&gt; FilePath
PkgName -&gt; FilePath
(Int -&gt; PkgName -&gt; FilePath -&gt; FilePath)
-&gt; (PkgName -&gt; FilePath)
-&gt; ([PkgName] -&gt; FilePath -&gt; FilePath)
-&gt; Show PkgName
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; PkgName -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; PkgName -&gt; FilePath -&gt; FilePath
$cshow :: PkgName -&gt; FilePath
show :: PkgName -&gt; FilePath
$cshowList :: [PkgName] -&gt; FilePath -&gt; FilePath
showList :: [PkgName] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198328"><span id="local-6989586621679198333"><span class="annot"><span class="annottext">PkgName -&gt; PkgName -&gt; Bool
(PkgName -&gt; PkgName -&gt; Bool)
-&gt; (PkgName -&gt; PkgName -&gt; Bool) -&gt; Eq PkgName
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: PkgName -&gt; PkgName -&gt; Bool
== :: PkgName -&gt; PkgName -&gt; Bool
$c/= :: PkgName -&gt; PkgName -&gt; Bool
/= :: PkgName -&gt; PkgName -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198341"><span id="local-6989586621679198346"><span id="local-6989586621679198351"><span id="local-6989586621679198356"><span id="local-6989586621679198361"><span id="local-6989586621679198366"><span id="local-6989586621679198371"><span class="annot"><span class="annottext">Eq PkgName
Eq PkgName =&gt;
(PkgName -&gt; PkgName -&gt; Ordering)
-&gt; (PkgName -&gt; PkgName -&gt; Bool)
-&gt; (PkgName -&gt; PkgName -&gt; Bool)
-&gt; (PkgName -&gt; PkgName -&gt; Bool)
-&gt; (PkgName -&gt; PkgName -&gt; Bool)
-&gt; (PkgName -&gt; PkgName -&gt; PkgName)
-&gt; (PkgName -&gt; PkgName -&gt; PkgName)
-&gt; Ord PkgName
PkgName -&gt; PkgName -&gt; Bool
PkgName -&gt; PkgName -&gt; Ordering
PkgName -&gt; PkgName -&gt; PkgName
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: PkgName -&gt; PkgName -&gt; Ordering
compare :: PkgName -&gt; PkgName -&gt; Ordering
$c&lt; :: PkgName -&gt; PkgName -&gt; Bool
&lt; :: PkgName -&gt; PkgName -&gt; Bool
$c&lt;= :: PkgName -&gt; PkgName -&gt; Bool
&lt;= :: PkgName -&gt; PkgName -&gt; Bool
$c&gt; :: PkgName -&gt; PkgName -&gt; Bool
&gt; :: PkgName -&gt; PkgName -&gt; Bool
$c&gt;= :: PkgName -&gt; PkgName -&gt; Bool
&gt;= :: PkgName -&gt; PkgName -&gt; Bool
$cmax :: PkgName -&gt; PkgName -&gt; PkgName
max :: PkgName -&gt; PkgName -&gt; PkgName
$cmin :: PkgName -&gt; PkgName -&gt; PkgName
min :: PkgName -&gt; PkgName -&gt; PkgName
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198379"><span id="local-6989586621679198383"><span id="local-6989586621679198387"><span id="local-6989586621679198389"><span id="local-6989586621679198391"><span id="local-6989586621679198397"><span id="local-6989586621679198402"><span id="local-6989586621679198405"><span id="local-6989586621679198408"><span id="local-6989586621679198411"><span id="local-6989586621679198414"><span id="local-6989586621679198417"><span id="local-6989586621679198422"><span id="local-6989586621679198427"><span class="annot"><span class="annottext">Typeable PkgName
Typeable PkgName =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; PkgName -&gt; c PkgName)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PkgName)
-&gt; (PkgName -&gt; Constr)
-&gt; (PkgName -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PkgName))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PkgName))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; PkgName -&gt; PkgName)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PkgName -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PkgName -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PkgName -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PkgName -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName)
-&gt; Data PkgName
PkgName -&gt; Constr
PkgName -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; PkgName -&gt; PkgName
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PkgName -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PkgName -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PkgName -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PkgName -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PkgName
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PkgName -&gt; c PkgName
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PkgName)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PkgName)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PkgName -&gt; c PkgName
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PkgName -&gt; c PkgName
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PkgName
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PkgName
$ctoConstr :: PkgName -&gt; Constr
toConstr :: PkgName -&gt; Constr
$cdataTypeOf :: PkgName -&gt; DataType
dataTypeOf :: PkgName -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PkgName)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PkgName)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PkgName)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PkgName)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PkgName -&gt; PkgName
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PkgName -&gt; PkgName
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PkgName -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PkgName -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PkgName -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PkgName -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PkgName -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PkgName -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PkgName -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PkgName -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PkgName -&gt; m PkgName
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198432"><span id="local-6989586621679198434"><span class="annot"><span class="annottext">(forall x. PkgName -&gt; Rep PkgName x)
-&gt; (forall x. Rep PkgName x -&gt; PkgName) -&gt; Generic PkgName
forall x. Rep PkgName x -&gt; PkgName
forall x. PkgName -&gt; Rep PkgName x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. PkgName -&gt; Rep PkgName x
from :: forall x. PkgName -&gt; Rep PkgName x
$cto :: forall x. Rep PkgName x -&gt; PkgName
to :: forall x. Rep PkgName x -&gt; PkgName
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-1545"></span><span>
</span><span id="line-1546"></span><span class="annot"><span class="hs-comment">-- | Obtained from 'reifyModule' and 'Language.Haskell.TH.Lib.thisModule'.</span></span><span>
</span><span id="line-1547"></span><span class="hs-keyword">data</span><span> </span><span id="Module"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Module"><span class="hs-identifier hs-var">Module</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Module"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Module"><span class="hs-identifier hs-var">Module</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PkgName"><span class="hs-identifier hs-type">PkgName</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-type">ModName</span></a></span><span> </span><span class="hs-comment">-- package qualified module name</span><span>
</span><span id="line-1548"></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679198438"><span id="local-6989586621679198443"><span id="local-6989586621679198447"><span class="annot"><span class="annottext">Int -&gt; Module -&gt; FilePath -&gt; FilePath
[Module] -&gt; FilePath -&gt; FilePath
Module -&gt; FilePath
(Int -&gt; Module -&gt; FilePath -&gt; FilePath)
-&gt; (Module -&gt; FilePath)
-&gt; ([Module] -&gt; FilePath -&gt; FilePath)
-&gt; Show Module
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Module -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Module -&gt; FilePath -&gt; FilePath
$cshow :: Module -&gt; FilePath
show :: Module -&gt; FilePath
$cshowList :: [Module] -&gt; FilePath -&gt; FilePath
showList :: [Module] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198450"><span id="local-6989586621679198454"><span class="annot"><span class="annottext">Module -&gt; Module -&gt; Bool
(Module -&gt; Module -&gt; Bool)
-&gt; (Module -&gt; Module -&gt; Bool) -&gt; Eq Module
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Module -&gt; Module -&gt; Bool
== :: Module -&gt; Module -&gt; Bool
$c/= :: Module -&gt; Module -&gt; Bool
/= :: Module -&gt; Module -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198460"><span id="local-6989586621679198464"><span id="local-6989586621679198468"><span id="local-6989586621679198472"><span id="local-6989586621679198475"><span id="local-6989586621679198478"><span id="local-6989586621679198481"><span class="annot"><span class="annottext">Eq Module
Eq Module =&gt;
(Module -&gt; Module -&gt; Ordering)
-&gt; (Module -&gt; Module -&gt; Bool)
-&gt; (Module -&gt; Module -&gt; Bool)
-&gt; (Module -&gt; Module -&gt; Bool)
-&gt; (Module -&gt; Module -&gt; Bool)
-&gt; (Module -&gt; Module -&gt; Module)
-&gt; (Module -&gt; Module -&gt; Module)
-&gt; Ord Module
Module -&gt; Module -&gt; Bool
Module -&gt; Module -&gt; Ordering
Module -&gt; Module -&gt; Module
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Module -&gt; Module -&gt; Ordering
compare :: Module -&gt; Module -&gt; Ordering
$c&lt; :: Module -&gt; Module -&gt; Bool
&lt; :: Module -&gt; Module -&gt; Bool
$c&lt;= :: Module -&gt; Module -&gt; Bool
&lt;= :: Module -&gt; Module -&gt; Bool
$c&gt; :: Module -&gt; Module -&gt; Bool
&gt; :: Module -&gt; Module -&gt; Bool
$c&gt;= :: Module -&gt; Module -&gt; Bool
&gt;= :: Module -&gt; Module -&gt; Bool
$cmax :: Module -&gt; Module -&gt; Module
max :: Module -&gt; Module -&gt; Module
$cmin :: Module -&gt; Module -&gt; Module
min :: Module -&gt; Module -&gt; Module
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198486"><span id="local-6989586621679198490"><span id="local-6989586621679198494"><span id="local-6989586621679198496"><span id="local-6989586621679198498"><span id="local-6989586621679198504"><span id="local-6989586621679198509"><span id="local-6989586621679198512"><span id="local-6989586621679198515"><span id="local-6989586621679198518"><span id="local-6989586621679198521"><span id="local-6989586621679198524"><span id="local-6989586621679198529"><span id="local-6989586621679198534"><span class="annot"><span class="annottext">Typeable Module
Typeable Module =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Module -&gt; c Module)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Module)
-&gt; (Module -&gt; Constr)
-&gt; (Module -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Module))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Module))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Module -&gt; Module)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Module -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Module -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module)
-&gt; Data Module
Module -&gt; Constr
Module -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Module -&gt; Module
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Module -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Module -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Module
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Module -&gt; c Module
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Module)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Module)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Module -&gt; c Module
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Module -&gt; c Module
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Module
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Module
$ctoConstr :: Module -&gt; Constr
toConstr :: Module -&gt; Constr
$cdataTypeOf :: Module -&gt; DataType
dataTypeOf :: Module -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Module)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Module)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Module)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Module)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Module -&gt; Module
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Module -&gt; Module
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Module -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Module -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Module -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Module -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module -&gt; m Module
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198539"><span id="local-6989586621679198541"><span class="annot"><span class="annottext">(forall x. Module -&gt; Rep Module x)
-&gt; (forall x. Rep Module x -&gt; Module) -&gt; Generic Module
forall x. Rep Module x -&gt; Module
forall x. Module -&gt; Rep Module x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Module -&gt; Rep Module x
from :: forall x. Module -&gt; Rep Module x
$cto :: forall x. Rep Module x -&gt; Module
to :: forall x. Rep Module x -&gt; Module
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-1549"></span><span>
</span><span id="line-1550"></span><span class="hs-keyword">newtype</span><span> </span><span id="OccName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#OccName"><span class="hs-identifier hs-var">OccName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="OccName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#OccName"><span class="hs-identifier hs-var">OccName</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1551"></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679198545"><span id="local-6989586621679198550"><span id="local-6989586621679198554"><span class="annot"><span class="annottext">Int -&gt; OccName -&gt; FilePath -&gt; FilePath
[OccName] -&gt; FilePath -&gt; FilePath
OccName -&gt; FilePath
(Int -&gt; OccName -&gt; FilePath -&gt; FilePath)
-&gt; (OccName -&gt; FilePath)
-&gt; ([OccName] -&gt; FilePath -&gt; FilePath)
-&gt; Show OccName
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; OccName -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; OccName -&gt; FilePath -&gt; FilePath
$cshow :: OccName -&gt; FilePath
show :: OccName -&gt; FilePath
$cshowList :: [OccName] -&gt; FilePath -&gt; FilePath
showList :: [OccName] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198557"><span id="local-6989586621679198562"><span class="annot"><span class="annottext">OccName -&gt; OccName -&gt; Bool
(OccName -&gt; OccName -&gt; Bool)
-&gt; (OccName -&gt; OccName -&gt; Bool) -&gt; Eq OccName
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: OccName -&gt; OccName -&gt; Bool
== :: OccName -&gt; OccName -&gt; Bool
$c/= :: OccName -&gt; OccName -&gt; Bool
/= :: OccName -&gt; OccName -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198570"><span id="local-6989586621679198575"><span id="local-6989586621679198580"><span id="local-6989586621679198585"><span id="local-6989586621679198590"><span id="local-6989586621679198595"><span id="local-6989586621679198600"><span class="annot"><span class="annottext">Eq OccName
Eq OccName =&gt;
(OccName -&gt; OccName -&gt; Ordering)
-&gt; (OccName -&gt; OccName -&gt; Bool)
-&gt; (OccName -&gt; OccName -&gt; Bool)
-&gt; (OccName -&gt; OccName -&gt; Bool)
-&gt; (OccName -&gt; OccName -&gt; Bool)
-&gt; (OccName -&gt; OccName -&gt; OccName)
-&gt; (OccName -&gt; OccName -&gt; OccName)
-&gt; Ord OccName
OccName -&gt; OccName -&gt; Bool
OccName -&gt; OccName -&gt; Ordering
OccName -&gt; OccName -&gt; OccName
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: OccName -&gt; OccName -&gt; Ordering
compare :: OccName -&gt; OccName -&gt; Ordering
$c&lt; :: OccName -&gt; OccName -&gt; Bool
&lt; :: OccName -&gt; OccName -&gt; Bool
$c&lt;= :: OccName -&gt; OccName -&gt; Bool
&lt;= :: OccName -&gt; OccName -&gt; Bool
$c&gt; :: OccName -&gt; OccName -&gt; Bool
&gt; :: OccName -&gt; OccName -&gt; Bool
$c&gt;= :: OccName -&gt; OccName -&gt; Bool
&gt;= :: OccName -&gt; OccName -&gt; Bool
$cmax :: OccName -&gt; OccName -&gt; OccName
max :: OccName -&gt; OccName -&gt; OccName
$cmin :: OccName -&gt; OccName -&gt; OccName
min :: OccName -&gt; OccName -&gt; OccName
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198608"><span id="local-6989586621679198612"><span id="local-6989586621679198616"><span id="local-6989586621679198618"><span id="local-6989586621679198620"><span id="local-6989586621679198626"><span id="local-6989586621679198631"><span id="local-6989586621679198634"><span id="local-6989586621679198637"><span id="local-6989586621679198640"><span id="local-6989586621679198643"><span id="local-6989586621679198646"><span id="local-6989586621679198651"><span id="local-6989586621679198656"><span class="annot"><span class="annottext">Typeable OccName
Typeable OccName =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; OccName -&gt; c OccName)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c OccName)
-&gt; (OccName -&gt; Constr)
-&gt; (OccName -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c OccName))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c OccName))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; OccName -&gt; OccName)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; OccName -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; OccName -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; OccName -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; OccName -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName)
-&gt; Data OccName
OccName -&gt; Constr
OccName -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; OccName -&gt; OccName
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; OccName -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; OccName -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; OccName -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; OccName -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c OccName
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; OccName -&gt; c OccName
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c OccName)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c OccName)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; OccName -&gt; c OccName
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; OccName -&gt; c OccName
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c OccName
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c OccName
$ctoConstr :: OccName -&gt; Constr
toConstr :: OccName -&gt; Constr
$cdataTypeOf :: OccName -&gt; DataType
dataTypeOf :: OccName -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c OccName)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c OccName)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c OccName)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c OccName)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; OccName -&gt; OccName
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; OccName -&gt; OccName
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; OccName -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; OccName -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; OccName -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; OccName -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; OccName -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; OccName -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; OccName -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; OccName -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; OccName -&gt; m OccName
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679198661"><span id="local-6989586621679198663"><span class="annot"><span class="annottext">(forall x. OccName -&gt; Rep OccName x)
-&gt; (forall x. Rep OccName x -&gt; OccName) -&gt; Generic OccName
forall x. Rep OccName x -&gt; OccName
forall x. OccName -&gt; Rep OccName x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. OccName -&gt; Rep OccName x
from :: forall x. OccName -&gt; Rep OccName x
$cto :: forall x. Rep OccName x -&gt; OccName
to :: forall x. Rep OccName x -&gt; OccName
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-1552"></span><span>
</span><span id="line-1553"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-type">mkModName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-type">ModName</span></a></span><span>
</span><span id="line-1554"></span><span id="mkModName"><span class="annot"><span class="annottext">mkModName :: FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var hs-var">mkModName</span></a></span></span><span> </span><span id="local-6989586621679198665"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198665"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-var">ModName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198665"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1555"></span><span>
</span><span id="line-1556"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#modString"><span class="hs-identifier hs-type">modString</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-type">ModName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1557"></span><span id="modString"><span class="annot"><span class="annottext">modString :: ModName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#modString"><span class="hs-identifier hs-var hs-var">modString</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-type">ModName</span></a></span><span> </span><span id="local-6989586621679198667"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198667"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198667"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-1558"></span><span>
</span><span id="line-1559"></span><span>
</span><span id="line-1560"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-type">mkPkgName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PkgName"><span class="hs-identifier hs-type">PkgName</span></a></span><span>
</span><span id="line-1561"></span><span id="mkPkgName"><span class="annot"><span class="annottext">mkPkgName :: FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-var hs-var">mkPkgName</span></a></span></span><span> </span><span id="local-6989586621679198668"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198668"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#PkgName"><span class="hs-identifier hs-var">PkgName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198668"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1562"></span><span>
</span><span id="line-1563"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#pkgString"><span class="hs-identifier hs-type">pkgString</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PkgName"><span class="hs-identifier hs-type">PkgName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1564"></span><span id="pkgString"><span class="annot"><span class="annottext">pkgString :: PkgName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#pkgString"><span class="hs-identifier hs-var hs-var">pkgString</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PkgName"><span class="hs-identifier hs-type">PkgName</span></a></span><span> </span><span id="local-6989586621679198670"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198670"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198670"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-1565"></span><span>
</span><span id="line-1566"></span><span>
</span><span id="line-1567"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1568"></span><span class="hs-comment">--              OccName</span><span>
</span><span id="line-1569"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1570"></span><span>
</span><span id="line-1571"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-type">mkOccName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#OccName"><span class="hs-identifier hs-type">OccName</span></a></span><span>
</span><span id="line-1572"></span><span id="mkOccName"><span class="annot"><span class="annottext">mkOccName :: FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var hs-var">mkOccName</span></a></span></span><span> </span><span id="local-6989586621679198671"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198671"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#OccName"><span class="hs-identifier hs-var">OccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198671"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1573"></span><span>
</span><span id="line-1574"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#occString"><span class="hs-identifier hs-type">occString</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#OccName"><span class="hs-identifier hs-type">OccName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1575"></span><span id="occString"><span class="annot"><span class="annottext">occString :: OccName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#occString"><span class="hs-identifier hs-var hs-var">occString</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#OccName"><span class="hs-identifier hs-type">OccName</span></a></span><span> </span><span id="local-6989586621679198673"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198673"><span class="hs-identifier hs-var">occ</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679198673"><span class="hs-identifier hs-var">occ</span></a></span><span>
</span><span id="line-1576"></span><span>
</span><span id="line-1577"></span><span>
</span><span id="line-1578"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1579"></span><span class="hs-comment">--               Names</span><span>
</span><span id="line-1580"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1581"></span><span class="hs-comment">--</span><span>
</span><span id="line-1582"></span><span class="hs-comment">-- For &quot;global&quot; names ('NameG') we need a totally unique name,</span><span>
</span><span id="line-1583"></span><span class="hs-comment">-- so we must include the name-space of the thing</span><span>
</span><span id="line-1584"></span><span class="hs-comment">--</span><span>
</span><span id="line-1585"></span><span class="hs-comment">-- For unique-numbered things ('NameU'), we've got a unique reference</span><span>
</span><span id="line-1586"></span><span class="hs-comment">-- anyway, so no need for name space</span><span>
</span><span id="line-1587"></span><span class="hs-comment">--</span><span>
</span><span id="line-1588"></span><span class="hs-comment">-- For dynamically bound thing ('NameS') we probably want them to</span><span>
</span><span id="line-1589"></span><span class="hs-comment">-- in a context-dependent way, so again we don't want the name</span><span>
</span><span id="line-1590"></span><span class="hs-comment">-- space.  For example:</span><span>
</span><span id="line-1591"></span><span class="hs-comment">--</span><span>
</span><span id="line-1592"></span><span class="hs-comment">-- &gt; let v = mkName &quot;T&quot; in [| data $v = $v |]</span><span>
</span><span id="line-1593"></span><span class="hs-comment">--</span><span>
</span><span id="line-1594"></span><span class="hs-comment">-- Here we use the same Name for both type constructor and data constructor</span><span>
</span><span id="line-1595"></span><span class="hs-comment">--</span><span>
</span><span id="line-1596"></span><span class="hs-comment">--</span><span>
</span><span id="line-1597"></span><span class="hs-comment">-- NameL and NameG are bound *outside* the TH syntax tree</span><span>
</span><span id="line-1598"></span><span class="hs-comment">-- either globally (NameG) or locally (NameL). Ex:</span><span>
</span><span id="line-1599"></span><span class="hs-comment">--</span><span>
</span><span id="line-1600"></span><span class="hs-comment">-- &gt; f x = $(h [| (map, x) |])</span><span>
</span><span id="line-1601"></span><span class="hs-comment">--</span><span>
</span><span id="line-1602"></span><span class="hs-comment">-- The 'map' will be a NameG, and 'x' wil be a NameL</span><span>
</span><span id="line-1603"></span><span class="hs-comment">--</span><span>
</span><span id="line-1604"></span><span class="hs-comment">-- These Names should never appear in a binding position in a TH syntax tree</span><span>
</span><span id="line-1605"></span><span>
</span><span id="line-1606"></span><span class="annot"><span class="hs-comment">{- $namecapture #namecapture#
Much of 'Name' API is concerned with the problem of /name capture/, which
can be seen in the following example.

&gt; f expr = [| let x = 0 in $expr |]
&gt; ...
&gt; g x = $( f [| x |] )
&gt; h y = $( f [| y |] )

A naive desugaring of this would yield:

&gt; g x = let x = 0 in x
&gt; h y = let x = 0 in y

All of a sudden, @g@ and @h@ have different meanings! In this case,
we say that the @x@ in the RHS of @g@ has been /captured/
by the binding of @x@ in @f@.

What we actually want is for the @x@ in @f@ to be distinct from the
@x@ in @g@, so we get the following desugaring:

&gt; g x = let x' = 0 in x
&gt; h y = let x' = 0 in y

which avoids name capture as desired.

In the general case, we say that a @Name@ can be captured if
the thing it refers to can be changed by adding new declarations.
-}</span></span><span>
</span><span id="line-1635"></span><span>
</span><span id="line-1636"></span><span class="annot"><span class="hs-comment">{- |
An abstract type representing names in the syntax tree.

'Name's can be constructed in several ways, which come with different
name-capture guarantees (see &quot;Language.Haskell.TH.Syntax#namecapture&quot; for
an explanation of name capture):

  * the built-in syntax @'f@ and @''T@ can be used to construct names,
    The expression @'f@ gives a @Name@ which refers to the value @f@
    currently in scope, and @''T@ gives a @Name@ which refers to the
    type @T@ currently in scope. These names can never be captured.

  * 'lookupValueName' and 'lookupTypeName' are similar to @'f@ and
     @''T@ respectively, but the @Name@s are looked up at the point
     where the current splice is being run. These names can never be
     captured.

  * 'newName' monadically generates a new name, which can never
     be captured.

  * 'mkName' generates a capturable name.

Names constructed using @newName@ and @mkName@ may be used in bindings
(such as @let x = ...@ or @\x -&gt; ...@), but names constructed using
@lookupValueName@, @lookupTypeName@, @'f@, @''T@ may not.
-}</span></span><span>
</span><span id="line-1662"></span><span class="hs-keyword">data</span><span> </span><span id="Name"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Name"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#OccName"><span class="hs-identifier hs-type">OccName</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameFlavour"><span class="hs-identifier hs-type">NameFlavour</span></a></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679198677"><span id="local-6989586621679198682"><span id="local-6989586621679198686"><span id="local-6989586621679198688"><span id="local-6989586621679198690"><span id="local-6989586621679198696"><span id="local-6989586621679198701"><span id="local-6989586621679198704"><span id="local-6989586621679198707"><span id="local-6989586621679198710"><span id="local-6989586621679198713"><span id="local-6989586621679198716"><span id="local-6989586621679198721"><span id="local-6989586621679198726"><span class="annot"><span class="annottext">Typeable Name
Typeable Name =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Name -&gt; c Name)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Name)
-&gt; (Name -&gt; Constr)
-&gt; (Name -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Name))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Name))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Name -&gt; Name)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Name -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name)
-&gt; Data Name
Name -&gt; Constr
Name -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Name -&gt; Name
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Name -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Name
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Name -&gt; c Name
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Name)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Name)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Name -&gt; c Name
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Name -&gt; c Name
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Name
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Name
$ctoConstr :: Name -&gt; Constr
toConstr :: Name -&gt; Constr
$cdataTypeOf :: Name -&gt; DataType
dataTypeOf :: Name -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Name)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Name)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Name)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Name)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Name -&gt; Name
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Name -&gt; Name
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Name -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Name -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name -&gt; m Name
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198731"><span id="local-6989586621679198736"><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
(Name -&gt; Name -&gt; Bool) -&gt; (Name -&gt; Name -&gt; Bool) -&gt; Eq Name
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Name -&gt; Name -&gt; Bool
== :: Name -&gt; Name -&gt; Bool
$c/= :: Name -&gt; Name -&gt; Bool
/= :: Name -&gt; Name -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198740"><span id="local-6989586621679198742"><span class="annot"><span class="annottext">(forall x. Name -&gt; Rep Name x)
-&gt; (forall x. Rep Name x -&gt; Name) -&gt; Generic Name
forall x. Rep Name x -&gt; Name
forall x. Name -&gt; Rep Name x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Name -&gt; Rep Name x
from :: forall x. Name -&gt; Rep Name x
$cto :: forall x. Rep Name x -&gt; Name
to :: forall x. Rep Name x -&gt; Name
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-1663"></span><span>
</span><span id="line-1664"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679198748"><span id="local-6989586621679198752"><span id="local-6989586621679198755"><span id="local-6989586621679198758"><span id="local-6989586621679198761"><span id="local-6989586621679198764"><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1665"></span><span>    </span><span class="hs-comment">-- check if unique is different before looking at strings</span><span>
</span><span id="line-1666"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span id="local-6989586621679198769"><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679198769"><span class="hs-identifier hs-var">o1</span></a></span></span><span> </span><span id="local-6989586621679198770"><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679198770"><span class="hs-identifier hs-var">f1</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679198771"><span class="annot"><span class="annottext">compare :: Name -&gt; Name -&gt; Ordering
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#compare"><span class="hs-operator hs-var hs-var hs-var">`compare`</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span id="local-6989586621679198772"><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679198772"><span class="hs-identifier hs-var">o2</span></a></span></span><span> </span><span id="local-6989586621679198773"><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679198773"><span class="hs-identifier hs-var">f2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679198770"><span class="hs-identifier hs-var">f1</span></a></span><span> </span><span class="annot"><span class="annottext">NameFlavour -&gt; NameFlavour -&gt; Ordering
forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#compare"><span class="hs-operator hs-var">`compare`</span></a></span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679198773"><span class="hs-identifier hs-var">f2</span></a></span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="annottext">Ordering -&gt; Ordering -&gt; Ordering
</span><a href="Language.Haskell.TH.Syntax.html#thenCmp"><span class="hs-operator hs-var">`thenCmp`</span></a></span><span>
</span><span id="line-1667"></span><span>                                        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679198769"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">OccName -&gt; OccName -&gt; Ordering
forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#compare"><span class="hs-operator hs-var">`compare`</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679198772"><span class="hs-identifier hs-var">o2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1668"></span><span>
</span><span id="line-1669"></span><span class="hs-keyword">data</span><span> </span><span id="NameFlavour"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameFlavour"><span class="hs-identifier hs-var">NameFlavour</span></a></span></span><span>
</span><span id="line-1670"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NameS"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameS"><span class="hs-identifier hs-var">NameS</span></a></span></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ An unqualified name; dynamically bound</span></span><span>
</span><span id="line-1671"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NameQ"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameQ"><span class="hs-identifier hs-var">NameQ</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-type">ModName</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ A qualified name; dynamically bound</span></span><span>
</span><span id="line-1672"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NameU"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameU"><span class="hs-identifier hs-var">NameU</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Uniq"><span class="hs-identifier hs-type">Uniq</span></a></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ A unique local name</span></span><span>
</span><span id="line-1673"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NameL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameL"><span class="hs-identifier hs-var">NameL</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Uniq"><span class="hs-identifier hs-type">Uniq</span></a></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Local name bound outside of the TH AST</span></span><span>
</span><span id="line-1674"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NameG"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-var">NameG</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameSpace"><span class="hs-identifier hs-type">NameSpace</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PkgName"><span class="hs-identifier hs-type">PkgName</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-type">ModName</span></a></span><span> </span><span class="hs-comment">-- ^ Global name bound outside of the TH AST:</span><span>
</span><span id="line-1675"></span><span>                </span><span class="hs-comment">-- An original name (occurrences only, not binders)</span><span>
</span><span id="line-1676"></span><span>                </span><span class="hs-comment">-- Need the namespace too to be sure which</span><span>
</span><span id="line-1677"></span><span>                </span><span class="hs-comment">-- thing we are naming</span><span>
</span><span id="line-1678"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span> </span><span id="local-6989586621679198782"><span id="local-6989586621679198792"><span id="local-6989586621679198800"><span id="local-6989586621679198802"><span id="local-6989586621679198804"><span id="local-6989586621679198809"><span id="local-6989586621679198814"><span id="local-6989586621679198817"><span id="local-6989586621679198820"><span id="local-6989586621679198823"><span id="local-6989586621679198826"><span id="local-6989586621679198829"><span id="local-6989586621679198834"><span id="local-6989586621679198839"><span class="annot"><span class="annottext">Typeable NameFlavour
Typeable NameFlavour =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; NameFlavour -&gt; c NameFlavour)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NameFlavour)
-&gt; (NameFlavour -&gt; Constr)
-&gt; (NameFlavour -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NameFlavour))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c NameFlavour))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; NameFlavour -&gt; NameFlavour)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameFlavour -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameFlavour -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NameFlavour -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NameFlavour -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour)
-&gt; Data NameFlavour
NameFlavour -&gt; Constr
NameFlavour -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; NameFlavour -&gt; NameFlavour
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NameFlavour -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NameFlavour -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameFlavour -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameFlavour -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NameFlavour
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NameFlavour -&gt; c NameFlavour
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NameFlavour)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NameFlavour)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NameFlavour -&gt; c NameFlavour
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NameFlavour -&gt; c NameFlavour
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NameFlavour
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NameFlavour
$ctoConstr :: NameFlavour -&gt; Constr
toConstr :: NameFlavour -&gt; Constr
$cdataTypeOf :: NameFlavour -&gt; DataType
dataTypeOf :: NameFlavour -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NameFlavour)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NameFlavour)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NameFlavour)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NameFlavour)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NameFlavour -&gt; NameFlavour
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NameFlavour -&gt; NameFlavour
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameFlavour -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameFlavour -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameFlavour -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameFlavour -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NameFlavour -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NameFlavour -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NameFlavour -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NameFlavour -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameFlavour -&gt; m NameFlavour
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198844"><span id="local-6989586621679198856"><span class="annot"><span class="annottext">NameFlavour -&gt; NameFlavour -&gt; Bool
(NameFlavour -&gt; NameFlavour -&gt; Bool)
-&gt; (NameFlavour -&gt; NameFlavour -&gt; Bool) -&gt; Eq NameFlavour
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: NameFlavour -&gt; NameFlavour -&gt; Bool
== :: NameFlavour -&gt; NameFlavour -&gt; Bool
$c/= :: NameFlavour -&gt; NameFlavour -&gt; Bool
/= :: NameFlavour -&gt; NameFlavour -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198861"><span id="local-6989586621679198872"><span id="local-6989586621679198875"><span id="local-6989586621679198878"><span id="local-6989586621679198881"><span id="local-6989586621679198884"><span id="local-6989586621679198887"><span class="annot"><span class="annottext">Eq NameFlavour
Eq NameFlavour =&gt;
(NameFlavour -&gt; NameFlavour -&gt; Ordering)
-&gt; (NameFlavour -&gt; NameFlavour -&gt; Bool)
-&gt; (NameFlavour -&gt; NameFlavour -&gt; Bool)
-&gt; (NameFlavour -&gt; NameFlavour -&gt; Bool)
-&gt; (NameFlavour -&gt; NameFlavour -&gt; Bool)
-&gt; (NameFlavour -&gt; NameFlavour -&gt; NameFlavour)
-&gt; (NameFlavour -&gt; NameFlavour -&gt; NameFlavour)
-&gt; Ord NameFlavour
NameFlavour -&gt; NameFlavour -&gt; Bool
NameFlavour -&gt; NameFlavour -&gt; Ordering
NameFlavour -&gt; NameFlavour -&gt; NameFlavour
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: NameFlavour -&gt; NameFlavour -&gt; Ordering
compare :: NameFlavour -&gt; NameFlavour -&gt; Ordering
$c&lt; :: NameFlavour -&gt; NameFlavour -&gt; Bool
&lt; :: NameFlavour -&gt; NameFlavour -&gt; Bool
$c&lt;= :: NameFlavour -&gt; NameFlavour -&gt; Bool
&lt;= :: NameFlavour -&gt; NameFlavour -&gt; Bool
$c&gt; :: NameFlavour -&gt; NameFlavour -&gt; Bool
&gt; :: NameFlavour -&gt; NameFlavour -&gt; Bool
$c&gt;= :: NameFlavour -&gt; NameFlavour -&gt; Bool
&gt;= :: NameFlavour -&gt; NameFlavour -&gt; Bool
$cmax :: NameFlavour -&gt; NameFlavour -&gt; NameFlavour
max :: NameFlavour -&gt; NameFlavour -&gt; NameFlavour
$cmin :: NameFlavour -&gt; NameFlavour -&gt; NameFlavour
min :: NameFlavour -&gt; NameFlavour -&gt; NameFlavour
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198890"><span id="local-6989586621679198903"><span id="local-6989586621679198907"><span class="annot"><span class="annottext">Int -&gt; NameFlavour -&gt; FilePath -&gt; FilePath
[NameFlavour] -&gt; FilePath -&gt; FilePath
NameFlavour -&gt; FilePath
(Int -&gt; NameFlavour -&gt; FilePath -&gt; FilePath)
-&gt; (NameFlavour -&gt; FilePath)
-&gt; ([NameFlavour] -&gt; FilePath -&gt; FilePath)
-&gt; Show NameFlavour
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; NameFlavour -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; NameFlavour -&gt; FilePath -&gt; FilePath
$cshow :: NameFlavour -&gt; FilePath
show :: NameFlavour -&gt; FilePath
$cshowList :: [NameFlavour] -&gt; FilePath -&gt; FilePath
showList :: [NameFlavour] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198910"><span id="local-6989586621679198912"><span class="annot"><span class="annottext">(forall x. NameFlavour -&gt; Rep NameFlavour x)
-&gt; (forall x. Rep NameFlavour x -&gt; NameFlavour)
-&gt; Generic NameFlavour
forall x. Rep NameFlavour x -&gt; NameFlavour
forall x. NameFlavour -&gt; Rep NameFlavour x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. NameFlavour -&gt; Rep NameFlavour x
from :: forall x. NameFlavour -&gt; Rep NameFlavour x
$cto :: forall x. Rep NameFlavour x -&gt; NameFlavour
to :: forall x. Rep NameFlavour x -&gt; NameFlavour
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-1679"></span><span>
</span><span id="line-1680"></span><span class="hs-keyword">data</span><span> </span><span id="NameSpace"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameSpace"><span class="hs-identifier hs-var">NameSpace</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="VarName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarName"><span class="hs-identifier hs-var">VarName</span></a></span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ Variables</span></span><span>
</span><span id="line-1681"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="DataName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Data constructors</span></span><span>
</span><span id="line-1682"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="TcClsName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TcClsName"><span class="hs-identifier hs-var">TcClsName</span></a></span></span><span>      </span><span class="hs-comment">-- ^ Type constructors and classes; Haskell has them</span><span>
</span><span id="line-1683"></span><span>                                </span><span class="hs-comment">-- in the same name space for now.</span><span>
</span><span id="line-1684"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="FldName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FldName"><span class="hs-identifier hs-var">FldName</span></a></span></span><span>
</span><span id="line-1685"></span><span>                 </span><span class="hs-special">{</span><span> </span><span id="fldParent"><span class="annot"><span class="annottext">NameSpace -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#fldParent"><span class="hs-identifier hs-var hs-var">fldParent</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1686"></span><span>                   </span><span class="hs-comment">-- ^ The textual name of the parent of the field.</span><span>
</span><span id="line-1687"></span><span>                   </span><span class="hs-comment">--</span><span>
</span><span id="line-1688"></span><span>                   </span><span class="hs-comment">--   - For a field of a datatype, this is the name of the first constructor</span><span>
</span><span id="line-1689"></span><span>                   </span><span class="hs-comment">--     of the datatype (regardless of whether this constructor has this field).</span><span>
</span><span id="line-1690"></span><span>                   </span><span class="hs-comment">--   - For a field of a pattern synonym, this is the name of the pattern synonym.</span><span>
</span><span id="line-1691"></span><span>                 </span><span class="hs-special">}</span><span>
</span><span id="line-1692"></span><span>               </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679198917"><span id="local-6989586621679198923"><span class="annot"><span class="annottext">NameSpace -&gt; NameSpace -&gt; Bool
(NameSpace -&gt; NameSpace -&gt; Bool)
-&gt; (NameSpace -&gt; NameSpace -&gt; Bool) -&gt; Eq NameSpace
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: NameSpace -&gt; NameSpace -&gt; Bool
== :: NameSpace -&gt; NameSpace -&gt; Bool
$c/= :: NameSpace -&gt; NameSpace -&gt; Bool
/= :: NameSpace -&gt; NameSpace -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198928"><span id="local-6989586621679198934"><span id="local-6989586621679198937"><span id="local-6989586621679198940"><span id="local-6989586621679198943"><span id="local-6989586621679198946"><span id="local-6989586621679198949"><span class="annot"><span class="annottext">Eq NameSpace
Eq NameSpace =&gt;
(NameSpace -&gt; NameSpace -&gt; Ordering)
-&gt; (NameSpace -&gt; NameSpace -&gt; Bool)
-&gt; (NameSpace -&gt; NameSpace -&gt; Bool)
-&gt; (NameSpace -&gt; NameSpace -&gt; Bool)
-&gt; (NameSpace -&gt; NameSpace -&gt; Bool)
-&gt; (NameSpace -&gt; NameSpace -&gt; NameSpace)
-&gt; (NameSpace -&gt; NameSpace -&gt; NameSpace)
-&gt; Ord NameSpace
NameSpace -&gt; NameSpace -&gt; Bool
NameSpace -&gt; NameSpace -&gt; Ordering
NameSpace -&gt; NameSpace -&gt; NameSpace
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: NameSpace -&gt; NameSpace -&gt; Ordering
compare :: NameSpace -&gt; NameSpace -&gt; Ordering
$c&lt; :: NameSpace -&gt; NameSpace -&gt; Bool
&lt; :: NameSpace -&gt; NameSpace -&gt; Bool
$c&lt;= :: NameSpace -&gt; NameSpace -&gt; Bool
&lt;= :: NameSpace -&gt; NameSpace -&gt; Bool
$c&gt; :: NameSpace -&gt; NameSpace -&gt; Bool
&gt; :: NameSpace -&gt; NameSpace -&gt; Bool
$c&gt;= :: NameSpace -&gt; NameSpace -&gt; Bool
&gt;= :: NameSpace -&gt; NameSpace -&gt; Bool
$cmax :: NameSpace -&gt; NameSpace -&gt; NameSpace
max :: NameSpace -&gt; NameSpace -&gt; NameSpace
$cmin :: NameSpace -&gt; NameSpace -&gt; NameSpace
min :: NameSpace -&gt; NameSpace -&gt; NameSpace
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198952"><span id="local-6989586621679198957"><span id="local-6989586621679198960"><span class="annot"><span class="annottext">Int -&gt; NameSpace -&gt; FilePath -&gt; FilePath
[NameSpace] -&gt; FilePath -&gt; FilePath
NameSpace -&gt; FilePath
(Int -&gt; NameSpace -&gt; FilePath -&gt; FilePath)
-&gt; (NameSpace -&gt; FilePath)
-&gt; ([NameSpace] -&gt; FilePath -&gt; FilePath)
-&gt; Show NameSpace
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; NameSpace -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; NameSpace -&gt; FilePath -&gt; FilePath
$cshow :: NameSpace -&gt; FilePath
show :: NameSpace -&gt; FilePath
$cshowList :: [NameSpace] -&gt; FilePath -&gt; FilePath
showList :: [NameSpace] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679198965"><span id="local-6989586621679198969"><span id="local-6989586621679198973"><span id="local-6989586621679198975"><span id="local-6989586621679198977"><span id="local-6989586621679198982"><span id="local-6989586621679198987"><span id="local-6989586621679198990"><span id="local-6989586621679198993"><span id="local-6989586621679198996"><span id="local-6989586621679198999"><span id="local-6989586621679199002"><span id="local-6989586621679199007"><span id="local-6989586621679199012"><span class="annot"><span class="annottext">Typeable NameSpace
Typeable NameSpace =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; NameSpace -&gt; c NameSpace)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NameSpace)
-&gt; (NameSpace -&gt; Constr)
-&gt; (NameSpace -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NameSpace))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NameSpace))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; NameSpace -&gt; NameSpace)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameSpace -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameSpace -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NameSpace -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NameSpace -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace)
-&gt; Data NameSpace
NameSpace -&gt; Constr
NameSpace -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; NameSpace -&gt; NameSpace
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NameSpace -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NameSpace -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameSpace -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameSpace -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NameSpace
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NameSpace -&gt; c NameSpace
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NameSpace)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NameSpace)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NameSpace -&gt; c NameSpace
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; NameSpace -&gt; c NameSpace
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NameSpace
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NameSpace
$ctoConstr :: NameSpace -&gt; Constr
toConstr :: NameSpace -&gt; Constr
$cdataTypeOf :: NameSpace -&gt; DataType
dataTypeOf :: NameSpace -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NameSpace)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NameSpace)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NameSpace)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c NameSpace)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NameSpace -&gt; NameSpace
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; NameSpace -&gt; NameSpace
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameSpace -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameSpace -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameSpace -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NameSpace -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NameSpace -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NameSpace -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NameSpace -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NameSpace -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; NameSpace -&gt; m NameSpace
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199017"><span id="local-6989586621679199019"><span class="annot"><span class="annottext">(forall x. NameSpace -&gt; Rep NameSpace x)
-&gt; (forall x. Rep NameSpace x -&gt; NameSpace) -&gt; Generic NameSpace
forall x. Rep NameSpace x -&gt; NameSpace
forall x. NameSpace -&gt; Rep NameSpace x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. NameSpace -&gt; Rep NameSpace x
from :: forall x. NameSpace -&gt; Rep NameSpace x
$cto :: forall x. Rep NameSpace x -&gt; NameSpace
to :: forall x. Rep NameSpace x -&gt; NameSpace
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-1693"></span><span>
</span><span id="line-1694"></span><span class="annot"><span class="hs-comment">-- | @Uniq@ is used by GHC to distinguish names from each other.</span></span><span>
</span><span id="line-1695"></span><span class="hs-keyword">type</span><span> </span><span id="Uniq"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Uniq"><span class="hs-identifier hs-var">Uniq</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>
</span><span id="line-1696"></span><span>
</span><span id="line-1697"></span><span class="hs-comment">-- | The name without its module prefix.</span><span>
</span><span id="line-1698"></span><span class="hs-comment">--</span><span>
</span><span id="line-1699"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1700"></span><span class="hs-comment">--</span><span>
</span><span id="line-1701"></span><span class="hs-comment">-- &gt;&gt;&gt; nameBase ''Data.Either.Either</span><span>
</span><span id="line-1702"></span><span class="hs-comment">-- &quot;Either&quot;</span><span>
</span><span id="line-1703"></span><span class="hs-comment">-- &gt;&gt;&gt; nameBase (mkName &quot;foo&quot;)</span><span>
</span><span id="line-1704"></span><span class="hs-comment">-- &quot;foo&quot;</span><span>
</span><span id="line-1705"></span><span class="hs-comment">-- &gt;&gt;&gt; nameBase (mkName &quot;Module.foo&quot;)</span><span>
</span><span id="line-1706"></span><span class="hs-comment">-- &quot;foo&quot;</span><span>
</span><span id="line-1707"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nameBase"><span class="hs-identifier hs-type">nameBase</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1708"></span><span id="nameBase"><span class="annot"><span class="annottext">nameBase :: Name -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#nameBase"><span class="hs-identifier hs-var hs-var">nameBase</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span id="local-6989586621679199022"><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199022"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#occString"><span class="hs-identifier hs-var">occString</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199022"><span class="hs-identifier hs-var">occ</span></a></span><span>
</span><span id="line-1709"></span><span>
</span><span id="line-1710"></span><span class="hs-comment">-- | Module prefix of a name, if it exists.</span><span>
</span><span id="line-1711"></span><span class="hs-comment">--</span><span>
</span><span id="line-1712"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1713"></span><span class="hs-comment">--</span><span>
</span><span id="line-1714"></span><span class="hs-comment">-- &gt;&gt;&gt; nameModule ''Data.Either.Either</span><span>
</span><span id="line-1715"></span><span class="hs-comment">-- Just &quot;Data.Either&quot;</span><span>
</span><span id="line-1716"></span><span class="hs-comment">-- &gt;&gt;&gt; nameModule (mkName &quot;foo&quot;)</span><span>
</span><span id="line-1717"></span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-1718"></span><span class="hs-comment">-- &gt;&gt;&gt; nameModule (mkName &quot;Module.foo&quot;)</span><span>
</span><span id="line-1719"></span><span class="hs-comment">-- Just &quot;Module&quot;</span><span>
</span><span id="line-1720"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nameModule"><span class="hs-identifier hs-type">nameModule</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1721"></span><span id="nameModule"><span class="annot"><span class="annottext">nameModule :: Name -&gt; Maybe FilePath
</span><a href="Language.Haskell.TH.Syntax.html#nameModule"><span class="hs-identifier hs-var hs-var">nameModule</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameQ"><span class="hs-identifier hs-type">NameQ</span></a></span><span> </span><span id="local-6989586621679199024"><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199024"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ModName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#modString"><span class="hs-identifier hs-var">modString</span></a></span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199024"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1722"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nameModule"><span class="hs-identifier hs-var">nameModule</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-type">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">PkgName
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679199025"><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199025"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ModName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#modString"><span class="hs-identifier hs-var">modString</span></a></span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199025"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1723"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nameModule"><span class="hs-identifier hs-var">nameModule</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span>                      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1724"></span><span>
</span><span id="line-1725"></span><span class="hs-comment">-- | A name's package, if it exists.</span><span>
</span><span id="line-1726"></span><span class="hs-comment">--</span><span>
</span><span id="line-1727"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1728"></span><span class="hs-comment">--</span><span>
</span><span id="line-1729"></span><span class="hs-comment">-- &gt;&gt;&gt; namePackage ''Data.Either.Either</span><span>
</span><span id="line-1730"></span><span class="hs-comment">-- Just &quot;base&quot;</span><span>
</span><span id="line-1731"></span><span class="hs-comment">-- &gt;&gt;&gt; namePackage (mkName &quot;foo&quot;)</span><span>
</span><span id="line-1732"></span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-1733"></span><span class="hs-comment">-- &gt;&gt;&gt; namePackage (mkName &quot;Module.foo&quot;)</span><span>
</span><span id="line-1734"></span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-1735"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#namePackage"><span class="hs-identifier hs-type">namePackage</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1736"></span><span id="namePackage"><span class="annot"><span class="annottext">namePackage :: Name -&gt; Maybe FilePath
</span><a href="Language.Haskell.TH.Syntax.html#namePackage"><span class="hs-identifier hs-var hs-var">namePackage</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-type">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679199027"><span class="annot"><span class="annottext">PkgName
</span><a href="#local-6989586621679199027"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">ModName
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PkgName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#pkgString"><span class="hs-identifier hs-var">pkgString</span></a></span><span> </span><span class="annot"><span class="annottext">PkgName
</span><a href="#local-6989586621679199027"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1737"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#namePackage"><span class="hs-identifier hs-var">namePackage</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span>                      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1738"></span><span>
</span><span id="line-1739"></span><span class="hs-comment">-- | Returns whether a name represents an occurrence of a top-level variable</span><span>
</span><span id="line-1740"></span><span class="hs-comment">-- ('VarName'), data constructor ('DataName'), type constructor, or type class</span><span>
</span><span id="line-1741"></span><span class="hs-comment">-- ('TcClsName'). If we can't be sure, it returns 'Nothing'.</span><span>
</span><span id="line-1742"></span><span class="hs-comment">--</span><span>
</span><span id="line-1743"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1744"></span><span class="hs-comment">--</span><span>
</span><span id="line-1745"></span><span class="hs-comment">-- &gt;&gt;&gt; nameSpace 'Prelude.id</span><span>
</span><span id="line-1746"></span><span class="hs-comment">-- Just VarName</span><span>
</span><span id="line-1747"></span><span class="hs-comment">-- &gt;&gt;&gt; nameSpace (mkName &quot;id&quot;)</span><span>
</span><span id="line-1748"></span><span class="hs-comment">-- Nothing -- only works for top-level variable names</span><span>
</span><span id="line-1749"></span><span class="hs-comment">-- &gt;&gt;&gt; nameSpace 'Data.Maybe.Just</span><span>
</span><span id="line-1750"></span><span class="hs-comment">-- Just DataName</span><span>
</span><span id="line-1751"></span><span class="hs-comment">-- &gt;&gt;&gt; nameSpace ''Data.Maybe.Maybe</span><span>
</span><span id="line-1752"></span><span class="hs-comment">-- Just TcClsName</span><span>
</span><span id="line-1753"></span><span class="hs-comment">-- &gt;&gt;&gt; nameSpace ''Data.Ord.Ord</span><span>
</span><span id="line-1754"></span><span class="hs-comment">-- Just TcClsName</span><span>
</span><span id="line-1755"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nameSpace"><span class="hs-identifier hs-type">nameSpace</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameSpace"><span class="hs-identifier hs-type">NameSpace</span></a></span><span>
</span><span id="line-1756"></span><span id="nameSpace"><span class="annot"><span class="annottext">nameSpace :: Name -&gt; Maybe NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#nameSpace"><span class="hs-identifier hs-var hs-var">nameSpace</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-type">NameG</span></a></span><span> </span><span id="local-6989586621679199028"><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199028"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span class="annot"><span class="annottext">PkgName
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">ModName
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; Maybe NameSpace
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199028"><span class="hs-identifier hs-var">ns</span></a></span><span>
</span><span id="line-1757"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#nameSpace"><span class="hs-identifier hs-var">nameSpace</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><span class="hs-identifier">_</span></span><span>                       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe NameSpace
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1758"></span><span>
</span><span id="line-1759"></span><span class="annot"><span class="hs-comment">{- |
Generate a capturable name. Occurrences of such names will be
resolved according to the Haskell scoping rules at the occurrence
site.

For example:

&gt; f = [| pi + $(varE (mkName &quot;pi&quot;)) |]
&gt; ...
&gt; g = let pi = 3 in $f

In this case, @g@ is desugared to

&gt; g = Prelude.pi + 3

Note that @mkName@ may be used with qualified names:

&gt; mkName &quot;Prelude.pi&quot;

See also 'Language.Haskell.TH.Lib.dyn' for a useful combinator. The above example could
be rewritten using 'Language.Haskell.TH.Lib.dyn' as

&gt; f = [| pi + $(dyn &quot;pi&quot;) |]
-}</span></span><span>
</span><span id="line-1783"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkName"><span class="hs-identifier hs-type">mkName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1784"></span><span class="hs-comment">-- The string can have a '.', thus &quot;Foo.baz&quot;,</span><span>
</span><span id="line-1785"></span><span class="hs-comment">-- giving a dynamically-bound qualified name,</span><span>
</span><span id="line-1786"></span><span class="hs-comment">-- in which case we want to generate a NameQ</span><span>
</span><span id="line-1787"></span><span class="hs-comment">--</span><span>
</span><span id="line-1788"></span><span class="hs-comment">-- Parse the string to see if it has a &quot;.&quot; in it</span><span>
</span><span id="line-1789"></span><span class="hs-comment">-- so we know whether to generate a qualified or unqualified name</span><span>
</span><span id="line-1790"></span><span class="hs-comment">-- It's a bit tricky because we need to parse</span><span>
</span><span id="line-1791"></span><span class="hs-comment">--</span><span>
</span><span id="line-1792"></span><span class="hs-comment">-- &gt; Foo.Baz.x   as    Qual Foo.Baz x</span><span>
</span><span id="line-1793"></span><span class="hs-comment">--</span><span>
</span><span id="line-1794"></span><span class="hs-comment">-- So we parse it from back to front</span><span>
</span><span id="line-1795"></span><span id="mkName"><span class="annot"><span class="annottext">mkName :: FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkName"><span class="hs-identifier hs-var hs-var">mkName</span></a></span></span><span> </span><span id="local-6989586621679199029"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199029"><span class="hs-identifier hs-var">str</span></a></span></span><span>
</span><span id="line-1796"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Name
</span><a href="#local-6989586621679199030"><span class="hs-identifier hs-var">split</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; FilePath
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199029"><span class="hs-identifier hs-var">str</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1797"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1798"></span><span>    </span><span id="local-6989586621679199030"><span class="annot"><span class="annottext">split :: FilePath -&gt; FilePath -&gt; Name
</span><a href="#local-6989586621679199030"><span class="hs-identifier hs-var hs-var">split</span></a></span></span><span> </span><span id="local-6989586621679199033"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199033"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199033"><span class="hs-identifier hs-var">occ</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameS"><span class="hs-identifier hs-var">NameS</span></a></span><span>
</span><span id="line-1799"></span><span>    </span><span class="annot"><a href="#local-6989586621679199030"><span class="hs-identifier hs-var">split</span></a></span><span> </span><span id="local-6989586621679199034"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199034"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'.'</span></span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-type">:</span></a></span><span id="local-6989586621679199035"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199035"><span class="hs-identifier hs-var">rev</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#not"><span class="hs-identifier hs-var">not</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199034"><span class="hs-identifier hs-var">occ</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1800"></span><span>                        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Bool
</span><a href="#local-6989586621679199036"><span class="hs-identifier hs-var">is_rev_mod_name</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199035"><span class="hs-identifier hs-var">rev</span></a></span><span>
</span><span id="line-1801"></span><span>                        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199034"><span class="hs-identifier hs-var">occ</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameQ"><span class="hs-identifier hs-var">NameQ</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; FilePath
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199035"><span class="hs-identifier hs-var">rev</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1802"></span><span>        </span><span class="hs-comment">-- The 'not (null occ)' guard ensures that</span><span>
</span><span id="line-1803"></span><span>        </span><span class="hs-comment">--      mkName &quot;&amp;.&quot; = Name &quot;&amp;.&quot; NameS</span><span>
</span><span id="line-1804"></span><span>        </span><span class="hs-comment">-- The 'is_rev_mod' guards ensure that</span><span>
</span><span id="line-1805"></span><span>        </span><span class="hs-comment">--      mkName &quot;.&amp;&quot; = Name &quot;.&amp;&quot; NameS</span><span>
</span><span id="line-1806"></span><span>        </span><span class="hs-comment">--      mkName &quot;^..&quot; = Name &quot;^..&quot; NameS      -- #8633</span><span>
</span><span id="line-1807"></span><span>        </span><span class="hs-comment">--      mkName &quot;Data.Bits..&amp;&quot; = Name &quot;.&amp;&quot; (NameQ &quot;Data.Bits&quot;)</span><span>
</span><span id="line-1808"></span><span>        </span><span class="hs-comment">-- This rather bizarre case actually happened; (.&amp;.) is in Data.Bits</span><span>
</span><span id="line-1809"></span><span>    </span><span class="annot"><a href="#local-6989586621679199030"><span class="hs-identifier hs-var">split</span></a></span><span> </span><span id="local-6989586621679199037"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199037"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679199038"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199038"><span class="hs-identifier hs-var">c</span></a></span></span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-type">:</span></a></span><span id="local-6989586621679199039"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199039"><span class="hs-identifier hs-var">rev</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Name
</span><a href="#local-6989586621679199030"><span class="hs-identifier hs-var">split</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199038"><span class="hs-identifier hs-var">c</span></a></span><span class="annot"><span class="annottext">Char -&gt; FilePath -&gt; FilePath
forall a. a -&gt; [a] -&gt; [a]
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-var">:</span></a></span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199037"><span class="hs-identifier hs-var">occ</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199039"><span class="hs-identifier hs-var">rev</span></a></span><span>
</span><span id="line-1810"></span><span>
</span><span id="line-1811"></span><span>    </span><span class="hs-comment">-- Recognises a reversed module name xA.yB.C,</span><span>
</span><span id="line-1812"></span><span>    </span><span class="hs-comment">-- with at least one component,</span><span>
</span><span id="line-1813"></span><span>    </span><span class="hs-comment">-- and each component looks like a module name</span><span>
</span><span id="line-1814"></span><span>    </span><span class="hs-comment">--   (i.e. non-empty, starts with capital, all alpha)</span><span>
</span><span id="line-1815"></span><span>    </span><span id="local-6989586621679199036"><span class="annot"><span class="annottext">is_rev_mod_name :: FilePath -&gt; Bool
</span><a href="#local-6989586621679199036"><span class="hs-identifier hs-var hs-var">is_rev_mod_name</span></a></span></span><span> </span><span id="local-6989586621679199045"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199045"><span class="hs-identifier hs-var">rev_mod_str</span></a></span></span><span>
</span><span id="line-1816"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679199046"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199046"><span class="hs-identifier hs-var">compt</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199047"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199047"><span class="hs-identifier hs-var">rest</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; FilePath -&gt; (FilePath, FilePath)
forall a. (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">break</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'.'</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199045"><span class="hs-identifier hs-var">rev_mod_str</span></a></span><span>
</span><span id="line-1817"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#not"><span class="hs-identifier hs-var">not</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199046"><span class="hs-identifier hs-var">compt</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">isUpper</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Char
forall a. HasCallStack =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">last</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199046"><span class="hs-identifier hs-var">compt</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; FilePath -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><a href="#local-6989586621679199051"><span class="hs-identifier hs-var">is_mod_char</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199046"><span class="hs-identifier hs-var">compt</span></a></span><span>
</span><span id="line-1818"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199047"><span class="hs-identifier hs-var">rest</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1819"></span><span>          </span><span class="hs-special">[</span><span class="hs-special">]</span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-1820"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679199052"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199052"><span class="hs-identifier hs-var">_dot</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-type">:</span></a></span><span> </span><span id="local-6989586621679199053"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199053"><span class="hs-identifier hs-var">rest'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Bool
</span><a href="#local-6989586621679199036"><span class="hs-identifier hs-var">is_rev_mod_name</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199053"><span class="hs-identifier hs-var">rest'</span></a></span><span>
</span><span id="line-1821"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1822"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-1823"></span><span>
</span><span id="line-1824"></span><span>    </span><span id="local-6989586621679199051"><span class="annot"><span class="annottext">is_mod_char :: Char -&gt; Bool
</span><a href="#local-6989586621679199051"><span class="hs-identifier hs-var hs-var">is_mod_char</span></a></span></span><span> </span><span id="local-6989586621679199056"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199056"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">isAlphaNum</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199056"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%7C%7C"><span class="hs-operator hs-var">||</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199056"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'_'</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%7C%7C"><span class="hs-operator hs-var">||</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199056"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\''</span></span><span>
</span><span id="line-1825"></span><span>
</span><span id="line-1826"></span><span class="annot"><span class="hs-comment">-- | Only used internally</span></span><span>
</span><span id="line-1827"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameU"><span class="hs-identifier hs-type">mkNameU</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Uniq"><span class="hs-identifier hs-type">Uniq</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1828"></span><span id="mkNameU"><span class="annot"><span class="annottext">mkNameU :: FilePath -&gt; Uniq -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameU"><span class="hs-identifier hs-var hs-var">mkNameU</span></a></span></span><span> </span><span id="local-6989586621679199057"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199057"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679199058"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679199058"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199057"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameU"><span class="hs-identifier hs-var">NameU</span></a></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679199058"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1829"></span><span>
</span><span id="line-1830"></span><span class="annot"><span class="hs-comment">-- | Only used internally</span></span><span>
</span><span id="line-1831"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameL"><span class="hs-identifier hs-type">mkNameL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Uniq"><span class="hs-identifier hs-type">Uniq</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1832"></span><span id="mkNameL"><span class="annot"><span class="annottext">mkNameL :: FilePath -&gt; Uniq -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameL"><span class="hs-identifier hs-var hs-var">mkNameL</span></a></span></span><span> </span><span id="local-6989586621679199059"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199059"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679199060"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679199060"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199059"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Uniq -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameL"><span class="hs-identifier hs-var">NameL</span></a></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679199060"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1833"></span><span>
</span><span id="line-1834"></span><span class="annot"><span class="hs-comment">-- | Only used internally</span></span><span>
</span><span id="line-1835"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameQ"><span class="hs-identifier hs-type">mkNameQ</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1836"></span><span id="mkNameQ"><span class="annot"><span class="annottext">mkNameQ :: FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameQ"><span class="hs-identifier hs-var hs-var">mkNameQ</span></a></span></span><span> </span><span id="local-6989586621679199061"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199061"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679199062"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199062"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199062"><span class="hs-identifier hs-var">occ</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameQ"><span class="hs-identifier hs-var">NameQ</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199061"><span class="hs-identifier hs-var">mn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1837"></span><span>
</span><span id="line-1838"></span><span class="annot"><span class="hs-comment">-- | Used for 'x etc, but not available to the programmer</span></span><span>
</span><span id="line-1839"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameG"><span class="hs-identifier hs-type">mkNameG</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameSpace"><span class="hs-identifier hs-type">NameSpace</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1840"></span><span id="mkNameG"><span class="annot"><span class="annottext">mkNameG :: NameSpace -&gt; FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG"><span class="hs-identifier hs-var hs-var">mkNameG</span></a></span></span><span> </span><span id="local-6989586621679199064"><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199064"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679199065"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199065"><span class="hs-identifier hs-var">pkg</span></a></span></span><span> </span><span id="local-6989586621679199066"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199066"><span class="hs-identifier hs-var">modu</span></a></span></span><span> </span><span id="local-6989586621679199067"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199067"><span class="hs-identifier hs-var">occ</span></a></span></span><span>
</span><span id="line-1841"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199067"><span class="hs-identifier hs-var">occ</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSpace -&gt; PkgName -&gt; ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-var">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199064"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-var">mkPkgName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199065"><span class="hs-identifier hs-var">pkg</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199066"><span class="hs-identifier hs-var">modu</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1842"></span><span>
</span><span id="line-1843"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameS"><span class="hs-identifier hs-type">mkNameS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1844"></span><span id="mkNameS"><span class="annot"><span class="annottext">mkNameS :: FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameS"><span class="hs-identifier hs-var hs-var">mkNameS</span></a></span></span><span> </span><span id="local-6989586621679199068"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199068"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199068"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameS"><span class="hs-identifier hs-var">NameS</span></a></span><span>
</span><span id="line-1845"></span><span>
</span><span id="line-1846"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameG_v"><span class="hs-identifier hs-type">mkNameG_v</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameG_tc"><span class="hs-identifier hs-type">mkNameG_tc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameG_d"><span class="hs-identifier hs-type">mkNameG_d</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1847"></span><span id="mkNameG_v"><span class="annot"><span class="annottext">mkNameG_v :: FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG_v"><span class="hs-identifier hs-var hs-var">mkNameG_v</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG"><span class="hs-identifier hs-var">mkNameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#VarName"><span class="hs-identifier hs-var">VarName</span></a></span><span>
</span><span id="line-1848"></span><span id="mkNameG_tc"><span class="annot"><span class="annottext">mkNameG_tc :: FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG_tc"><span class="hs-identifier hs-var hs-var">mkNameG_tc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG"><span class="hs-identifier hs-var">mkNameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#TcClsName"><span class="hs-identifier hs-var">TcClsName</span></a></span><span>
</span><span id="line-1849"></span><span id="mkNameG_d"><span class="annot"><span class="annottext">mkNameG_d :: FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG_d"><span class="hs-identifier hs-var hs-var">mkNameG_d</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG"><span class="hs-identifier hs-var">mkNameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span>
</span><span id="line-1850"></span><span>
</span><span id="line-1851"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mkNameG_fld"><span class="hs-identifier hs-type">mkNameG_fld</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ package</span></span><span>
</span><span id="line-1852"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ module</span></span><span>
</span><span id="line-1853"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ parent (first constructor of parent type)</span></span><span>
</span><span id="line-1854"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ field name</span></span><span>
</span><span id="line-1855"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1856"></span><span id="mkNameG_fld"><span class="annot"><span class="annottext">mkNameG_fld :: FilePath -&gt; FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG_fld"><span class="hs-identifier hs-var hs-var">mkNameG_fld</span></a></span></span><span> </span><span id="local-6989586621679199069"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199069"><span class="hs-identifier hs-var">pkg</span></a></span></span><span> </span><span id="local-6989586621679199070"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199070"><span class="hs-identifier hs-var">modu</span></a></span></span><span> </span><span id="local-6989586621679199071"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199071"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621679199072"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199072"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; FilePath -&gt; FilePath -&gt; FilePath -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mkNameG"><span class="hs-identifier hs-var">mkNameG</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#FldName"><span class="hs-identifier hs-var">FldName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199071"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199069"><span class="hs-identifier hs-var">pkg</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199070"><span class="hs-identifier hs-var">modu</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199072"><span class="hs-identifier hs-var">occ</span></a></span><span>
</span><span id="line-1857"></span><span>
</span><span id="line-1858"></span><span class="hs-keyword">data</span><span> </span><span id="NameIs"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameIs"><span class="hs-identifier hs-var">NameIs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Alone"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Alone"><span class="hs-identifier hs-var">Alone</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Applied"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Applied"><span class="hs-identifier hs-var">Applied</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Infix"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Infix"><span class="hs-identifier hs-var">Infix</span></a></span></span><span>
</span><span id="line-1859"></span><span>
</span><span id="line-1860"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#showName"><span class="hs-identifier hs-type">showName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1861"></span><span id="showName"><span class="annot"><span class="annottext">showName :: Name -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#showName"><span class="hs-identifier hs-var hs-var">showName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameIs -&gt; Name -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#showName%27"><span class="hs-identifier hs-var">showName'</span></a></span><span> </span><span class="annot"><span class="annottext">NameIs
</span><a href="Language.Haskell.TH.Syntax.html#Alone"><span class="hs-identifier hs-var">Alone</span></a></span><span>
</span><span id="line-1862"></span><span>
</span><span id="line-1863"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#showName%27"><span class="hs-identifier hs-type">showName'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameIs"><span class="hs-identifier hs-type">NameIs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1864"></span><span id="showName%27"><span class="annot"><span class="annottext">showName' :: NameIs -&gt; Name -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#showName%27"><span class="hs-identifier hs-var hs-var">showName'</span></a></span></span><span> </span><span id="local-6989586621679199077"><span class="annot"><span class="annottext">NameIs
</span><a href="#local-6989586621679199077"><span class="hs-identifier hs-var">ni</span></a></span></span><span> </span><span id="local-6989586621679199078"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679199078"><span class="hs-identifier hs-var">nm</span></a></span></span><span>
</span><span id="line-1865"></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NameIs
</span><a href="#local-6989586621679199077"><span class="hs-identifier hs-var">ni</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1866"></span><span>       </span><span class="annot"><span class="annottext">NameIs
</span><a href="Language.Haskell.TH.Syntax.html#Alone"><span class="hs-identifier hs-var">Alone</span></a></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199079"><span class="hs-identifier hs-var">nms</span></a></span><span>
</span><span id="line-1867"></span><span>       </span><span class="annot"><span class="annottext">NameIs
</span><a href="Language.Haskell.TH.Syntax.html#Applied"><span class="hs-identifier hs-var">Applied</span></a></span><span>
</span><span id="line-1868"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679199080"><span class="hs-identifier hs-var">pnam</span></a></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199079"><span class="hs-identifier hs-var">nms</span></a></span><span>
</span><span id="line-1869"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;(&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199079"><span class="hs-identifier hs-var">nms</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;)&quot;</span></span><span>
</span><span id="line-1870"></span><span>       </span><span class="annot"><span class="annottext">NameIs
</span><a href="Language.Haskell.TH.Syntax.html#Infix"><span class="hs-identifier hs-var">Infix</span></a></span><span>
</span><span id="line-1871"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679199080"><span class="hs-identifier hs-var">pnam</span></a></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;`&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199079"><span class="hs-identifier hs-var">nms</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;`&quot;</span></span><span>
</span><span id="line-1872"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199079"><span class="hs-identifier hs-var">nms</span></a></span><span>
</span><span id="line-1873"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-1874"></span><span>        </span><span class="hs-comment">-- For now, we make the NameQ and NameG print the same, even though</span><span>
</span><span id="line-1875"></span><span>        </span><span class="hs-comment">-- NameQ is a qualified name (so what it means depends on what the</span><span>
</span><span id="line-1876"></span><span>        </span><span class="hs-comment">-- current scope is), and NameG is an original name (so its meaning</span><span>
</span><span id="line-1877"></span><span>        </span><span class="hs-comment">-- should be independent of what's in scope.</span><span>
</span><span id="line-1878"></span><span>        </span><span class="hs-comment">-- We may well want to distinguish them in the end.</span><span>
</span><span id="line-1879"></span><span>        </span><span class="hs-comment">-- Ditto NameU and NameL</span><span>
</span><span id="line-1880"></span><span>        </span><span id="local-6989586621679199079"><span class="annot"><span class="annottext">nms :: FilePath
</span><a href="#local-6989586621679199079"><span class="hs-identifier hs-var hs-var">nms</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679199078"><span class="hs-identifier hs-var">nm</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1881"></span><span>          </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span id="local-6989586621679199081"><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199081"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameS"><span class="hs-identifier hs-var">NameS</span></a></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#occString"><span class="hs-identifier hs-var">occString</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199081"><span class="hs-identifier hs-var">occ</span></a></span><span>
</span><span id="line-1882"></span><span>          </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span id="local-6989586621679199082"><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199082"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameQ"><span class="hs-identifier hs-type">NameQ</span></a></span><span> </span><span id="local-6989586621679199083"><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199083"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ModName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#modString"><span class="hs-identifier hs-var">modString</span></a></span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199083"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">OccName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#occString"><span class="hs-identifier hs-var">occString</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199082"><span class="hs-identifier hs-var">occ</span></a></span><span>
</span><span id="line-1883"></span><span>          </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span id="local-6989586621679199084"><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199084"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-type">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">PkgName
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679199085"><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199085"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ModName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#modString"><span class="hs-identifier hs-var">modString</span></a></span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199085"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">OccName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#occString"><span class="hs-identifier hs-var">occString</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199084"><span class="hs-identifier hs-var">occ</span></a></span><span>
</span><span id="line-1884"></span><span>          </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span id="local-6989586621679199086"><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199086"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameU"><span class="hs-identifier hs-type">NameU</span></a></span><span> </span><span id="local-6989586621679199087"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679199087"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#occString"><span class="hs-identifier hs-var">occString</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199086"><span class="hs-identifier hs-var">occ</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;_&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Uniq -&gt; FilePath
forall a. Show a =&gt; a -&gt; FilePath
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679199087"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-1885"></span><span>          </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span id="local-6989586621679199089"><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199089"><span class="hs-identifier hs-var">occ</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameL"><span class="hs-identifier hs-type">NameL</span></a></span><span> </span><span id="local-6989586621679199090"><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679199090"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#occString"><span class="hs-identifier hs-var">occString</span></a></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679199089"><span class="hs-identifier hs-var">occ</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;_&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Uniq -&gt; FilePath
forall a. Show a =&gt; a -&gt; FilePath
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Uniq
</span><a href="#local-6989586621679199090"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-1886"></span><span>
</span><span id="line-1887"></span><span>        </span><span id="local-6989586621679199080"><span class="annot"><span class="annottext">pnam :: Bool
</span><a href="#local-6989586621679199080"><span class="hs-identifier hs-var hs-var">pnam</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Bool
</span><a href="#local-6989586621679199091"><span class="hs-identifier hs-var">classify</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199079"><span class="hs-identifier hs-var">nms</span></a></span><span>
</span><span id="line-1888"></span><span>
</span><span id="line-1889"></span><span>        </span><span class="hs-comment">-- True if we are function style, e.g. f, [], (,)</span><span>
</span><span id="line-1890"></span><span>        </span><span class="hs-comment">-- False if we are operator style, e.g. +, :+</span><span>
</span><span id="line-1891"></span><span>        </span><span id="local-6989586621679199091"><span class="annot"><span class="annottext">classify :: FilePath -&gt; Bool
</span><a href="#local-6989586621679199091"><span class="hs-identifier hs-var hs-var">classify</span></a></span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;&quot;</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span> </span><span class="hs-comment">-- shouldn't happen; . operator is handled below</span><span>
</span><span id="line-1892"></span><span>        </span><span class="annot"><a href="#local-6989586621679199091"><span class="hs-identifier hs-var">classify</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679199095"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199095"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-type">:</span></a></span><span id="local-6989586621679199096"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199096"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">isAlpha</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199095"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%7C%7C"><span class="hs-operator hs-var">||</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679199095"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;_[]()&quot;</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1893"></span><span>                            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; FilePath -&gt; FilePath
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">dropWhile</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%2F%3D"><span class="hs-operator hs-var">/=</span></a></span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'.'</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199096"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1894"></span><span>                                  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-identifier">_</span></span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-type">:</span></a></span><span id="local-6989586621679199099"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199099"><span class="hs-identifier hs-var">xs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Bool
</span><a href="#local-6989586621679199091"><span class="hs-identifier hs-var">classify</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199099"><span class="hs-identifier hs-var">xs'</span></a></span><span>
</span><span id="line-1895"></span><span>                                  </span><span class="hs-special">[</span><span class="hs-special">]</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-1896"></span><span>                        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-1897"></span><span>
</span><span id="line-1898"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679199101"><span id="local-6989586621679199106"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1899"></span><span>  </span><span id="local-6989586621679199108"><span class="annot"><span class="annottext">show :: Name -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var">show</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#showName"><span class="hs-identifier hs-var">showName</span></a></span><span>
</span><span id="line-1900"></span><span>
</span><span id="line-1901"></span><span class="hs-comment">-- Tuple data and type constructors</span><span>
</span><span id="line-1902"></span><span class="annot"><span class="hs-comment">-- | Tuple data constructor</span></span><span>
</span><span id="line-1903"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#tupleDataName"><span class="hs-identifier hs-type">tupleDataName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1904"></span><span class="annot"><span class="hs-comment">-- | Tuple type constructor</span></span><span>
</span><span id="line-1905"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#tupleTypeName"><span class="hs-identifier hs-type">tupleTypeName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1906"></span><span>
</span><span id="line-1907"></span><span id="tupleDataName"><span class="annot"><span class="annottext">tupleDataName :: Int -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#tupleDataName"><span class="hs-identifier hs-var hs-var">tupleDataName</span></a></span></span><span> </span><span id="local-6989586621679199110"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199110"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; NameSpace -&gt; Bool -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mk_tup_name"><span class="hs-identifier hs-var">mk_tup_name</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199110"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span>  </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-1908"></span><span id="tupleTypeName"><span class="annot"><span class="annottext">tupleTypeName :: Int -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#tupleTypeName"><span class="hs-identifier hs-var hs-var">tupleTypeName</span></a></span></span><span> </span><span id="local-6989586621679199112"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199112"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; NameSpace -&gt; Bool -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mk_tup_name"><span class="hs-identifier hs-var">mk_tup_name</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199112"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#TcClsName"><span class="hs-identifier hs-var">TcClsName</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-1909"></span><span>
</span><span id="line-1910"></span><span class="hs-comment">-- Unboxed tuple data and type constructors</span><span>
</span><span id="line-1911"></span><span class="annot"><span class="hs-comment">-- | Unboxed tuple data constructor</span></span><span>
</span><span id="line-1912"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#unboxedTupleDataName"><span class="hs-identifier hs-type">unboxedTupleDataName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1913"></span><span class="annot"><span class="hs-comment">-- | Unboxed tuple type constructor</span></span><span>
</span><span id="line-1914"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#unboxedTupleTypeName"><span class="hs-identifier hs-type">unboxedTupleTypeName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1915"></span><span>
</span><span id="line-1916"></span><span id="unboxedTupleDataName"><span class="annot"><span class="annottext">unboxedTupleDataName :: Int -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#unboxedTupleDataName"><span class="hs-identifier hs-var hs-var">unboxedTupleDataName</span></a></span></span><span> </span><span id="local-6989586621679199114"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199114"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; NameSpace -&gt; Bool -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mk_tup_name"><span class="hs-identifier hs-var">mk_tup_name</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199114"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span>  </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-1917"></span><span id="unboxedTupleTypeName"><span class="annot"><span class="annottext">unboxedTupleTypeName :: Int -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#unboxedTupleTypeName"><span class="hs-identifier hs-var hs-var">unboxedTupleTypeName</span></a></span></span><span> </span><span id="local-6989586621679199115"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199115"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; NameSpace -&gt; Bool -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mk_tup_name"><span class="hs-identifier hs-var">mk_tup_name</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199115"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#TcClsName"><span class="hs-identifier hs-var">TcClsName</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-1918"></span><span>
</span><span id="line-1919"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#mk_tup_name"><span class="hs-identifier hs-type">mk_tup_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NameSpace"><span class="hs-identifier hs-type">NameSpace</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1920"></span><span id="mk_tup_name"><span class="annot"><span class="annottext">mk_tup_name :: Int -&gt; NameSpace -&gt; Bool -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#mk_tup_name"><span class="hs-identifier hs-var hs-var">mk_tup_name</span></a></span></span><span> </span><span id="local-6989586621679199116"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199116"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679199117"><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199117"><span class="hs-identifier hs-var">space</span></a></span></span><span> </span><span id="local-6989586621679199118"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679199118"><span class="hs-identifier hs-var">boxed</span></a></span></span><span>
</span><span id="line-1921"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199119"><span class="hs-identifier hs-var">tup_occ</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSpace -&gt; PkgName -&gt; ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-var">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199117"><span class="hs-identifier hs-var">space</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-var">mkPkgName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;ghc-prim&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679199120"><span class="hs-identifier hs-var">tup_mod</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1922"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1923"></span><span>    </span><span id="local-6989586621679199121"><span class="annot"><span class="annottext">withParens :: FilePath -&gt; FilePath
</span><a href="#local-6989586621679199121"><span class="hs-identifier hs-var hs-var">withParens</span></a></span></span><span> </span><span id="local-6989586621679199122"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199122"><span class="hs-identifier hs-var">thing</span></a></span></span><span>
</span><span id="line-1924"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679199118"><span class="hs-identifier hs-var">boxed</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;(&quot;</span></span><span>  </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199122"><span class="hs-identifier hs-var">thing</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;)&quot;</span></span><span>
</span><span id="line-1925"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;(#&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199122"><span class="hs-identifier hs-var">thing</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;#)&quot;</span></span><span>
</span><span id="line-1926"></span><span>    </span><span id="local-6989586621679199119"><span class="annot"><span class="annottext">tup_occ :: FilePath
</span><a href="#local-6989586621679199119"><span class="hs-identifier hs-var hs-var">tup_occ</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199116"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199117"><span class="hs-identifier hs-var">space</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; NameSpace -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#TcClsName"><span class="hs-identifier hs-var">TcClsName</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679199118"><span class="hs-identifier hs-var">boxed</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Unit&quot;</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Unit#&quot;</span></span><span>
</span><span id="line-1927"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199116"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679199118"><span class="hs-identifier hs-var">boxed</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199123"><span class="hs-identifier hs-var">solo</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199124"><span class="hs-identifier hs-var">unboxed_solo</span></a></span><span>
</span><span id="line-1928"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199117"><span class="hs-identifier hs-var">space</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; NameSpace -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#TcClsName"><span class="hs-identifier hs-var">TcClsName</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Tuple&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; FilePath
forall a. Show a =&gt; a -&gt; FilePath
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199116"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679199118"><span class="hs-identifier hs-var">boxed</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;&quot;</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;#&quot;</span></span><span>
</span><span id="line-1929"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath
</span><a href="#local-6989586621679199121"><span class="hs-identifier hs-var">withParens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Char -&gt; FilePath
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199126"><span class="hs-identifier hs-var">n_commas</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">','</span></span><span class="hs-special">)</span><span>
</span><span id="line-1930"></span><span>    </span><span id="local-6989586621679199126"><span class="annot"><span class="annottext">n_commas :: Int
</span><a href="#local-6989586621679199126"><span class="hs-identifier hs-var hs-var">n_commas</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199116"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-1931"></span><span>    </span><span id="local-6989586621679199120"><span class="annot"><span class="annottext">tup_mod :: ModName
</span><a href="#local-6989586621679199120"><span class="hs-identifier hs-var hs-var">tup_mod</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679199118"><span class="hs-identifier hs-var">boxed</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;GHC.Tuple&quot;</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;GHC.Types&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1932"></span><span>    </span><span id="local-6989586621679199123"><span class="annot"><span class="annottext">solo :: FilePath
</span><a href="#local-6989586621679199123"><span class="hs-identifier hs-var hs-var">solo</span></a></span></span><span>
</span><span id="line-1933"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199117"><span class="hs-identifier hs-var">space</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; NameSpace -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;MkSolo&quot;</span></span><span>
</span><span id="line-1934"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Solo&quot;</span></span><span>
</span><span id="line-1935"></span><span>
</span><span id="line-1936"></span><span>    </span><span id="local-6989586621679199124"><span class="annot"><span class="annottext">unboxed_solo :: FilePath
</span><a href="#local-6989586621679199124"><span class="hs-identifier hs-var hs-var">unboxed_solo</span></a></span></span><span>
</span><span id="line-1937"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="#local-6989586621679199117"><span class="hs-identifier hs-var">space</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace -&gt; NameSpace -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;(# #)&quot;</span></span><span>
</span><span id="line-1938"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Solo#&quot;</span></span><span>
</span><span id="line-1939"></span><span>
</span><span id="line-1940"></span><span class="hs-comment">-- Unboxed sum data and type constructors</span><span>
</span><span id="line-1941"></span><span class="annot"><span class="hs-comment">-- | Unboxed sum data constructor</span></span><span>
</span><span id="line-1942"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#unboxedSumDataName"><span class="hs-identifier hs-type">unboxedSumDataName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumAlt"><span class="hs-identifier hs-type">SumAlt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumArity"><span class="hs-identifier hs-type">SumArity</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1943"></span><span class="annot"><span class="hs-comment">-- | Unboxed sum type constructor</span></span><span>
</span><span id="line-1944"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#unboxedSumTypeName"><span class="hs-identifier hs-type">unboxedSumTypeName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumArity"><span class="hs-identifier hs-type">SumArity</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1945"></span><span>
</span><span id="line-1946"></span><span id="unboxedSumDataName"><span class="annot"><span class="annottext">unboxedSumDataName :: Int -&gt; Int -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#unboxedSumDataName"><span class="hs-identifier hs-var hs-var">unboxedSumDataName</span></a></span></span><span> </span><span id="local-6989586621679199131"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199131"><span class="hs-identifier hs-var">alt</span></a></span></span><span> </span><span id="local-6989586621679199132"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199132"><span class="hs-identifier hs-var">arity</span></a></span></span><span>
</span><span id="line-1947"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199131"><span class="hs-identifier hs-var">alt</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3E"><span class="hs-operator hs-var">&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199132"><span class="hs-identifier hs-var">arity</span></a></span><span>
</span><span id="line-1948"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Name
forall a. HasCallStack =&gt; FilePath -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Name) -&gt; FilePath -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199133"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Index out of bounds.&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199134"><span class="hs-identifier hs-var">debug_info</span></a></span><span>
</span><span id="line-1949"></span><span>
</span><span id="line-1950"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199131"><span class="hs-identifier hs-var">alt</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3C%3D"><span class="hs-operator hs-var">&lt;=</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-1951"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Name
forall a. HasCallStack =&gt; FilePath -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Name) -&gt; FilePath -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199133"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Alt must be &gt; 0.&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199134"><span class="hs-identifier hs-var">debug_info</span></a></span><span>
</span><span id="line-1952"></span><span>
</span><span id="line-1953"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199132"><span class="hs-identifier hs-var">arity</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3C"><span class="hs-operator hs-var">&lt;</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span>
</span><span id="line-1954"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Name
forall a. HasCallStack =&gt; FilePath -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Name) -&gt; FilePath -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199133"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Arity must be &gt;= 2.&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199134"><span class="hs-identifier hs-var">debug_info</span></a></span><span>
</span><span id="line-1955"></span><span>
</span><span id="line-1956"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1957"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199135"><span class="hs-identifier hs-var">sum_occ</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1958"></span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSpace -&gt; PkgName -&gt; ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-var">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#DataName"><span class="hs-identifier hs-var">DataName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-var">mkPkgName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;ghc-prim&quot;</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;GHC.Types&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1959"></span><span>
</span><span id="line-1960"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1961"></span><span>    </span><span id="local-6989586621679199133"><span class="annot"><span class="annottext">prefix :: FilePath
</span><a href="#local-6989586621679199133"><span class="hs-identifier hs-var hs-var">prefix</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;unboxedSumDataName: &quot;</span></span><span>
</span><span id="line-1962"></span><span>    </span><span id="local-6989586621679199134"><span class="annot"><span class="annottext">debug_info :: FilePath
</span><a href="#local-6989586621679199134"><span class="hs-identifier hs-var hs-var">debug_info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot; (alt: &quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; FilePath
forall a. Show a =&gt; a -&gt; FilePath
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199131"><span class="hs-identifier hs-var">alt</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;, arity: &quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; FilePath
forall a. Show a =&gt; a -&gt; FilePath
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199132"><span class="hs-identifier hs-var">arity</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;)&quot;</span></span><span>
</span><span id="line-1963"></span><span>
</span><span id="line-1964"></span><span>    </span><span class="hs-comment">-- Synced with the definition of mkSumDataConOcc in GHC.Builtin.Types</span><span>
</span><span id="line-1965"></span><span>    </span><span id="local-6989586621679199135"><span class="annot"><span class="annottext">sum_occ :: FilePath
</span><a href="#local-6989586621679199135"><span class="hs-identifier hs-var hs-var">sum_occ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'('</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; FilePath -&gt; FilePath
forall a. a -&gt; [a] -&gt; [a]
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-var">:</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'#'</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; FilePath -&gt; FilePath
forall a. a -&gt; [a] -&gt; [a]
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-var">:</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; FilePath
</span><a href="#local-6989586621679199136"><span class="hs-identifier hs-var">bars</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199137"><span class="hs-identifier hs-var">nbars_before</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'_'</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; FilePath -&gt; FilePath
forall a. a -&gt; [a] -&gt; [a]
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#%3A"><span class="hs-glyph hs-var">:</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; FilePath
</span><a href="#local-6989586621679199136"><span class="hs-identifier hs-var">bars</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199138"><span class="hs-identifier hs-var">nbars_after</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;#)&quot;</span></span><span>
</span><span id="line-1966"></span><span>    </span><span id="local-6989586621679199136"><span class="annot"><span class="annottext">bars :: Int -&gt; FilePath
</span><a href="#local-6989586621679199136"><span class="hs-identifier hs-var hs-var">bars</span></a></span></span><span> </span><span id="local-6989586621679199139"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199139"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Char -&gt; FilePath
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199139"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'|'</span></span><span>
</span><span id="line-1967"></span><span>    </span><span id="local-6989586621679199137"><span class="annot"><span class="annottext">nbars_before :: Int
</span><a href="#local-6989586621679199137"><span class="hs-identifier hs-var hs-var">nbars_before</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199131"><span class="hs-identifier hs-var">alt</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-1968"></span><span>    </span><span id="local-6989586621679199138"><span class="annot"><span class="annottext">nbars_after :: Int
</span><a href="#local-6989586621679199138"><span class="hs-identifier hs-var hs-var">nbars_after</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199132"><span class="hs-identifier hs-var">arity</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199131"><span class="hs-identifier hs-var">alt</span></a></span><span>
</span><span id="line-1969"></span><span>
</span><span id="line-1970"></span><span id="unboxedSumTypeName"><span class="annot"><span class="annottext">unboxedSumTypeName :: Int -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#unboxedSumTypeName"><span class="hs-identifier hs-var hs-var">unboxedSumTypeName</span></a></span></span><span> </span><span id="local-6989586621679199140"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199140"><span class="hs-identifier hs-var">arity</span></a></span></span><span>
</span><span id="line-1971"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199140"><span class="hs-identifier hs-var">arity</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3C"><span class="hs-operator hs-var">&lt;</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span>
</span><span id="line-1972"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Name
forall a. HasCallStack =&gt; FilePath -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Name) -&gt; FilePath -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;unboxedSumTypeName: Arity must be &gt;= 2.&quot;</span></span><span>
</span><span id="line-1973"></span><span>         </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot; (arity: &quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; FilePath
forall a. Show a =&gt; a -&gt; FilePath
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199140"><span class="hs-identifier hs-var">arity</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;)&quot;</span></span><span>
</span><span id="line-1974"></span><span>
</span><span id="line-1975"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1976"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName -&gt; NameFlavour -&gt; Name
</span><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; OccName
</span><a href="Language.Haskell.TH.Syntax.html#mkOccName"><span class="hs-identifier hs-var">mkOccName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679199141"><span class="hs-identifier hs-var">sum_occ</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1977"></span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSpace -&gt; PkgName -&gt; ModName -&gt; NameFlavour
</span><a href="Language.Haskell.TH.Syntax.html#NameG"><span class="hs-identifier hs-var">NameG</span></a></span><span> </span><span class="annot"><span class="annottext">NameSpace
</span><a href="Language.Haskell.TH.Syntax.html#TcClsName"><span class="hs-identifier hs-var">TcClsName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; PkgName
</span><a href="Language.Haskell.TH.Syntax.html#mkPkgName"><span class="hs-identifier hs-var">mkPkgName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;ghc-prim&quot;</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; ModName
</span><a href="Language.Haskell.TH.Syntax.html#mkModName"><span class="hs-identifier hs-var">mkModName</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;GHC.Types&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1978"></span><span>
</span><span id="line-1979"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1980"></span><span>    </span><span class="hs-comment">-- Synced with the definition of mkSumTyConOcc in GHC.Builtin.Types</span><span>
</span><span id="line-1981"></span><span>    </span><span id="local-6989586621679199141"><span class="annot"><span class="annottext">sum_occ :: FilePath
</span><a href="#local-6989586621679199141"><span class="hs-identifier hs-var hs-var">sum_occ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;Sum&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; FilePath
forall a. Show a =&gt; a -&gt; FilePath
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679199140"><span class="hs-identifier hs-var">arity</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><span class="hs-string">&quot;#&quot;</span></span><span>
</span><span id="line-1982"></span><span>
</span><span id="line-1983"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1984"></span><span class="hs-comment">--              Locations</span><span>
</span><span id="line-1985"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1986"></span><span>
</span><span id="line-1987"></span><span class="hs-keyword">data</span><span> </span><span id="Loc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Loc"><span class="hs-identifier hs-var">Loc</span></a></span></span><span>
</span><span id="line-1988"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Loc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Loc"><span class="hs-identifier hs-var">Loc</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="loc_filename"><span class="annot"><span class="annottext">Loc -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#loc_filename"><span class="hs-identifier hs-var hs-var">loc_filename</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1989"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="loc_package"><span class="annot"><span class="annottext">Loc -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#loc_package"><span class="hs-identifier hs-var hs-var">loc_package</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1990"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="loc_module"><span class="annot"><span class="annottext">Loc -&gt; FilePath
</span><a href="Language.Haskell.TH.Syntax.html#loc_module"><span class="hs-identifier hs-var hs-var">loc_module</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1991"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="loc_start"><span class="annot"><span class="annottext">Loc -&gt; CharPos
</span><a href="Language.Haskell.TH.Syntax.html#loc_start"><span class="hs-identifier hs-var hs-var">loc_start</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CharPos"><span class="hs-identifier hs-type">CharPos</span></a></span><span>
</span><span id="line-1992"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="loc_end"><span class="annot"><span class="annottext">Loc -&gt; CharPos
</span><a href="Language.Haskell.TH.Syntax.html#loc_end"><span class="hs-identifier hs-var hs-var">loc_end</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CharPos"><span class="hs-identifier hs-type">CharPos</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1993"></span><span>   </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679199149"><span id="local-6989586621679199159"><span id="local-6989586621679199163"><span class="annot"><span class="annottext">Int -&gt; Loc -&gt; FilePath -&gt; FilePath
[Loc] -&gt; FilePath -&gt; FilePath
Loc -&gt; FilePath
(Int -&gt; Loc -&gt; FilePath -&gt; FilePath)
-&gt; (Loc -&gt; FilePath) -&gt; ([Loc] -&gt; FilePath -&gt; FilePath) -&gt; Show Loc
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Loc -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Loc -&gt; FilePath -&gt; FilePath
$cshow :: Loc -&gt; FilePath
show :: Loc -&gt; FilePath
$cshowList :: [Loc] -&gt; FilePath -&gt; FilePath
showList :: [Loc] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199166"><span id="local-6989586621679199175"><span class="annot"><span class="annottext">Loc -&gt; Loc -&gt; Bool
(Loc -&gt; Loc -&gt; Bool) -&gt; (Loc -&gt; Loc -&gt; Bool) -&gt; Eq Loc
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Loc -&gt; Loc -&gt; Bool
== :: Loc -&gt; Loc -&gt; Bool
$c/= :: Loc -&gt; Loc -&gt; Bool
/= :: Loc -&gt; Loc -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199181"><span id="local-6989586621679199190"><span id="local-6989586621679199198"><span id="local-6989586621679199202"><span id="local-6989586621679199205"><span id="local-6989586621679199208"><span id="local-6989586621679199211"><span class="annot"><span class="annottext">Eq Loc
Eq Loc =&gt;
(Loc -&gt; Loc -&gt; Ordering)
-&gt; (Loc -&gt; Loc -&gt; Bool)
-&gt; (Loc -&gt; Loc -&gt; Bool)
-&gt; (Loc -&gt; Loc -&gt; Bool)
-&gt; (Loc -&gt; Loc -&gt; Bool)
-&gt; (Loc -&gt; Loc -&gt; Loc)
-&gt; (Loc -&gt; Loc -&gt; Loc)
-&gt; Ord Loc
Loc -&gt; Loc -&gt; Bool
Loc -&gt; Loc -&gt; Ordering
Loc -&gt; Loc -&gt; Loc
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Loc -&gt; Loc -&gt; Ordering
compare :: Loc -&gt; Loc -&gt; Ordering
$c&lt; :: Loc -&gt; Loc -&gt; Bool
&lt; :: Loc -&gt; Loc -&gt; Bool
$c&lt;= :: Loc -&gt; Loc -&gt; Bool
&lt;= :: Loc -&gt; Loc -&gt; Bool
$c&gt; :: Loc -&gt; Loc -&gt; Bool
&gt; :: Loc -&gt; Loc -&gt; Bool
$c&gt;= :: Loc -&gt; Loc -&gt; Bool
&gt;= :: Loc -&gt; Loc -&gt; Bool
$cmax :: Loc -&gt; Loc -&gt; Loc
max :: Loc -&gt; Loc -&gt; Loc
$cmin :: Loc -&gt; Loc -&gt; Loc
min :: Loc -&gt; Loc -&gt; Loc
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199216"><span id="local-6989586621679199227"><span id="local-6989586621679199237"><span id="local-6989586621679199239"><span id="local-6989586621679199241"><span id="local-6989586621679199247"><span id="local-6989586621679199252"><span id="local-6989586621679199255"><span id="local-6989586621679199258"><span id="local-6989586621679199261"><span id="local-6989586621679199264"><span id="local-6989586621679199267"><span id="local-6989586621679199272"><span id="local-6989586621679199277"><span class="annot"><span class="annottext">Typeable Loc
Typeable Loc =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Loc -&gt; c Loc)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Loc)
-&gt; (Loc -&gt; Constr)
-&gt; (Loc -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Loc))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Loc))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Loc -&gt; Loc)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Loc -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Loc -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Loc -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Loc -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc)
-&gt; Data Loc
Loc -&gt; Constr
Loc -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Loc -&gt; Loc
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Loc -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Loc -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Loc -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Loc -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Loc
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Loc -&gt; c Loc
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Loc)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Loc)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Loc -&gt; c Loc
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Loc -&gt; c Loc
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Loc
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Loc
$ctoConstr :: Loc -&gt; Constr
toConstr :: Loc -&gt; Constr
$cdataTypeOf :: Loc -&gt; DataType
dataTypeOf :: Loc -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Loc)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Loc)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Loc)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Loc)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Loc -&gt; Loc
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Loc -&gt; Loc
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Loc -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Loc -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Loc -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Loc -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Loc -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Loc -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Loc -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Loc -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Loc -&gt; m Loc
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199283"><span id="local-6989586621679199285"><span class="annot"><span class="annottext">(forall x. Loc -&gt; Rep Loc x)
-&gt; (forall x. Rep Loc x -&gt; Loc) -&gt; Generic Loc
forall x. Rep Loc x -&gt; Loc
forall x. Loc -&gt; Rep Loc x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Loc -&gt; Rep Loc x
from :: forall x. Loc -&gt; Rep Loc x
$cto :: forall x. Rep Loc x -&gt; Loc
to :: forall x. Rep Loc x -&gt; Loc
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-1994"></span><span>
</span><span id="line-1995"></span><span class="hs-keyword">type</span><span> </span><span id="CharPos"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CharPos"><span class="hs-identifier hs-var">CharPos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Line and character position</span></span><span>
</span><span id="line-1996"></span><span>
</span><span id="line-1997"></span><span>
</span><span id="line-1998"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-1999"></span><span class="hs-comment">--</span><span>
</span><span id="line-2000"></span><span class="hs-comment">--      The Info returned by reification</span><span>
</span><span id="line-2001"></span><span class="hs-comment">--</span><span>
</span><span id="line-2002"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-2003"></span><span>
</span><span id="line-2004"></span><span class="annot"><span class="hs-comment">-- | Obtained from 'reify' in the 'Q' Monad.</span></span><span>
</span><span id="line-2005"></span><span class="hs-keyword">data</span><span> </span><span id="Info"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Info"><span class="hs-identifier hs-var">Info</span></a></span></span><span>
</span><span id="line-2006"></span><span>  </span><span class="hs-glyph">=</span><span>
</span><span id="line-2007"></span><span>  </span><span class="annot"><span class="hs-comment">-- | A class, with a list of its visible instances</span></span><span>
</span><span id="line-2008"></span><span>  </span><span id="ClassI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ClassI"><span class="hs-identifier hs-var">ClassI</span></a></span></span><span>
</span><span id="line-2009"></span><span>      </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span>
</span><span id="line-2010"></span><span>      </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InstanceDec"><span class="hs-identifier hs-type">InstanceDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2011"></span><span>
</span><span id="line-2012"></span><span>  </span><span class="annot"><span class="hs-comment">-- | A class method</span></span><span>
</span><span id="line-2013"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ClassOpI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ClassOpI"><span class="hs-identifier hs-var">ClassOpI</span></a></span></span><span>
</span><span id="line-2014"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2015"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2016"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ParentName"><span class="hs-identifier hs-type">ParentName</span></a></span><span>
</span><span id="line-2017"></span><span>
</span><span id="line-2018"></span><span>  </span><span class="hs-comment">-- | A \&quot;plain\&quot; type constructor. \&quot;Fancier\&quot; type constructors are returned</span><span>
</span><span id="line-2019"></span><span>  </span><span class="hs-comment">-- using 'PrimTyConI' or 'FamilyI' as appropriate. At present, this reified</span><span>
</span><span id="line-2020"></span><span>  </span><span class="hs-comment">-- declaration will never have derived instances attached to it (if you wish</span><span>
</span><span id="line-2021"></span><span>  </span><span class="hs-comment">-- to check for an instance, see 'reifyInstances').</span><span>
</span><span id="line-2022"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TyConI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyConI"><span class="hs-identifier hs-var">TyConI</span></a></span></span><span>
</span><span id="line-2023"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span>
</span><span id="line-2024"></span><span>
</span><span id="line-2025"></span><span>  </span><span class="hs-comment">-- | A type or data family, with a list of its visible instances. A closed</span><span>
</span><span id="line-2026"></span><span>  </span><span class="hs-comment">-- type family is returned with 0 instances.</span><span>
</span><span id="line-2027"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FamilyI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FamilyI"><span class="hs-identifier hs-var">FamilyI</span></a></span></span><span>
</span><span id="line-2028"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span>
</span><span id="line-2029"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InstanceDec"><span class="hs-identifier hs-type">InstanceDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2030"></span><span>
</span><span id="line-2031"></span><span>  </span><span class="hs-comment">-- | A \&quot;primitive\&quot; type constructor, which can't be expressed with a 'Dec'.</span><span>
</span><span id="line-2032"></span><span>  </span><span class="hs-comment">-- Examples: @(-&gt;)@, @Int#@.</span><span>
</span><span id="line-2033"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PrimTyConI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PrimTyConI"><span class="hs-identifier hs-var">PrimTyConI</span></a></span></span><span>
</span><span id="line-2034"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2035"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Arity"><span class="hs-identifier hs-type">Arity</span></a></span><span>
</span><span id="line-2036"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Unlifted"><span class="hs-identifier hs-type">Unlifted</span></a></span><span>
</span><span id="line-2037"></span><span>
</span><span id="line-2038"></span><span>  </span><span class="annot"><span class="hs-comment">-- | A data constructor</span></span><span>
</span><span id="line-2039"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataConI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DataConI"><span class="hs-identifier hs-var">DataConI</span></a></span></span><span>
</span><span id="line-2040"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2041"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2042"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ParentName"><span class="hs-identifier hs-type">ParentName</span></a></span><span>
</span><span id="line-2043"></span><span>
</span><span id="line-2044"></span><span>  </span><span class="annot"><span class="hs-comment">-- | A pattern synonym</span></span><span>
</span><span id="line-2045"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSynI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynI"><span class="hs-identifier hs-var">PatSynI</span></a></span></span><span>
</span><span id="line-2046"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2047"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynType"><span class="hs-identifier hs-type">PatSynType</span></a></span><span>
</span><span id="line-2048"></span><span>
</span><span id="line-2049"></span><span>  </span><span class="annot"><span class="hs-comment">{- |
  A \&quot;value\&quot; variable (as opposed to a type variable, see 'TyVarI').

  The @Maybe Dec@ field contains @Just@ the declaration which
  defined the variable - including the RHS of the declaration -
  or else @Nothing@, in the case where the RHS is unavailable to
  the compiler. At present, this value is /always/ @Nothing@:
  returning the RHS has not yet been implemented because of
  lack of interest.
  -}</span></span><span>
</span><span id="line-2059"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="VarI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarI"><span class="hs-identifier hs-var">VarI</span></a></span></span><span>
</span><span id="line-2060"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2061"></span><span>       </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2062"></span><span>       </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2063"></span><span>
</span><span id="line-2064"></span><span>  </span><span class="annot"><span class="hs-comment">{- |
  A type variable.

  The @Type@ field contains the type which underlies the variable.
  At present, this is always @'VarT' theName@, but future changes
  may permit refinement of this.
  -}</span></span><span>
</span><span id="line-2071"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TyVarI"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarI"><span class="hs-identifier hs-var">TyVarI</span></a></span></span><span>      </span><span class="hs-comment">-- Scoped type variable</span><span>
</span><span id="line-2072"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2073"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>    </span><span class="hs-comment">-- What it is bound to</span><span>
</span><span id="line-2074"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679199301"><span id="local-6989586621679199337"><span id="local-6989586621679199341"><span class="annot"><span class="annottext">Int -&gt; Info -&gt; FilePath -&gt; FilePath
[Info] -&gt; FilePath -&gt; FilePath
Info -&gt; FilePath
(Int -&gt; Info -&gt; FilePath -&gt; FilePath)
-&gt; (Info -&gt; FilePath)
-&gt; ([Info] -&gt; FilePath -&gt; FilePath)
-&gt; Show Info
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Info -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Info -&gt; FilePath -&gt; FilePath
$cshow :: Info -&gt; FilePath
show :: Info -&gt; FilePath
$cshowList :: [Info] -&gt; FilePath -&gt; FilePath
showList :: [Info] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199344"><span id="local-6989586621679199373"><span class="annot"><span class="annottext">Info -&gt; Info -&gt; Bool
(Info -&gt; Info -&gt; Bool) -&gt; (Info -&gt; Info -&gt; Bool) -&gt; Eq Info
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Info -&gt; Info -&gt; Bool
== :: Info -&gt; Info -&gt; Bool
$c/= :: Info -&gt; Info -&gt; Bool
/= :: Info -&gt; Info -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199379"><span id="local-6989586621679199411"><span id="local-6989586621679199415"><span id="local-6989586621679199418"><span id="local-6989586621679199421"><span id="local-6989586621679199424"><span id="local-6989586621679199427"><span class="annot"><span class="annottext">Eq Info
Eq Info =&gt;
(Info -&gt; Info -&gt; Ordering)
-&gt; (Info -&gt; Info -&gt; Bool)
-&gt; (Info -&gt; Info -&gt; Bool)
-&gt; (Info -&gt; Info -&gt; Bool)
-&gt; (Info -&gt; Info -&gt; Bool)
-&gt; (Info -&gt; Info -&gt; Info)
-&gt; (Info -&gt; Info -&gt; Info)
-&gt; Ord Info
Info -&gt; Info -&gt; Bool
Info -&gt; Info -&gt; Ordering
Info -&gt; Info -&gt; Info
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Info -&gt; Info -&gt; Ordering
compare :: Info -&gt; Info -&gt; Ordering
$c&lt; :: Info -&gt; Info -&gt; Bool
&lt; :: Info -&gt; Info -&gt; Bool
$c&lt;= :: Info -&gt; Info -&gt; Bool
&lt;= :: Info -&gt; Info -&gt; Bool
$c&gt; :: Info -&gt; Info -&gt; Bool
&gt; :: Info -&gt; Info -&gt; Bool
$c&gt;= :: Info -&gt; Info -&gt; Bool
&gt;= :: Info -&gt; Info -&gt; Bool
$cmax :: Info -&gt; Info -&gt; Info
max :: Info -&gt; Info -&gt; Info
$cmin :: Info -&gt; Info -&gt; Info
min :: Info -&gt; Info -&gt; Info
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199432"><span id="local-6989586621679199459"><span id="local-6989586621679199483"><span id="local-6989586621679199485"><span id="local-6989586621679199487"><span id="local-6989586621679199493"><span id="local-6989586621679199498"><span id="local-6989586621679199501"><span id="local-6989586621679199504"><span id="local-6989586621679199507"><span id="local-6989586621679199510"><span id="local-6989586621679199513"><span id="local-6989586621679199518"><span id="local-6989586621679199523"><span class="annot"><span class="annottext">Typeable Info
Typeable Info =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Info -&gt; c Info)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Info)
-&gt; (Info -&gt; Constr)
-&gt; (Info -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Info))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Info))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Info -&gt; Info)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Info -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Info -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Info -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Info -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info)
-&gt; Data Info
Info -&gt; Constr
Info -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Info -&gt; Info
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Info -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Info -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Info -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Info -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Info
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Info -&gt; c Info
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Info)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Info)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Info -&gt; c Info
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Info -&gt; c Info
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Info
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Info
$ctoConstr :: Info -&gt; Constr
toConstr :: Info -&gt; Constr
$cdataTypeOf :: Info -&gt; DataType
dataTypeOf :: Info -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Info)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Info)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Info)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Info)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Info -&gt; Info
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Info -&gt; Info
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Info -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Info -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Info -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Info -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Info -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Info -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Info -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Info -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Info -&gt; m Info
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199529"><span id="local-6989586621679199531"><span class="annot"><span class="annottext">(forall x. Info -&gt; Rep Info x)
-&gt; (forall x. Rep Info x -&gt; Info) -&gt; Generic Info
forall x. Rep Info x -&gt; Info
forall x. Info -&gt; Rep Info x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Info -&gt; Rep Info x
from :: forall x. Info -&gt; Rep Info x
$cto :: forall x. Rep Info x -&gt; Info
to :: forall x. Rep Info x -&gt; Info
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2075"></span><span>
</span><span id="line-2076"></span><span class="annot"><span class="hs-comment">-- | Obtained from 'reifyModule' in the 'Q' Monad.</span></span><span>
</span><span id="line-2077"></span><span class="hs-keyword">data</span><span> </span><span id="ModuleInfo"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModuleInfo"><span class="hs-identifier hs-var">ModuleInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2078"></span><span>  </span><span class="annot"><span class="hs-comment">-- | Contains the import list of the module.</span></span><span>
</span><span id="line-2079"></span><span>  </span><span id="ModuleInfo"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModuleInfo"><span class="hs-identifier hs-var">ModuleInfo</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2080"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679199535"><span id="local-6989586621679199540"><span id="local-6989586621679199544"><span class="annot"><span class="annottext">Int -&gt; ModuleInfo -&gt; FilePath -&gt; FilePath
[ModuleInfo] -&gt; FilePath -&gt; FilePath
ModuleInfo -&gt; FilePath
(Int -&gt; ModuleInfo -&gt; FilePath -&gt; FilePath)
-&gt; (ModuleInfo -&gt; FilePath)
-&gt; ([ModuleInfo] -&gt; FilePath -&gt; FilePath)
-&gt; Show ModuleInfo
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; ModuleInfo -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; ModuleInfo -&gt; FilePath -&gt; FilePath
$cshow :: ModuleInfo -&gt; FilePath
show :: ModuleInfo -&gt; FilePath
$cshowList :: [ModuleInfo] -&gt; FilePath -&gt; FilePath
showList :: [ModuleInfo] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199547"><span id="local-6989586621679199551"><span class="annot"><span class="annottext">ModuleInfo -&gt; ModuleInfo -&gt; Bool
(ModuleInfo -&gt; ModuleInfo -&gt; Bool)
-&gt; (ModuleInfo -&gt; ModuleInfo -&gt; Bool) -&gt; Eq ModuleInfo
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
== :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
$c/= :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
/= :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199557"><span id="local-6989586621679199561"><span id="local-6989586621679199565"><span id="local-6989586621679199569"><span id="local-6989586621679199572"><span id="local-6989586621679199575"><span id="local-6989586621679199578"><span class="annot"><span class="annottext">Eq ModuleInfo
Eq ModuleInfo =&gt;
(ModuleInfo -&gt; ModuleInfo -&gt; Ordering)
-&gt; (ModuleInfo -&gt; ModuleInfo -&gt; Bool)
-&gt; (ModuleInfo -&gt; ModuleInfo -&gt; Bool)
-&gt; (ModuleInfo -&gt; ModuleInfo -&gt; Bool)
-&gt; (ModuleInfo -&gt; ModuleInfo -&gt; Bool)
-&gt; (ModuleInfo -&gt; ModuleInfo -&gt; ModuleInfo)
-&gt; (ModuleInfo -&gt; ModuleInfo -&gt; ModuleInfo)
-&gt; Ord ModuleInfo
ModuleInfo -&gt; ModuleInfo -&gt; Bool
ModuleInfo -&gt; ModuleInfo -&gt; Ordering
ModuleInfo -&gt; ModuleInfo -&gt; ModuleInfo
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: ModuleInfo -&gt; ModuleInfo -&gt; Ordering
compare :: ModuleInfo -&gt; ModuleInfo -&gt; Ordering
$c&lt; :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
&lt; :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
$c&lt;= :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
&lt;= :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
$c&gt; :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
&gt; :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
$c&gt;= :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
&gt;= :: ModuleInfo -&gt; ModuleInfo -&gt; Bool
$cmax :: ModuleInfo -&gt; ModuleInfo -&gt; ModuleInfo
max :: ModuleInfo -&gt; ModuleInfo -&gt; ModuleInfo
$cmin :: ModuleInfo -&gt; ModuleInfo -&gt; ModuleInfo
min :: ModuleInfo -&gt; ModuleInfo -&gt; ModuleInfo
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199583"><span id="local-6989586621679199587"><span id="local-6989586621679199591"><span id="local-6989586621679199593"><span id="local-6989586621679199595"><span id="local-6989586621679199601"><span id="local-6989586621679199606"><span id="local-6989586621679199609"><span id="local-6989586621679199612"><span id="local-6989586621679199615"><span id="local-6989586621679199618"><span id="local-6989586621679199621"><span id="local-6989586621679199626"><span id="local-6989586621679199631"><span class="annot"><span class="annottext">Typeable ModuleInfo
Typeable ModuleInfo =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; ModuleInfo -&gt; c ModuleInfo)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ModuleInfo)
-&gt; (ModuleInfo -&gt; Constr)
-&gt; (ModuleInfo -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ModuleInfo))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c ModuleInfo))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; ModuleInfo -&gt; ModuleInfo)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleInfo -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleInfo -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleInfo -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleInfo -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo)
-&gt; Data ModuleInfo
ModuleInfo -&gt; Constr
ModuleInfo -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; ModuleInfo -&gt; ModuleInfo
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleInfo -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleInfo -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleInfo -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleInfo -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ModuleInfo
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleInfo -&gt; c ModuleInfo
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ModuleInfo)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c ModuleInfo)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleInfo -&gt; c ModuleInfo
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleInfo -&gt; c ModuleInfo
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ModuleInfo
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ModuleInfo
$ctoConstr :: ModuleInfo -&gt; Constr
toConstr :: ModuleInfo -&gt; Constr
$cdataTypeOf :: ModuleInfo -&gt; DataType
dataTypeOf :: ModuleInfo -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ModuleInfo)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ModuleInfo)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c ModuleInfo)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c ModuleInfo)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ModuleInfo -&gt; ModuleInfo
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ModuleInfo -&gt; ModuleInfo
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleInfo -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleInfo -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleInfo -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleInfo -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleInfo -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleInfo -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleInfo -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleInfo -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleInfo -&gt; m ModuleInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199636"><span id="local-6989586621679199638"><span class="annot"><span class="annottext">(forall x. ModuleInfo -&gt; Rep ModuleInfo x)
-&gt; (forall x. Rep ModuleInfo x -&gt; ModuleInfo) -&gt; Generic ModuleInfo
forall x. Rep ModuleInfo x -&gt; ModuleInfo
forall x. ModuleInfo -&gt; Rep ModuleInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. ModuleInfo -&gt; Rep ModuleInfo x
from :: forall x. ModuleInfo -&gt; Rep ModuleInfo x
$cto :: forall x. Rep ModuleInfo x -&gt; ModuleInfo
to :: forall x. Rep ModuleInfo x -&gt; ModuleInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2081"></span><span>
</span><span id="line-2082"></span><span class="annot"><span class="hs-comment">{- |
In 'ClassOpI' and 'DataConI', name of the parent class or type
-}</span></span><span>
</span><span id="line-2085"></span><span class="hs-keyword">type</span><span> </span><span id="ParentName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ParentName"><span class="hs-identifier hs-var">ParentName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2086"></span><span>
</span><span id="line-2087"></span><span class="hs-comment">-- | In 'UnboxedSumE' and 'UnboxedSumP', the number associated with a</span><span>
</span><span id="line-2088"></span><span class="hs-comment">-- particular data constructor. 'SumAlt's are one-indexed and should never</span><span>
</span><span id="line-2089"></span><span class="hs-comment">-- exceed the value of its corresponding 'SumArity'. For example:</span><span>
</span><span id="line-2090"></span><span class="hs-comment">--</span><span>
</span><span id="line-2091"></span><span class="hs-comment">-- * @(\#_|\#)@ has 'SumAlt' 1 (out of a total 'SumArity' of 2)</span><span>
</span><span id="line-2092"></span><span class="hs-comment">--</span><span>
</span><span id="line-2093"></span><span class="hs-comment">-- * @(\#|_\#)@ has 'SumAlt' 2 (out of a total 'SumArity' of 2)</span><span>
</span><span id="line-2094"></span><span class="hs-keyword">type</span><span> </span><span id="SumAlt"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumAlt"><span class="hs-identifier hs-var">SumAlt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-2095"></span><span>
</span><span id="line-2096"></span><span class="hs-comment">-- | In 'UnboxedSumE', 'UnboxedSumT', and 'UnboxedSumP', the total number of</span><span>
</span><span id="line-2097"></span><span class="hs-comment">-- 'SumAlt's. For example, @(\#|\#)@ has a 'SumArity' of 2.</span><span>
</span><span id="line-2098"></span><span class="hs-keyword">type</span><span> </span><span id="SumArity"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumArity"><span class="hs-identifier hs-var">SumArity</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-2099"></span><span>
</span><span id="line-2100"></span><span class="annot"><span class="hs-comment">-- | In 'PrimTyConI', arity of the type constructor</span></span><span>
</span><span id="line-2101"></span><span class="hs-keyword">type</span><span> </span><span id="Arity"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Arity"><span class="hs-identifier hs-var">Arity</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-2102"></span><span>
</span><span id="line-2103"></span><span class="annot"><span class="hs-comment">-- | In 'PrimTyConI', is the type constructor unlifted?</span></span><span>
</span><span id="line-2104"></span><span class="hs-keyword">type</span><span> </span><span id="Unlifted"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Unlifted"><span class="hs-identifier hs-var">Unlifted</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-2105"></span><span>
</span><span id="line-2106"></span><span class="hs-comment">-- | 'InstanceDec' describes a single instance of a class or type function.</span><span>
</span><span id="line-2107"></span><span class="hs-comment">-- It is just a 'Dec', but guaranteed to be one of the following:</span><span>
</span><span id="line-2108"></span><span class="hs-comment">--</span><span>
</span><span id="line-2109"></span><span class="hs-comment">--   * 'InstanceD' (with empty @['Dec']@)</span><span>
</span><span id="line-2110"></span><span class="hs-comment">--</span><span>
</span><span id="line-2111"></span><span class="hs-comment">--   * 'DataInstD' or 'NewtypeInstD' (with empty derived @['Name']@)</span><span>
</span><span id="line-2112"></span><span class="hs-comment">--</span><span>
</span><span id="line-2113"></span><span class="hs-comment">--   * 'TySynInstD'</span><span>
</span><span id="line-2114"></span><span class="hs-keyword">type</span><span> </span><span id="InstanceDec"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InstanceDec"><span class="hs-identifier hs-var">InstanceDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span>
</span><span id="line-2115"></span><span>
</span><span id="line-2116"></span><span class="hs-keyword">data</span><span> </span><span id="Fixity"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Fixity"><span class="hs-identifier hs-var">Fixity</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span id="Fixity"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Fixity"><span class="hs-identifier hs-var">Fixity</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FixityDirection"><span class="hs-identifier hs-type">FixityDirection</span></a></span><span>
</span><span id="line-2117"></span><span>    </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679199647"><span id="local-6989586621679199652"><span class="annot"><span class="annottext">Fixity -&gt; Fixity -&gt; Bool
(Fixity -&gt; Fixity -&gt; Bool)
-&gt; (Fixity -&gt; Fixity -&gt; Bool) -&gt; Eq Fixity
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Fixity -&gt; Fixity -&gt; Bool
== :: Fixity -&gt; Fixity -&gt; Bool
$c/= :: Fixity -&gt; Fixity -&gt; Bool
/= :: Fixity -&gt; Fixity -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199658"><span id="local-6989586621679199663"><span id="local-6989586621679199667"><span id="local-6989586621679199671"><span id="local-6989586621679199674"><span id="local-6989586621679199677"><span id="local-6989586621679199680"><span class="annot"><span class="annottext">Eq Fixity
Eq Fixity =&gt;
(Fixity -&gt; Fixity -&gt; Ordering)
-&gt; (Fixity -&gt; Fixity -&gt; Bool)
-&gt; (Fixity -&gt; Fixity -&gt; Bool)
-&gt; (Fixity -&gt; Fixity -&gt; Bool)
-&gt; (Fixity -&gt; Fixity -&gt; Bool)
-&gt; (Fixity -&gt; Fixity -&gt; Fixity)
-&gt; (Fixity -&gt; Fixity -&gt; Fixity)
-&gt; Ord Fixity
Fixity -&gt; Fixity -&gt; Bool
Fixity -&gt; Fixity -&gt; Ordering
Fixity -&gt; Fixity -&gt; Fixity
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Fixity -&gt; Fixity -&gt; Ordering
compare :: Fixity -&gt; Fixity -&gt; Ordering
$c&lt; :: Fixity -&gt; Fixity -&gt; Bool
&lt; :: Fixity -&gt; Fixity -&gt; Bool
$c&lt;= :: Fixity -&gt; Fixity -&gt; Bool
&lt;= :: Fixity -&gt; Fixity -&gt; Bool
$c&gt; :: Fixity -&gt; Fixity -&gt; Bool
&gt; :: Fixity -&gt; Fixity -&gt; Bool
$c&gt;= :: Fixity -&gt; Fixity -&gt; Bool
&gt;= :: Fixity -&gt; Fixity -&gt; Bool
$cmax :: Fixity -&gt; Fixity -&gt; Fixity
max :: Fixity -&gt; Fixity -&gt; Fixity
$cmin :: Fixity -&gt; Fixity -&gt; Fixity
min :: Fixity -&gt; Fixity -&gt; Fixity
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199683"><span id="local-6989586621679199689"><span id="local-6989586621679199693"><span class="annot"><span class="annottext">Int -&gt; Fixity -&gt; FilePath -&gt; FilePath
[Fixity] -&gt; FilePath -&gt; FilePath
Fixity -&gt; FilePath
(Int -&gt; Fixity -&gt; FilePath -&gt; FilePath)
-&gt; (Fixity -&gt; FilePath)
-&gt; ([Fixity] -&gt; FilePath -&gt; FilePath)
-&gt; Show Fixity
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Fixity -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Fixity -&gt; FilePath -&gt; FilePath
$cshow :: Fixity -&gt; FilePath
show :: Fixity -&gt; FilePath
$cshowList :: [Fixity] -&gt; FilePath -&gt; FilePath
showList :: [Fixity] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199698"><span id="local-6989586621679199703"><span id="local-6989586621679199707"><span id="local-6989586621679199709"><span id="local-6989586621679199711"><span id="local-6989586621679199717"><span id="local-6989586621679199722"><span id="local-6989586621679199725"><span id="local-6989586621679199728"><span id="local-6989586621679199731"><span id="local-6989586621679199734"><span id="local-6989586621679199737"><span id="local-6989586621679199742"><span id="local-6989586621679199747"><span class="annot"><span class="annottext">Typeable Fixity
Typeable Fixity =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Fixity -&gt; c Fixity)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Fixity)
-&gt; (Fixity -&gt; Constr)
-&gt; (Fixity -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Fixity))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Fixity))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Fixity -&gt; Fixity)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Fixity -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Fixity -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Fixity -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Fixity -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity)
-&gt; Data Fixity
Fixity -&gt; Constr
Fixity -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Fixity -&gt; Fixity
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Fixity -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Fixity -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Fixity -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Fixity -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Fixity
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Fixity -&gt; c Fixity
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Fixity)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Fixity)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Fixity -&gt; c Fixity
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Fixity -&gt; c Fixity
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Fixity
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Fixity
$ctoConstr :: Fixity -&gt; Constr
toConstr :: Fixity -&gt; Constr
$cdataTypeOf :: Fixity -&gt; DataType
dataTypeOf :: Fixity -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Fixity)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Fixity)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Fixity)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Fixity)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Fixity -&gt; Fixity
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Fixity -&gt; Fixity
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Fixity -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Fixity -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Fixity -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Fixity -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Fixity -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Fixity -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Fixity -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Fixity -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Fixity -&gt; m Fixity
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199752"><span id="local-6989586621679199754"><span class="annot"><span class="annottext">(forall x. Fixity -&gt; Rep Fixity x)
-&gt; (forall x. Rep Fixity x -&gt; Fixity) -&gt; Generic Fixity
forall x. Rep Fixity x -&gt; Fixity
forall x. Fixity -&gt; Rep Fixity x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Fixity -&gt; Rep Fixity x
from :: forall x. Fixity -&gt; Rep Fixity x
$cto :: forall x. Rep Fixity x -&gt; Fixity
to :: forall x. Rep Fixity x -&gt; Fixity
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2118"></span><span class="hs-keyword">data</span><span> </span><span id="FixityDirection"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FixityDirection"><span class="hs-identifier hs-var">FixityDirection</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="InfixL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixL"><span class="hs-identifier hs-var">InfixL</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="InfixR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixR"><span class="hs-identifier hs-var">InfixR</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="InfixN"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixN"><span class="hs-identifier hs-var">InfixN</span></a></span></span><span>
</span><span id="line-2119"></span><span>    </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679199759"><span id="local-6989586621679199763"><span class="annot"><span class="annottext">FixityDirection -&gt; FixityDirection -&gt; Bool
(FixityDirection -&gt; FixityDirection -&gt; Bool)
-&gt; (FixityDirection -&gt; FixityDirection -&gt; Bool)
-&gt; Eq FixityDirection
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: FixityDirection -&gt; FixityDirection -&gt; Bool
== :: FixityDirection -&gt; FixityDirection -&gt; Bool
$c/= :: FixityDirection -&gt; FixityDirection -&gt; Bool
/= :: FixityDirection -&gt; FixityDirection -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199768"><span id="local-6989586621679199772"><span id="local-6989586621679199776"><span id="local-6989586621679199779"><span id="local-6989586621679199782"><span id="local-6989586621679199785"><span id="local-6989586621679199788"><span class="annot"><span class="annottext">Eq FixityDirection
Eq FixityDirection =&gt;
(FixityDirection -&gt; FixityDirection -&gt; Ordering)
-&gt; (FixityDirection -&gt; FixityDirection -&gt; Bool)
-&gt; (FixityDirection -&gt; FixityDirection -&gt; Bool)
-&gt; (FixityDirection -&gt; FixityDirection -&gt; Bool)
-&gt; (FixityDirection -&gt; FixityDirection -&gt; Bool)
-&gt; (FixityDirection -&gt; FixityDirection -&gt; FixityDirection)
-&gt; (FixityDirection -&gt; FixityDirection -&gt; FixityDirection)
-&gt; Ord FixityDirection
FixityDirection -&gt; FixityDirection -&gt; Bool
FixityDirection -&gt; FixityDirection -&gt; Ordering
FixityDirection -&gt; FixityDirection -&gt; FixityDirection
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: FixityDirection -&gt; FixityDirection -&gt; Ordering
compare :: FixityDirection -&gt; FixityDirection -&gt; Ordering
$c&lt; :: FixityDirection -&gt; FixityDirection -&gt; Bool
&lt; :: FixityDirection -&gt; FixityDirection -&gt; Bool
$c&lt;= :: FixityDirection -&gt; FixityDirection -&gt; Bool
&lt;= :: FixityDirection -&gt; FixityDirection -&gt; Bool
$c&gt; :: FixityDirection -&gt; FixityDirection -&gt; Bool
&gt; :: FixityDirection -&gt; FixityDirection -&gt; Bool
$c&gt;= :: FixityDirection -&gt; FixityDirection -&gt; Bool
&gt;= :: FixityDirection -&gt; FixityDirection -&gt; Bool
$cmax :: FixityDirection -&gt; FixityDirection -&gt; FixityDirection
max :: FixityDirection -&gt; FixityDirection -&gt; FixityDirection
$cmin :: FixityDirection -&gt; FixityDirection -&gt; FixityDirection
min :: FixityDirection -&gt; FixityDirection -&gt; FixityDirection
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199791"><span id="local-6989586621679199793"><span id="local-6989586621679199796"><span class="annot"><span class="annottext">Int -&gt; FixityDirection -&gt; FilePath -&gt; FilePath
[FixityDirection] -&gt; FilePath -&gt; FilePath
FixityDirection -&gt; FilePath
(Int -&gt; FixityDirection -&gt; FilePath -&gt; FilePath)
-&gt; (FixityDirection -&gt; FilePath)
-&gt; ([FixityDirection] -&gt; FilePath -&gt; FilePath)
-&gt; Show FixityDirection
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; FixityDirection -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; FixityDirection -&gt; FilePath -&gt; FilePath
$cshow :: FixityDirection -&gt; FilePath
show :: FixityDirection -&gt; FilePath
$cshowList :: [FixityDirection] -&gt; FilePath -&gt; FilePath
showList :: [FixityDirection] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199801"><span id="local-6989586621679199803"><span id="local-6989586621679199805"><span id="local-6989586621679199807"><span id="local-6989586621679199809"><span id="local-6989586621679199814"><span id="local-6989586621679199819"><span id="local-6989586621679199822"><span id="local-6989586621679199825"><span id="local-6989586621679199828"><span id="local-6989586621679199831"><span id="local-6989586621679199834"><span id="local-6989586621679199839"><span id="local-6989586621679199844"><span class="annot"><span class="annottext">Typeable FixityDirection
Typeable FixityDirection =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; FixityDirection -&gt; c FixityDirection)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FixityDirection)
-&gt; (FixityDirection -&gt; Constr)
-&gt; (FixityDirection -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FixityDirection))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c FixityDirection))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; FixityDirection -&gt; FixityDirection)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FixityDirection -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FixityDirection -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; FixityDirection -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FixityDirection -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FixityDirection -&gt; m FixityDirection)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FixityDirection -&gt; m FixityDirection)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FixityDirection -&gt; m FixityDirection)
-&gt; Data FixityDirection
FixityDirection -&gt; Constr
FixityDirection -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; FixityDirection -&gt; FixityDirection
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FixityDirection -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FixityDirection -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FixityDirection -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FixityDirection -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FixityDirection -&gt; m FixityDirection
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FixityDirection -&gt; m FixityDirection
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FixityDirection
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FixityDirection -&gt; c FixityDirection
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FixityDirection)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FixityDirection)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FixityDirection -&gt; c FixityDirection
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FixityDirection -&gt; c FixityDirection
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FixityDirection
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FixityDirection
$ctoConstr :: FixityDirection -&gt; Constr
toConstr :: FixityDirection -&gt; Constr
$cdataTypeOf :: FixityDirection -&gt; DataType
dataTypeOf :: FixityDirection -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FixityDirection)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FixityDirection)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FixityDirection)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FixityDirection)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FixityDirection -&gt; FixityDirection
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FixityDirection -&gt; FixityDirection
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FixityDirection -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FixityDirection -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FixityDirection -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FixityDirection -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FixityDirection -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FixityDirection -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FixityDirection -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FixityDirection -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FixityDirection -&gt; m FixityDirection
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FixityDirection -&gt; m FixityDirection
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FixityDirection -&gt; m FixityDirection
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FixityDirection -&gt; m FixityDirection
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FixityDirection -&gt; m FixityDirection
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FixityDirection -&gt; m FixityDirection
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199849"><span id="local-6989586621679199851"><span class="annot"><span class="annottext">(forall x. FixityDirection -&gt; Rep FixityDirection x)
-&gt; (forall x. Rep FixityDirection x -&gt; FixityDirection)
-&gt; Generic FixityDirection
forall x. Rep FixityDirection x -&gt; FixityDirection
forall x. FixityDirection -&gt; Rep FixityDirection x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. FixityDirection -&gt; Rep FixityDirection x
from :: forall x. FixityDirection -&gt; Rep FixityDirection x
$cto :: forall x. Rep FixityDirection x -&gt; FixityDirection
to :: forall x. Rep FixityDirection x -&gt; FixityDirection
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2120"></span><span>
</span><span id="line-2121"></span><span class="annot"><span class="hs-comment">-- | Highest allowed operator precedence for 'Fixity' constructor (answer: 9)</span></span><span>
</span><span id="line-2122"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#maxPrecedence"><span class="hs-identifier hs-type">maxPrecedence</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-2123"></span><span id="maxPrecedence"><span class="annot"><span class="annottext">maxPrecedence :: Int
</span><a href="Language.Haskell.TH.Syntax.html#maxPrecedence"><span class="hs-identifier hs-var hs-var">maxPrecedence</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">9</span></span><span class="hs-glyph">::</span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2124"></span><span>
</span><span id="line-2125"></span><span class="annot"><span class="hs-comment">-- | Default fixity: @infixl 9@</span></span><span>
</span><span id="line-2126"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#defaultFixity"><span class="hs-identifier hs-type">defaultFixity</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a></span><span>
</span><span id="line-2127"></span><span id="defaultFixity"><span class="annot"><span class="annottext">defaultFixity :: Fixity
</span><a href="Language.Haskell.TH.Syntax.html#defaultFixity"><span class="hs-identifier hs-var hs-var">defaultFixity</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; FixityDirection -&gt; Fixity
</span><a href="Language.Haskell.TH.Syntax.html#Fixity"><span class="hs-identifier hs-var">Fixity</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="Language.Haskell.TH.Syntax.html#maxPrecedence"><span class="hs-identifier hs-var">maxPrecedence</span></a></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><a href="Language.Haskell.TH.Syntax.html#InfixL"><span class="hs-identifier hs-var">InfixL</span></a></span><span>
</span><span id="line-2128"></span><span>
</span><span id="line-2129"></span><span>
</span><span id="line-2130"></span><span class="hs-comment">{-
Note [Unresolved infix]
~~~~~~~~~~~~~~~~~~~~~~~
-}</span><span>
</span><span id="line-2134"></span><span class="annot"><span class="hs-comment">{- $infix #infix#

When implementing antiquotation for quasiquoters, one often wants
to parse strings into expressions:

&gt; parse :: String -&gt; Maybe Exp

But how should we parse @a + b * c@? If we don't know the fixities of
@+@ and @*@, we don't know whether to parse it as @a + (b * c)@ or @(a
+ b) * c@.

In cases like this, use 'UInfixE', 'UInfixP', 'UInfixT', or 'PromotedUInfixT',
which stand for \&quot;unresolved infix expression/pattern/type/promoted
constructor\&quot;, respectively. When the compiler is given a splice containing a
tree of @UInfixE@ applications such as

&gt; UInfixE
&gt;   (UInfixE e1 op1 e2)
&gt;   op2
&gt;   (UInfixE e3 op3 e4)

it will look up and the fixities of the relevant operators and
reassociate the tree as necessary.

  * trees will not be reassociated across 'ParensE', 'ParensP', or 'ParensT',
    which are of use for parsing expressions like

    &gt; (a + b * c) + d * e

  * 'InfixE', 'InfixP', 'InfixT', and 'PromotedInfixT' expressions are never
    reassociated.

  * The 'UInfixE' constructor doesn't support sections. Sections
    such as @(a *)@ have no ambiguity, so 'InfixE' suffices. For longer
    sections such as @(a + b * c -)@, use an 'InfixE' constructor for the
    outer-most section, and use 'UInfixE' constructors for all
    other operators:

    &gt; InfixE
    &gt;   Just (UInfixE ...a + b * c...)
    &gt;   op
    &gt;   Nothing

    Sections such as @(a + b +)@ and @((a + b) +)@ should be rendered
    into 'Exp's differently:

    &gt; (+ a + b)   ---&gt; InfixE Nothing + (Just $ UInfixE a + b)
    &gt;                    -- will result in a fixity error if (+) is left-infix
    &gt; (+ (a + b)) ---&gt; InfixE Nothing + (Just $ ParensE $ UInfixE a + b)
    &gt;                    -- no fixity errors

  * Quoted expressions such as

    &gt; [| a * b + c |] :: Q Exp
    &gt; [p| a : b : c |] :: Q Pat
    &gt; [t| T + T |] :: Q Type

    will never contain 'UInfixE', 'UInfixP', 'UInfixT', 'PromotedUInfixT',
    'InfixT', 'PromotedInfixT, 'ParensE', 'ParensP', or 'ParensT' constructors.

-}</span></span><span>
</span><span id="line-2195"></span><span>
</span><span id="line-2196"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-2197"></span><span class="hs-comment">--</span><span>
</span><span id="line-2198"></span><span class="hs-comment">--      The main syntax data types</span><span>
</span><span id="line-2199"></span><span class="hs-comment">--</span><span>
</span><span id="line-2200"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-2201"></span><span>
</span><span id="line-2202"></span><span class="hs-keyword">data</span><span> </span><span id="Lit"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lit"><span class="hs-identifier hs-var">Lit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="CharL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CharL"><span class="hs-identifier hs-var">CharL</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Char"><span class="hs-identifier hs-type">Char</span></a></span><span>
</span><span id="line-2203"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="StringL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StringL"><span class="hs-identifier hs-var">StringL</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2204"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="IntegerL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#IntegerL"><span class="hs-identifier hs-var">IntegerL</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>     </span><span class="hs-comment">-- ^ Used for overloaded and non-overloaded</span><span>
</span><span id="line-2205"></span><span>                                </span><span class="hs-comment">-- literals. We don't have a good way to</span><span>
</span><span id="line-2206"></span><span>                                </span><span class="hs-comment">-- represent non-overloaded literals at</span><span>
</span><span id="line-2207"></span><span>                                </span><span class="hs-comment">-- the moment. Maybe that doesn't matter?</span><span>
</span><span id="line-2208"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="RationalL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RationalL"><span class="hs-identifier hs-var">RationalL</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Rational</span></span><span>   </span><span class="hs-comment">-- Ditto</span><span>
</span><span id="line-2209"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="IntPrimL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#IntPrimL"><span class="hs-identifier hs-var">IntPrimL</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>
</span><span id="line-2210"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="WordPrimL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#WordPrimL"><span class="hs-identifier hs-var">WordPrimL</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>
</span><span id="line-2211"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="FloatPrimL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FloatPrimL"><span class="hs-identifier hs-var">FloatPrimL</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Rational</span></span><span>
</span><span id="line-2212"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="DoublePrimL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DoublePrimL"><span class="hs-identifier hs-var">DoublePrimL</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Rational</span></span><span>
</span><span id="line-2213"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="StringPrimL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StringPrimL"><span class="hs-identifier hs-var">StringPrimL</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">]</span><span>  </span><span class="annot"><span class="hs-comment">-- ^ A primitive C-style string, type 'Addr#'</span></span><span>
</span><span id="line-2214"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="BytesPrimL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BytesPrimL"><span class="hs-identifier hs-var">BytesPrimL</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ Some raw bytes, type 'Addr#':</span></span><span>
</span><span id="line-2215"></span><span>         </span><span class="hs-glyph">|</span><span> </span><span id="CharPrimL"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CharPrimL"><span class="hs-identifier hs-var">CharPrimL</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Char"><span class="hs-identifier hs-type">Char</span></a></span><span>
</span><span id="line-2216"></span><span>    </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679199865"><span id="local-6989586621679199892"><span id="local-6989586621679199896"><span class="annot"><span class="annottext">Int -&gt; Lit -&gt; FilePath -&gt; FilePath
[Lit] -&gt; FilePath -&gt; FilePath
Lit -&gt; FilePath
(Int -&gt; Lit -&gt; FilePath -&gt; FilePath)
-&gt; (Lit -&gt; FilePath) -&gt; ([Lit] -&gt; FilePath -&gt; FilePath) -&gt; Show Lit
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Lit -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Lit -&gt; FilePath -&gt; FilePath
$cshow :: Lit -&gt; FilePath
show :: Lit -&gt; FilePath
$cshowList :: [Lit] -&gt; FilePath -&gt; FilePath
showList :: [Lit] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199900"><span id="local-6989586621679199918"><span class="annot"><span class="annottext">Lit -&gt; Lit -&gt; Bool
(Lit -&gt; Lit -&gt; Bool) -&gt; (Lit -&gt; Lit -&gt; Bool) -&gt; Eq Lit
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Lit -&gt; Lit -&gt; Bool
== :: Lit -&gt; Lit -&gt; Bool
$c/= :: Lit -&gt; Lit -&gt; Bool
/= :: Lit -&gt; Lit -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199925"><span id="local-6989586621679199949"><span id="local-6989586621679199953"><span id="local-6989586621679199956"><span id="local-6989586621679199959"><span id="local-6989586621679199962"><span id="local-6989586621679199965"><span class="annot"><span class="annottext">Eq Lit
Eq Lit =&gt;
(Lit -&gt; Lit -&gt; Ordering)
-&gt; (Lit -&gt; Lit -&gt; Bool)
-&gt; (Lit -&gt; Lit -&gt; Bool)
-&gt; (Lit -&gt; Lit -&gt; Bool)
-&gt; (Lit -&gt; Lit -&gt; Bool)
-&gt; (Lit -&gt; Lit -&gt; Lit)
-&gt; (Lit -&gt; Lit -&gt; Lit)
-&gt; Ord Lit
Lit -&gt; Lit -&gt; Bool
Lit -&gt; Lit -&gt; Ordering
Lit -&gt; Lit -&gt; Lit
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Lit -&gt; Lit -&gt; Ordering
compare :: Lit -&gt; Lit -&gt; Ordering
$c&lt; :: Lit -&gt; Lit -&gt; Bool
&lt; :: Lit -&gt; Lit -&gt; Bool
$c&lt;= :: Lit -&gt; Lit -&gt; Bool
&lt;= :: Lit -&gt; Lit -&gt; Bool
$c&gt; :: Lit -&gt; Lit -&gt; Bool
&gt; :: Lit -&gt; Lit -&gt; Bool
$c&gt;= :: Lit -&gt; Lit -&gt; Bool
&gt;= :: Lit -&gt; Lit -&gt; Bool
$cmax :: Lit -&gt; Lit -&gt; Lit
max :: Lit -&gt; Lit -&gt; Lit
$cmin :: Lit -&gt; Lit -&gt; Lit
min :: Lit -&gt; Lit -&gt; Lit
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679199972"><span id="local-6989586621679199989"><span id="local-6989586621679200004"><span id="local-6989586621679200006"><span id="local-6989586621679200008"><span id="local-6989586621679200014"><span id="local-6989586621679200019"><span id="local-6989586621679200022"><span id="local-6989586621679200025"><span id="local-6989586621679200028"><span id="local-6989586621679200031"><span id="local-6989586621679200034"><span id="local-6989586621679200039"><span id="local-6989586621679200044"><span class="annot"><span class="annottext">Typeable Lit
Typeable Lit =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Lit -&gt; c Lit)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Lit)
-&gt; (Lit -&gt; Constr)
-&gt; (Lit -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Lit))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Lit))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Lit -&gt; Lit)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Lit -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Lit -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Lit -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Lit -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit)
-&gt; Data Lit
Lit -&gt; Constr
Lit -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Lit -&gt; Lit
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Lit -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Lit -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Lit -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Lit -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Lit
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Lit -&gt; c Lit
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Lit)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Lit)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Lit -&gt; c Lit
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Lit -&gt; c Lit
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Lit
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Lit
$ctoConstr :: Lit -&gt; Constr
toConstr :: Lit -&gt; Constr
$cdataTypeOf :: Lit -&gt; DataType
dataTypeOf :: Lit -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Lit)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Lit)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Lit)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Lit)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Lit -&gt; Lit
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Lit -&gt; Lit
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Lit -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Lit -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Lit -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Lit -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Lit -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Lit -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Lit -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Lit -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Lit -&gt; m Lit
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200050"><span id="local-6989586621679200052"><span class="annot"><span class="annottext">(forall x. Lit -&gt; Rep Lit x)
-&gt; (forall x. Rep Lit x -&gt; Lit) -&gt; Generic Lit
forall x. Rep Lit x -&gt; Lit
forall x. Lit -&gt; Rep Lit x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Lit -&gt; Rep Lit x
from :: forall x. Lit -&gt; Rep Lit x
$cto :: forall x. Rep Lit x -&gt; Lit
to :: forall x. Rep Lit x -&gt; Lit
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2217"></span><span>
</span><span id="line-2218"></span><span>    </span><span class="hs-comment">-- We could add Int, Float, Double etc, as we do in HsLit,</span><span>
</span><span id="line-2219"></span><span>    </span><span class="hs-comment">-- but that could complicate the</span><span>
</span><span id="line-2220"></span><span>    </span><span class="hs-comment">-- supposedly-simple TH.Syntax literal type</span><span>
</span><span id="line-2221"></span><span>
</span><span id="line-2222"></span><span class="hs-comment">-- | Raw bytes embedded into the binary.</span><span>
</span><span id="line-2223"></span><span class="hs-comment">--</span><span>
</span><span id="line-2224"></span><span class="hs-comment">-- Avoid using Bytes constructor directly as it is likely to change in the</span><span>
</span><span id="line-2225"></span><span class="hs-comment">-- future. Use helpers such as `mkBytes` in Language.Haskell.TH.Lib instead.</span><span>
</span><span id="line-2226"></span><span class="hs-keyword">data</span><span> </span><span id="Bytes"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-var">Bytes</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Bytes"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-var">Bytes</span></a></span></span><span>
</span><span id="line-2227"></span><span>   </span><span class="hs-special">{</span><span> </span><span id="bytesPtr"><span class="annot"><span class="annottext">Bytes -&gt; ForeignPtr Word8
</span><a href="Language.Haskell.TH.Syntax.html#bytesPtr"><span class="hs-identifier hs-var hs-var">bytesPtr</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ForeignPtr</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Pointer to the data</span></span><span>
</span><span id="line-2228"></span><span>   </span><span class="hs-special">,</span><span> </span><span id="bytesOffset"><span class="annot"><span class="annottext">Bytes -&gt; Word
</span><a href="Language.Haskell.TH.Syntax.html#bytesOffset"><span class="hs-identifier hs-var hs-var">bytesOffset</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Word"><span class="hs-identifier hs-type">Word</span></a></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ Offset from the pointer</span></span><span>
</span><span id="line-2229"></span><span>   </span><span class="hs-special">,</span><span> </span><span id="bytesSize"><span class="annot"><span class="annottext">Bytes -&gt; Word
</span><a href="Language.Haskell.TH.Syntax.html#bytesSize"><span class="hs-identifier hs-var hs-var">bytesSize</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Word"><span class="hs-identifier hs-type">Word</span></a></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ Number of bytes</span></span><span>
</span><span id="line-2230"></span><span>
</span><span id="line-2231"></span><span>   </span><span class="hs-comment">-- Maybe someday:</span><span>
</span><span id="line-2232"></span><span>   </span><span class="hs-comment">-- , bytesAlignement  :: Word -- ^ Alignement constraint</span><span>
</span><span id="line-2233"></span><span>   </span><span class="hs-comment">-- , bytesReadOnly    :: Bool -- ^ Shall we embed into a read-only</span><span>
</span><span id="line-2234"></span><span>   </span><span class="hs-comment">--                            --   section or not</span><span>
</span><span id="line-2235"></span><span>   </span><span class="hs-comment">-- , bytesInitialized :: Bool -- ^ False: only use `bytesSize` to allocate</span><span>
</span><span id="line-2236"></span><span>   </span><span class="hs-comment">--                            --   an uninitialized region</span><span>
</span><span id="line-2237"></span><span>   </span><span class="hs-special">}</span><span>
</span><span id="line-2238"></span><span>   </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679200060"><span id="local-6989586621679200068"><span id="local-6989586621679200074"><span id="local-6989586621679200076"><span id="local-6989586621679200078"><span id="local-6989586621679200083"><span id="local-6989586621679200088"><span id="local-6989586621679200091"><span id="local-6989586621679200094"><span id="local-6989586621679200097"><span id="local-6989586621679200100"><span id="local-6989586621679200103"><span id="local-6989586621679200108"><span id="local-6989586621679200113"><span class="annot"><span class="annottext">Typeable Bytes
Typeable Bytes =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Bytes -&gt; c Bytes)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Bytes)
-&gt; (Bytes -&gt; Constr)
-&gt; (Bytes -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Bytes))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Bytes))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Bytes -&gt; Bytes)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bytes -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bytes -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bytes -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bytes -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes)
-&gt; Data Bytes
Bytes -&gt; Constr
Bytes -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Bytes -&gt; Bytes
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bytes -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bytes -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bytes -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bytes -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Bytes
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bytes -&gt; c Bytes
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Bytes)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Bytes)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bytes -&gt; c Bytes
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bytes -&gt; c Bytes
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Bytes
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Bytes
$ctoConstr :: Bytes -&gt; Constr
toConstr :: Bytes -&gt; Constr
$cdataTypeOf :: Bytes -&gt; DataType
dataTypeOf :: Bytes -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Bytes)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Bytes)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Bytes)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Bytes)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Bytes -&gt; Bytes
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Bytes -&gt; Bytes
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bytes -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bytes -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bytes -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bytes -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bytes -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bytes -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bytes -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bytes -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bytes -&gt; m Bytes
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679200118"><span id="local-6989586621679200120"><span class="annot"><span class="annottext">(forall x. Bytes -&gt; Rep Bytes x)
-&gt; (forall x. Rep Bytes x -&gt; Bytes) -&gt; Generic Bytes
forall x. Rep Bytes x -&gt; Bytes
forall x. Bytes -&gt; Rep Bytes x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Bytes -&gt; Rep Bytes x
from :: forall x. Bytes -&gt; Rep Bytes x
$cto :: forall x. Rep Bytes x -&gt; Bytes
to :: forall x. Rep Bytes x -&gt; Bytes
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2239"></span><span>
</span><span id="line-2240"></span><span class="hs-comment">-- We can't derive Show instance for Bytes because we don't want to show the</span><span>
</span><span id="line-2241"></span><span class="hs-comment">-- pointer value but the actual bytes (similarly to what ByteString does). See</span><span>
</span><span id="line-2242"></span><span class="hs-comment">-- #16457.</span><span>
</span><span id="line-2243"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679200123"><span id="local-6989586621679200127"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2244"></span><span>   </span><span id="local-6989586621679200133"><span class="annot"><span class="annottext">show :: Bytes -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var">show</span></span></span><span> </span><span id="local-6989586621679200134"><span class="annot"><span class="annottext">Bytes
</span><a href="#local-6989586621679200134"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IO FilePath -&gt; FilePath
forall a. IO a -&gt; a
</span><span class="hs-identifier hs-var">unsafePerformIO</span></span><span> </span><span class="annot"><span class="annottext">(IO FilePath -&gt; FilePath) -&gt; IO FilePath -&gt; FilePath
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8 -&gt; (Ptr Word8 -&gt; IO FilePath) -&gt; IO FilePath
forall a b. ForeignPtr a -&gt; (Ptr a -&gt; IO b) -&gt; IO b
</span><span class="hs-identifier hs-var">withForeignPtr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bytes -&gt; ForeignPtr Word8
</span><a href="Language.Haskell.TH.Syntax.html#bytesPtr"><span class="hs-identifier hs-var">bytesPtr</span></a></span><span> </span><span class="annot"><span class="annottext">Bytes
</span><a href="#local-6989586621679200134"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((Ptr Word8 -&gt; IO FilePath) -&gt; IO FilePath)
-&gt; (Ptr Word8 -&gt; IO FilePath) -&gt; IO FilePath
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679200136"><span class="annot"><span class="annottext">Ptr Word8
</span><a href="#local-6989586621679200136"><span class="hs-identifier hs-var">ptr</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2245"></span><span>               </span><span class="annot"><span class="annottext">CStringLen -&gt; IO FilePath
</span><span class="hs-identifier hs-var">peekCStringLen</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">Ptr Word8
</span><a href="#local-6989586621679200136"><span class="hs-identifier hs-var">ptr</span></a></span><span> </span><span class="annot"><span class="annottext">Ptr Word8 -&gt; Int -&gt; Ptr CChar
forall a b. Ptr a -&gt; Int -&gt; Ptr b
</span><span class="hs-operator hs-var">`plusPtr`</span></span><span> </span><span class="annot"><span class="annottext">Word -&gt; Int
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bytes -&gt; Word
</span><a href="Language.Haskell.TH.Syntax.html#bytesOffset"><span class="hs-identifier hs-var">bytesOffset</span></a></span><span> </span><span class="annot"><span class="annottext">Bytes
</span><a href="#local-6989586621679200134"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2246"></span><span>                              </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Word -&gt; Int
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bytes -&gt; Word
</span><a href="Language.Haskell.TH.Syntax.html#bytesSize"><span class="hs-identifier hs-var">bytesSize</span></a></span><span> </span><span class="annot"><span class="annottext">Bytes
</span><a href="#local-6989586621679200134"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2247"></span><span>                              </span><span class="hs-special">)</span><span>
</span><span id="line-2248"></span><span>
</span><span id="line-2249"></span><span class="hs-comment">-- We can't derive Eq and Ord instances for Bytes because we don't want to</span><span>
</span><span id="line-2250"></span><span class="hs-comment">-- compare pointer values but the actual bytes (similarly to what ByteString</span><span>
</span><span id="line-2251"></span><span class="hs-comment">-- does).  See #16457</span><span>
</span><span id="line-2252"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679200140"><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-type">Eq</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2253"></span><span>   </span><span id="local-6989586621679200142"><span class="annot"><span class="annottext">== :: Bytes -&gt; Bytes -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var hs-var hs-var">(==)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bytes -&gt; Bytes -&gt; Bool
</span><a href="Language.Haskell.TH.Syntax.html#eqBytes"><span class="hs-identifier hs-var">eqBytes</span></a></span><span>
</span><span id="line-2254"></span><span>
</span><span id="line-2255"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679200148"><span id="local-6989586621679200151"><span id="local-6989586621679200154"><span id="local-6989586621679200157"><span id="local-6989586621679200160"><span id="local-6989586621679200163"><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-2256"></span><span>   </span><span id="local-6989586621679200165"><span class="annot"><span class="annottext">compare :: Bytes -&gt; Bytes -&gt; Ordering
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#compare"><span class="hs-identifier hs-var hs-var hs-var">compare</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bytes -&gt; Bytes -&gt; Ordering
</span><a href="Language.Haskell.TH.Syntax.html#compareBytes"><span class="hs-identifier hs-var">compareBytes</span></a></span><span>
</span><span id="line-2257"></span><span>
</span><span id="line-2258"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#eqBytes"><span class="hs-identifier hs-type">eqBytes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-2259"></span><span id="eqBytes"><span class="annot"><span class="annottext">eqBytes :: Bytes -&gt; Bytes -&gt; Bool
</span><a href="Language.Haskell.TH.Syntax.html#eqBytes"><span class="hs-identifier hs-var hs-var">eqBytes</span></a></span></span><span> </span><span id="local-6989586621679200167"><span class="annot"><span class="annottext">a :: Bytes
</span><a href="#local-6989586621679200167"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span id="local-6989586621679200168"><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679200168"><span class="hs-identifier hs-var">fp</span></a></span></span><span> </span><span id="local-6989586621679200169"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200169"><span class="hs-identifier hs-var">off</span></a></span></span><span> </span><span id="local-6989586621679200170"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200170"><span class="hs-identifier hs-var">len</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679200171"><span class="annot"><span class="annottext">b :: Bytes
</span><a href="#local-6989586621679200171"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span id="local-6989586621679200172"><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679200172"><span class="hs-identifier hs-var">fp'</span></a></span></span><span> </span><span id="local-6989586621679200173"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200173"><span class="hs-identifier hs-var">off'</span></a></span></span><span> </span><span id="local-6989586621679200174"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200174"><span class="hs-identifier hs-var">len'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-2260"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200170"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">Word -&gt; Word -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%2F%3D"><span class="hs-operator hs-var">/=</span></a></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200174"><span class="hs-identifier hs-var">len'</span></a></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>    </span><span class="hs-comment">-- short cut on length</span><span>
</span><span id="line-2261"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679200168"><span class="hs-identifier hs-var">fp</span></a></span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8 -&gt; ForeignPtr Word8 -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679200172"><span class="hs-identifier hs-var">fp'</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%26%26"><span class="hs-operator hs-var">&amp;&amp;</span></a></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200169"><span class="hs-identifier hs-var">off</span></a></span><span> </span><span class="annot"><span class="annottext">Word -&gt; Word -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200173"><span class="hs-identifier hs-var">off'</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>     </span><span class="hs-comment">-- short cut for the same bytes</span><span>
</span><span id="line-2262"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bytes -&gt; Bytes -&gt; Ordering
</span><a href="Language.Haskell.TH.Syntax.html#compareBytes"><span class="hs-identifier hs-var">compareBytes</span></a></span><span> </span><span class="annot"><span class="annottext">Bytes
</span><a href="#local-6989586621679200167"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Bytes
</span><a href="#local-6989586621679200171"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering -&gt; Ordering -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#EQ"><span class="hs-identifier hs-var">EQ</span></a></span><span>
</span><span id="line-2263"></span><span>
</span><span id="line-2264"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#compareBytes"><span class="hs-identifier hs-type">compareBytes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Ordering"><span class="hs-identifier hs-type">Ordering</span></a></span><span>
</span><span id="line-2265"></span><span id="compareBytes"><span class="annot"><span class="annottext">compareBytes :: Bytes -&gt; Bytes -&gt; Ordering
</span><a href="Language.Haskell.TH.Syntax.html#compareBytes"><span class="hs-identifier hs-var hs-var">compareBytes</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8
</span><span class="hs-identifier">_</span></span><span>   </span><span class="annot"><span class="annottext">Word
</span><span class="hs-identifier">_</span></span><span>    </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8
</span><span class="hs-identifier">_</span></span><span>   </span><span class="annot"><span class="annottext">Word
</span><span class="hs-identifier">_</span></span><span>    </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#EQ"><span class="hs-identifier hs-var">EQ</span></a></span><span>  </span><span class="hs-comment">-- short cut for empty Bytes</span><span>
</span><span id="line-2266"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#compareBytes"><span class="hs-identifier hs-var">compareBytes</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span id="local-6989586621679200176"><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679200176"><span class="hs-identifier hs-var">fp1</span></a></span></span><span> </span><span id="local-6989586621679200177"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200177"><span class="hs-identifier hs-var">off1</span></a></span></span><span> </span><span id="local-6989586621679200178"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200178"><span class="hs-identifier hs-var">len1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bytes"><span class="hs-identifier hs-type">Bytes</span></a></span><span> </span><span id="local-6989586621679200179"><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679200179"><span class="hs-identifier hs-var">fp2</span></a></span></span><span> </span><span id="local-6989586621679200180"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200180"><span class="hs-identifier hs-var">off2</span></a></span></span><span> </span><span id="local-6989586621679200181"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200181"><span class="hs-identifier hs-var">len2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2267"></span><span>    </span><span class="annot"><span class="annottext">IO Ordering -&gt; Ordering
forall a. IO a -&gt; a
</span><span class="hs-identifier hs-var">unsafePerformIO</span></span><span> </span><span class="annot"><span class="annottext">(IO Ordering -&gt; Ordering) -&gt; IO Ordering -&gt; Ordering
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-2268"></span><span>      </span><span class="annot"><span class="annottext">ForeignPtr Word8 -&gt; (Ptr Word8 -&gt; IO Ordering) -&gt; IO Ordering
forall a b. ForeignPtr a -&gt; (Ptr a -&gt; IO b) -&gt; IO b
</span><span class="hs-identifier hs-var">withForeignPtr</span></span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679200176"><span class="hs-identifier hs-var">fp1</span></a></span><span> </span><span class="annot"><span class="annottext">((Ptr Word8 -&gt; IO Ordering) -&gt; IO Ordering)
-&gt; (Ptr Word8 -&gt; IO Ordering) -&gt; IO Ordering
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679200182"><span class="annot"><span class="annottext">Ptr Word8
</span><a href="#local-6989586621679200182"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2269"></span><span>      </span><span class="annot"><span class="annottext">ForeignPtr Word8 -&gt; (Ptr Word8 -&gt; IO Ordering) -&gt; IO Ordering
forall a b. ForeignPtr a -&gt; (Ptr a -&gt; IO b) -&gt; IO b
</span><span class="hs-identifier hs-var">withForeignPtr</span></span><span> </span><span class="annot"><span class="annottext">ForeignPtr Word8
</span><a href="#local-6989586621679200179"><span class="hs-identifier hs-var">fp2</span></a></span><span> </span><span class="annot"><span class="annottext">((Ptr Word8 -&gt; IO Ordering) -&gt; IO Ordering)
-&gt; (Ptr Word8 -&gt; IO Ordering) -&gt; IO Ordering
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679200183"><span class="annot"><span class="annottext">Ptr Word8
</span><a href="#local-6989586621679200183"><span class="hs-identifier hs-var">p2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-2270"></span><span>        </span><span id="local-6989586621679200184"><span class="annot"><a href="#local-6989586621679200184"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Ptr (ZonkAny 1) -&gt; Ptr (ZonkAny 0) -&gt; CSize -&gt; IO CInt
forall a b. Ptr a -&gt; Ptr b -&gt; CSize -&gt; IO CInt
</span><a href="Language.Haskell.TH.Syntax.html#memcmp"><span class="hs-identifier hs-var">memcmp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ptr Word8
</span><a href="#local-6989586621679200182"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">Ptr Word8 -&gt; Int -&gt; Ptr (ZonkAny 1)
forall a b. Ptr a -&gt; Int -&gt; Ptr b
</span><span class="hs-operator hs-var">`plusPtr`</span></span><span> </span><span class="annot"><span class="annottext">Word -&gt; Int
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200177"><span class="hs-identifier hs-var">off1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2271"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Ptr Word8
</span><a href="#local-6989586621679200183"><span class="hs-identifier hs-var">p2</span></a></span><span> </span><span class="annot"><span class="annottext">Ptr Word8 -&gt; Int -&gt; Ptr (ZonkAny 0)
forall a b. Ptr a -&gt; Int -&gt; Ptr b
</span><span class="hs-operator hs-var">`plusPtr`</span></span><span> </span><span class="annot"><span class="annottext">Word -&gt; Int
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200180"><span class="hs-identifier hs-var">off2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2272"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word -&gt; CSize
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word -&gt; Word -&gt; Word
forall a. Ord a =&gt; a -&gt; a -&gt; a
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#min"><span class="hs-identifier hs-var">min</span></a></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200178"><span class="hs-identifier hs-var">len1</span></a></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679200181"><span class="hs-identifier hs-var">len2</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-2273"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$!</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679200184"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#compare"><span class="hs-operator hs-type">`compare`</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679200178"><span class="hs-identifier hs-type">len1</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#compare"><span class="hs-operator hs-type">`compare`</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679200181"><span class="hs-identifier hs-type">len2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2274"></span><span>
</span><span id="line-2275"></span><span class="hs-keyword">foreign</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-keyword">ccall</span></span><span> </span><span class="annot"><span class="hs-keyword">unsafe</span></span><span> </span><span class="annot"><span class="hs-string">&quot;memcmp&quot;</span></span><span>
</span><span id="line-2276"></span><span>  </span><span id="memcmp"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#memcmp"><span class="hs-identifier hs-var">memcmp</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679194061"><span id="local-6989586621679194062"><span class="annot"><span class="hs-identifier hs-type">Ptr</span></span><span> </span><span class="annot"><a href="#local-6989586621679194061"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ptr</span></span><span> </span><span class="annot"><a href="#local-6989586621679194062"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">CSize</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">CInt</span></span></span></span><span>
</span><span id="line-2277"></span><span>
</span><span id="line-2278"></span><span>
</span><span id="line-2279"></span><span class="annot"><span class="hs-comment">-- | Pattern in Haskell given in @{}@</span></span><span>
</span><span id="line-2280"></span><span class="hs-keyword">data</span><span> </span><span id="Pat"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-var">Pat</span></a></span></span><span>
</span><span id="line-2281"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="LitP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LitP"><span class="hs-identifier hs-var">LitP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span>                        </span><span class="annot"><span class="hs-comment">-- ^ @{ 5 or \'c\' }@</span></span><span>
</span><span id="line-2282"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="VarP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarP"><span class="hs-identifier hs-var">VarP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>                       </span><span class="annot"><span class="hs-comment">-- ^ @{ x }@</span></span><span>
</span><span id="line-2283"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TupP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TupP"><span class="hs-identifier hs-var">TupP</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span class="hs-special">]</span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @{ (p1,p2) }@</span></span><span>
</span><span id="line-2284"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedTupP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UnboxedTupP"><span class="hs-identifier hs-var">UnboxedTupP</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span class="hs-special">]</span><span>               </span><span class="annot"><span class="hs-comment">-- ^ @{ (\# p1,p2 \#) }@</span></span><span>
</span><span id="line-2285"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedSumP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UnboxedSumP"><span class="hs-identifier hs-var">UnboxedSumP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumAlt"><span class="hs-identifier hs-type">SumAlt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumArity"><span class="hs-identifier hs-type">SumArity</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @{ (\#|p|\#) }@</span></span><span>
</span><span id="line-2286"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ConP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ConP"><span class="hs-identifier hs-var">ConP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span class="hs-special">]</span><span>          </span><span class="annot"><span class="hs-comment">-- ^ @data T1 = C1 t1 t2; {C1 \@ty1 p1 p2} = e@</span></span><span>
</span><span id="line-2287"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InfixP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixP"><span class="hs-identifier hs-var">InfixP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ @foo ({x :+ y}) = e@</span></span><span>
</span><span id="line-2288"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UInfixP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UInfixP"><span class="hs-identifier hs-var">UInfixP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span>            </span><span class="hs-comment">-- ^ @foo ({x :+ y}) = e@</span><span>
</span><span id="line-2289"></span><span>                                    </span><span class="hs-comment">--</span><span>
</span><span id="line-2290"></span><span>                                    </span><span class="hs-comment">-- See &quot;Language.Haskell.TH.Syntax#infix&quot;</span><span>
</span><span id="line-2291"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParensP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ParensP"><span class="hs-identifier hs-var">ParensP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span>                     </span><span class="hs-comment">-- ^ @{(p)}@</span><span>
</span><span id="line-2292"></span><span>                                    </span><span class="hs-comment">--</span><span>
</span><span id="line-2293"></span><span>                                    </span><span class="hs-comment">-- See &quot;Language.Haskell.TH.Syntax#infix&quot;</span><span>
</span><span id="line-2294"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TildeP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TildeP"><span class="hs-identifier hs-var">TildeP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @{ ~p }@</span></span><span>
</span><span id="line-2295"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BangP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BangP"><span class="hs-identifier hs-var">BangP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span>                       </span><span class="annot"><span class="hs-comment">-- ^ @{ !p }@</span></span><span>
</span><span id="line-2296"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="AsP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AsP"><span class="hs-identifier hs-var">AsP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span>                    </span><span class="annot"><span class="hs-comment">-- ^ @{ x \@ p }@</span></span><span>
</span><span id="line-2297"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="WildP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#WildP"><span class="hs-identifier hs-var">WildP</span></a></span></span><span>                           </span><span class="annot"><span class="hs-comment">-- ^ @{ _ }@</span></span><span>
</span><span id="line-2298"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecP"><span class="hs-identifier hs-var">RecP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FieldPat"><span class="hs-identifier hs-type">FieldPat</span></a></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">-- ^ @f (Pt { pointx = x }) = g x@</span></span><span>
</span><span id="line-2299"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ListP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ListP"><span class="hs-identifier hs-var">ListP</span></a></span></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">]</span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ @{ [1,2,3] }@</span></span><span>
</span><span id="line-2300"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SigP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SigP"><span class="hs-identifier hs-var">SigP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ @{ p :: t }@</span></span><span>
</span><span id="line-2301"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ViewP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ViewP"><span class="hs-identifier hs-var">ViewP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ @{ e -&gt; p }@</span></span><span>
</span><span id="line-2302"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeP"><span class="hs-identifier hs-var">TypeP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @{ type p }@</span></span><span>
</span><span id="line-2303"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InvisP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InvisP"><span class="hs-identifier hs-var">InvisP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^ @{ @p }@</span></span><span>
</span><span id="line-2304"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679200201"><span id="local-6989586621679200255"><span id="local-6989586621679200259"><span class="annot"><span class="annottext">Int -&gt; Pat -&gt; FilePath -&gt; FilePath
[Pat] -&gt; FilePath -&gt; FilePath
Pat -&gt; FilePath
(Int -&gt; Pat -&gt; FilePath -&gt; FilePath)
-&gt; (Pat -&gt; FilePath) -&gt; ([Pat] -&gt; FilePath -&gt; FilePath) -&gt; Show Pat
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Pat -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Pat -&gt; FilePath -&gt; FilePath
$cshow :: Pat -&gt; FilePath
show :: Pat -&gt; FilePath
$cshowList :: [Pat] -&gt; FilePath -&gt; FilePath
showList :: [Pat] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200262"><span id="local-6989586621679200300"><span class="annot"><span class="annottext">Pat -&gt; Pat -&gt; Bool
(Pat -&gt; Pat -&gt; Bool) -&gt; (Pat -&gt; Pat -&gt; Bool) -&gt; Eq Pat
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Pat -&gt; Pat -&gt; Bool
== :: Pat -&gt; Pat -&gt; Bool
$c/= :: Pat -&gt; Pat -&gt; Bool
/= :: Pat -&gt; Pat -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200306"><span id="local-6989586621679200357"><span id="local-6989586621679200361"><span id="local-6989586621679200364"><span id="local-6989586621679200367"><span id="local-6989586621679200370"><span id="local-6989586621679200373"><span class="annot"><span class="annottext">Eq Pat
Eq Pat =&gt;
(Pat -&gt; Pat -&gt; Ordering)
-&gt; (Pat -&gt; Pat -&gt; Bool)
-&gt; (Pat -&gt; Pat -&gt; Bool)
-&gt; (Pat -&gt; Pat -&gt; Bool)
-&gt; (Pat -&gt; Pat -&gt; Bool)
-&gt; (Pat -&gt; Pat -&gt; Pat)
-&gt; (Pat -&gt; Pat -&gt; Pat)
-&gt; Ord Pat
Pat -&gt; Pat -&gt; Bool
Pat -&gt; Pat -&gt; Ordering
Pat -&gt; Pat -&gt; Pat
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Pat -&gt; Pat -&gt; Ordering
compare :: Pat -&gt; Pat -&gt; Ordering
$c&lt; :: Pat -&gt; Pat -&gt; Bool
&lt; :: Pat -&gt; Pat -&gt; Bool
$c&lt;= :: Pat -&gt; Pat -&gt; Bool
&lt;= :: Pat -&gt; Pat -&gt; Bool
$c&gt; :: Pat -&gt; Pat -&gt; Bool
&gt; :: Pat -&gt; Pat -&gt; Bool
$c&gt;= :: Pat -&gt; Pat -&gt; Bool
&gt;= :: Pat -&gt; Pat -&gt; Bool
$cmax :: Pat -&gt; Pat -&gt; Pat
max :: Pat -&gt; Pat -&gt; Pat
$cmin :: Pat -&gt; Pat -&gt; Pat
min :: Pat -&gt; Pat -&gt; Pat
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200378"><span id="local-6989586621679200414"><span id="local-6989586621679200449"><span id="local-6989586621679200451"><span id="local-6989586621679200453"><span id="local-6989586621679200459"><span id="local-6989586621679200464"><span id="local-6989586621679200467"><span id="local-6989586621679200470"><span id="local-6989586621679200473"><span id="local-6989586621679200476"><span id="local-6989586621679200479"><span id="local-6989586621679200484"><span id="local-6989586621679200489"><span class="annot"><span class="annottext">Typeable Pat
Typeable Pat =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Pat -&gt; c Pat)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Pat)
-&gt; (Pat -&gt; Constr)
-&gt; (Pat -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Pat))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Pat))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Pat -&gt; Pat)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pat -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat)
-&gt; Data Pat
Pat -&gt; Constr
Pat -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Pat -&gt; Pat
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pat -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Pat
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pat -&gt; c Pat
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Pat)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Pat)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pat -&gt; c Pat
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pat -&gt; c Pat
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Pat
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Pat
$ctoConstr :: Pat -&gt; Constr
toConstr :: Pat -&gt; Constr
$cdataTypeOf :: Pat -&gt; DataType
dataTypeOf :: Pat -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Pat)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Pat)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Pat)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Pat)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Pat -&gt; Pat
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Pat -&gt; Pat
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pat -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pat -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat -&gt; m Pat
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200494"><span id="local-6989586621679200496"><span class="annot"><span class="annottext">(forall x. Pat -&gt; Rep Pat x)
-&gt; (forall x. Rep Pat x -&gt; Pat) -&gt; Generic Pat
forall x. Rep Pat x -&gt; Pat
forall x. Pat -&gt; Rep Pat x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Pat -&gt; Rep Pat x
from :: forall x. Pat -&gt; Rep Pat x
$cto :: forall x. Rep Pat x -&gt; Pat
to :: forall x. Rep Pat x -&gt; Pat
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2305"></span><span>
</span><span id="line-2306"></span><span class="hs-keyword">type</span><span> </span><span id="FieldPat"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FieldPat"><span class="hs-identifier hs-var">FieldPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2307"></span><span>
</span><span id="line-2308"></span><span class="hs-keyword">data</span><span> </span><span id="Match"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Match"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Body"><span class="hs-identifier hs-type">Body</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ @case e of { pat -&gt; body where decs }@</span></span><span>
</span><span id="line-2309"></span><span>    </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679200500"><span id="local-6989586621679200508"><span id="local-6989586621679200512"><span class="annot"><span class="annottext">Int -&gt; Match -&gt; FilePath -&gt; FilePath
[Match] -&gt; FilePath -&gt; FilePath
Match -&gt; FilePath
(Int -&gt; Match -&gt; FilePath -&gt; FilePath)
-&gt; (Match -&gt; FilePath)
-&gt; ([Match] -&gt; FilePath -&gt; FilePath)
-&gt; Show Match
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Match -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Match -&gt; FilePath -&gt; FilePath
$cshow :: Match -&gt; FilePath
show :: Match -&gt; FilePath
$cshowList :: [Match] -&gt; FilePath -&gt; FilePath
showList :: [Match] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200515"><span id="local-6989586621679200522"><span class="annot"><span class="annottext">Match -&gt; Match -&gt; Bool
(Match -&gt; Match -&gt; Bool) -&gt; (Match -&gt; Match -&gt; Bool) -&gt; Eq Match
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Match -&gt; Match -&gt; Bool
== :: Match -&gt; Match -&gt; Bool
$c/= :: Match -&gt; Match -&gt; Bool
/= :: Match -&gt; Match -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200528"><span id="local-6989586621679200535"><span id="local-6989586621679200541"><span id="local-6989586621679200545"><span id="local-6989586621679200548"><span id="local-6989586621679200551"><span id="local-6989586621679200554"><span class="annot"><span class="annottext">Eq Match
Eq Match =&gt;
(Match -&gt; Match -&gt; Ordering)
-&gt; (Match -&gt; Match -&gt; Bool)
-&gt; (Match -&gt; Match -&gt; Bool)
-&gt; (Match -&gt; Match -&gt; Bool)
-&gt; (Match -&gt; Match -&gt; Bool)
-&gt; (Match -&gt; Match -&gt; Match)
-&gt; (Match -&gt; Match -&gt; Match)
-&gt; Ord Match
Match -&gt; Match -&gt; Bool
Match -&gt; Match -&gt; Ordering
Match -&gt; Match -&gt; Match
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Match -&gt; Match -&gt; Ordering
compare :: Match -&gt; Match -&gt; Ordering
$c&lt; :: Match -&gt; Match -&gt; Bool
&lt; :: Match -&gt; Match -&gt; Bool
$c&lt;= :: Match -&gt; Match -&gt; Bool
&lt;= :: Match -&gt; Match -&gt; Bool
$c&gt; :: Match -&gt; Match -&gt; Bool
&gt; :: Match -&gt; Match -&gt; Bool
$c&gt;= :: Match -&gt; Match -&gt; Bool
&gt;= :: Match -&gt; Match -&gt; Bool
$cmax :: Match -&gt; Match -&gt; Match
max :: Match -&gt; Match -&gt; Match
$cmin :: Match -&gt; Match -&gt; Match
min :: Match -&gt; Match -&gt; Match
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200559"><span id="local-6989586621679200566"><span id="local-6989586621679200572"><span id="local-6989586621679200574"><span id="local-6989586621679200576"><span id="local-6989586621679200582"><span id="local-6989586621679200587"><span id="local-6989586621679200590"><span id="local-6989586621679200593"><span id="local-6989586621679200596"><span id="local-6989586621679200599"><span id="local-6989586621679200602"><span id="local-6989586621679200607"><span id="local-6989586621679200612"><span class="annot"><span class="annottext">Typeable Match
Typeable Match =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Match -&gt; c Match)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Match)
-&gt; (Match -&gt; Constr)
-&gt; (Match -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Match))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Match))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Match -&gt; Match)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Match -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Match -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match)
-&gt; Data Match
Match -&gt; Constr
Match -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Match -&gt; Match
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Match -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Match -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Match
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Match -&gt; c Match
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Match)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Match)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Match -&gt; c Match
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Match -&gt; c Match
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Match
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Match
$ctoConstr :: Match -&gt; Constr
toConstr :: Match -&gt; Constr
$cdataTypeOf :: Match -&gt; DataType
dataTypeOf :: Match -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Match)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Match)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Match)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Match)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Match -&gt; Match
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Match -&gt; Match
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Match -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Match -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Match -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Match -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match -&gt; m Match
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200617"><span id="local-6989586621679200619"><span class="annot"><span class="annottext">(forall x. Match -&gt; Rep Match x)
-&gt; (forall x. Rep Match x -&gt; Match) -&gt; Generic Match
forall x. Rep Match x -&gt; Match
forall x. Match -&gt; Rep Match x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Match -&gt; Rep Match x
from :: forall x. Match -&gt; Rep Match x
$cto :: forall x. Rep Match x -&gt; Match
to :: forall x. Rep Match x -&gt; Match
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2310"></span><span>
</span><span id="line-2311"></span><span class="hs-keyword">data</span><span> </span><span id="Clause"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Clause"><span class="hs-identifier hs-var">Clause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Clause"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Clause"><span class="hs-identifier hs-var">Clause</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Body"><span class="hs-identifier hs-type">Body</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2312"></span><span>                                  </span><span class="annot"><span class="hs-comment">-- ^ @f { p1 p2 = body where decs }@</span></span><span>
</span><span id="line-2313"></span><span>    </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679200623"><span id="local-6989586621679200631"><span id="local-6989586621679200635"><span class="annot"><span class="annottext">Int -&gt; Clause -&gt; FilePath -&gt; FilePath
[Clause] -&gt; FilePath -&gt; FilePath
Clause -&gt; FilePath
(Int -&gt; Clause -&gt; FilePath -&gt; FilePath)
-&gt; (Clause -&gt; FilePath)
-&gt; ([Clause] -&gt; FilePath -&gt; FilePath)
-&gt; Show Clause
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Clause -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Clause -&gt; FilePath -&gt; FilePath
$cshow :: Clause -&gt; FilePath
show :: Clause -&gt; FilePath
$cshowList :: [Clause] -&gt; FilePath -&gt; FilePath
showList :: [Clause] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200638"><span id="local-6989586621679200645"><span class="annot"><span class="annottext">Clause -&gt; Clause -&gt; Bool
(Clause -&gt; Clause -&gt; Bool)
-&gt; (Clause -&gt; Clause -&gt; Bool) -&gt; Eq Clause
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Clause -&gt; Clause -&gt; Bool
== :: Clause -&gt; Clause -&gt; Bool
$c/= :: Clause -&gt; Clause -&gt; Bool
/= :: Clause -&gt; Clause -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200651"><span id="local-6989586621679200658"><span id="local-6989586621679200665"><span id="local-6989586621679200669"><span id="local-6989586621679200672"><span id="local-6989586621679200675"><span id="local-6989586621679200678"><span class="annot"><span class="annottext">Eq Clause
Eq Clause =&gt;
(Clause -&gt; Clause -&gt; Ordering)
-&gt; (Clause -&gt; Clause -&gt; Bool)
-&gt; (Clause -&gt; Clause -&gt; Bool)
-&gt; (Clause -&gt; Clause -&gt; Bool)
-&gt; (Clause -&gt; Clause -&gt; Bool)
-&gt; (Clause -&gt; Clause -&gt; Clause)
-&gt; (Clause -&gt; Clause -&gt; Clause)
-&gt; Ord Clause
Clause -&gt; Clause -&gt; Bool
Clause -&gt; Clause -&gt; Ordering
Clause -&gt; Clause -&gt; Clause
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Clause -&gt; Clause -&gt; Ordering
compare :: Clause -&gt; Clause -&gt; Ordering
$c&lt; :: Clause -&gt; Clause -&gt; Bool
&lt; :: Clause -&gt; Clause -&gt; Bool
$c&lt;= :: Clause -&gt; Clause -&gt; Bool
&lt;= :: Clause -&gt; Clause -&gt; Bool
$c&gt; :: Clause -&gt; Clause -&gt; Bool
&gt; :: Clause -&gt; Clause -&gt; Bool
$c&gt;= :: Clause -&gt; Clause -&gt; Bool
&gt;= :: Clause -&gt; Clause -&gt; Bool
$cmax :: Clause -&gt; Clause -&gt; Clause
max :: Clause -&gt; Clause -&gt; Clause
$cmin :: Clause -&gt; Clause -&gt; Clause
min :: Clause -&gt; Clause -&gt; Clause
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200683"><span id="local-6989586621679200690"><span id="local-6989586621679200697"><span id="local-6989586621679200699"><span id="local-6989586621679200701"><span id="local-6989586621679200707"><span id="local-6989586621679200712"><span id="local-6989586621679200715"><span id="local-6989586621679200718"><span id="local-6989586621679200721"><span id="local-6989586621679200724"><span id="local-6989586621679200727"><span id="local-6989586621679200732"><span id="local-6989586621679200737"><span class="annot"><span class="annottext">Typeable Clause
Typeable Clause =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Clause -&gt; c Clause)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Clause)
-&gt; (Clause -&gt; Constr)
-&gt; (Clause -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Clause))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Clause))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Clause -&gt; Clause)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Clause -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Clause -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Clause -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Clause -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause)
-&gt; Data Clause
Clause -&gt; Constr
Clause -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Clause -&gt; Clause
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Clause -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Clause -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Clause -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Clause -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Clause
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Clause -&gt; c Clause
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Clause)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Clause)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Clause -&gt; c Clause
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Clause -&gt; c Clause
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Clause
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Clause
$ctoConstr :: Clause -&gt; Constr
toConstr :: Clause -&gt; Constr
$cdataTypeOf :: Clause -&gt; DataType
dataTypeOf :: Clause -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Clause)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Clause)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Clause)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Clause)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Clause -&gt; Clause
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Clause -&gt; Clause
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Clause -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Clause -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Clause -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Clause -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Clause -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Clause -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Clause -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Clause -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Clause -&gt; m Clause
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200742"><span id="local-6989586621679200744"><span class="annot"><span class="annottext">(forall x. Clause -&gt; Rep Clause x)
-&gt; (forall x. Rep Clause x -&gt; Clause) -&gt; Generic Clause
forall x. Rep Clause x -&gt; Clause
forall x. Clause -&gt; Rep Clause x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Clause -&gt; Rep Clause x
from :: forall x. Clause -&gt; Rep Clause x
$cto :: forall x. Rep Clause x -&gt; Clause
to :: forall x. Rep Clause x -&gt; Clause
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2314"></span><span>
</span><span id="line-2315"></span><span class="hs-keyword">data</span><span> </span><span id="Exp"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-var">Exp</span></a></span></span><span>
</span><span id="line-2316"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="VarE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarE"><span class="hs-identifier hs-var">VarE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>                          </span><span class="annot"><span class="hs-comment">-- ^ @{ x }@</span></span><span>
</span><span id="line-2317"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ConE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ConE"><span class="hs-identifier hs-var">ConE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>                          </span><span class="annot"><span class="hs-comment">-- ^ @data T1 = C1 t1 t2; p = {C1} e1 e2  @</span></span><span>
</span><span id="line-2318"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LitE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LitE"><span class="hs-identifier hs-var">LitE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span>                           </span><span class="annot"><span class="hs-comment">-- ^ @{ 5 or \'c\'}@</span></span><span>
</span><span id="line-2319"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="AppE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AppE"><span class="hs-identifier hs-var">AppE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                       </span><span class="annot"><span class="hs-comment">-- ^ @{ f x }@</span></span><span>
</span><span id="line-2320"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="AppTypeE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AppTypeE"><span class="hs-identifier hs-var">AppTypeE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^ @{ f \@Int }@</span></span><span>
</span><span id="line-2321"></span><span>
</span><span id="line-2322"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InfixE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixE"><span class="hs-identifier hs-var">InfixE</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ @{x + y} or {(x+)} or {(+ x)} or {(+)}@</span></span><span>
</span><span id="line-2323"></span><span>
</span><span id="line-2324"></span><span>    </span><span class="hs-comment">-- It's a bit gruesome to use an Exp as the operator when a Name</span><span>
</span><span id="line-2325"></span><span>    </span><span class="hs-comment">-- would suffice. Historically, Exp was used to make it easier to</span><span>
</span><span id="line-2326"></span><span>    </span><span class="hs-comment">-- distinguish between infix constructors and non-constructors.</span><span>
</span><span id="line-2327"></span><span>    </span><span class="hs-comment">-- This is a bit overkill, since one could just as well call</span><span>
</span><span id="line-2328"></span><span>    </span><span class="hs-comment">-- `startsConId` or `startsConSym` (from `GHC.Lexeme`) on a Name.</span><span>
</span><span id="line-2329"></span><span>    </span><span class="hs-comment">-- Unfortunately, changing this design now would involve lots of</span><span>
</span><span id="line-2330"></span><span>    </span><span class="hs-comment">-- code churn for consumers of the TH API, so we continue to use</span><span>
</span><span id="line-2331"></span><span>    </span><span class="hs-comment">-- an Exp as the operator and perform an extra check during conversion</span><span>
</span><span id="line-2332"></span><span>    </span><span class="hs-comment">-- to ensure that the Exp is a constructor or a variable (#16895).</span><span>
</span><span id="line-2333"></span><span>
</span><span id="line-2334"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UInfixE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UInfixE"><span class="hs-identifier hs-var">UInfixE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                </span><span class="hs-comment">-- ^ @{x + y}@</span><span>
</span><span id="line-2335"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2336"></span><span>                                       </span><span class="hs-comment">-- See &quot;Language.Haskell.TH.Syntax#infix&quot;</span><span>
</span><span id="line-2337"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParensE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ParensE"><span class="hs-identifier hs-var">ParensE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                        </span><span class="hs-comment">-- ^ @{ (e) }@</span><span>
</span><span id="line-2338"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2339"></span><span>                                       </span><span class="hs-comment">-- See &quot;Language.Haskell.TH.Syntax#infix&quot;</span><span>
</span><span id="line-2340"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LamE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LamE"><span class="hs-identifier hs-var">LamE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^ @{ \\ p1 p2 -&gt; e }@</span></span><span>
</span><span id="line-2341"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LamCaseE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LamCaseE"><span class="hs-identifier hs-var">LamCaseE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span class="hs-special">]</span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ @{ \\case m1; m2 }@</span></span><span>
</span><span id="line-2342"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LamCasesE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LamCasesE"><span class="hs-identifier hs-var">LamCasesE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Clause"><span class="hs-identifier hs-type">Clause</span></a></span><span class="hs-special">]</span><span>                 </span><span class="annot"><span class="hs-comment">-- ^ @{ \\cases m1; m2 }@</span></span><span>
</span><span id="line-2343"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TupE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TupE"><span class="hs-identifier hs-var">TupE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span class="hs-special">]</span><span>                   </span><span class="hs-comment">-- ^ @{ (e1,e2) }  @</span><span>
</span><span id="line-2344"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2345"></span><span>                                       </span><span class="hs-comment">-- The 'Maybe' is necessary for handling</span><span>
</span><span id="line-2346"></span><span>                                       </span><span class="hs-comment">-- tuple sections.</span><span>
</span><span id="line-2347"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2348"></span><span>                                       </span><span class="hs-comment">-- &gt; (1,)</span><span>
</span><span id="line-2349"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2350"></span><span>                                       </span><span class="hs-comment">-- translates to</span><span>
</span><span id="line-2351"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2352"></span><span>                                       </span><span class="hs-comment">-- &gt; TupE [Just (LitE (IntegerL 1)),Nothing]</span><span>
</span><span id="line-2353"></span><span>
</span><span id="line-2354"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedTupE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UnboxedTupE"><span class="hs-identifier hs-var">UnboxedTupE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span class="hs-special">]</span><span>            </span><span class="hs-comment">-- ^ @{ (\# e1,e2 \#) }  @</span><span>
</span><span id="line-2355"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2356"></span><span>                                       </span><span class="hs-comment">-- The 'Maybe' is necessary for handling</span><span>
</span><span id="line-2357"></span><span>                                       </span><span class="hs-comment">-- tuple sections.</span><span>
</span><span id="line-2358"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2359"></span><span>                                       </span><span class="hs-comment">-- &gt; (# 'c', #)</span><span>
</span><span id="line-2360"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2361"></span><span>                                       </span><span class="hs-comment">-- translates to</span><span>
</span><span id="line-2362"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2363"></span><span>                                       </span><span class="hs-comment">-- &gt; UnboxedTupE [Just (LitE (CharL 'c')),Nothing]</span><span>
</span><span id="line-2364"></span><span>
</span><span id="line-2365"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedSumE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UnboxedSumE"><span class="hs-identifier hs-var">UnboxedSumE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumAlt"><span class="hs-identifier hs-type">SumAlt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumArity"><span class="hs-identifier hs-type">SumArity</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @{ (\#|e|\#) }@</span></span><span>
</span><span id="line-2366"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CondE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CondE"><span class="hs-identifier hs-var">CondE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^ @{ if e1 then e2 else e3 }@</span></span><span>
</span><span id="line-2367"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MultiIfE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#MultiIfE"><span class="hs-identifier hs-var">MultiIfE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Guard"><span class="hs-identifier hs-type">Guard</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">-- ^ @{ if | g1 -&gt; e1 | g2 -&gt; e2 }@</span></span><span>
</span><span id="line-2368"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LetE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LetE"><span class="hs-identifier hs-var">LetE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^ @{ let { x=e1; y=e2 } in e3 }@</span></span><span>
</span><span id="line-2369"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CaseE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CaseE"><span class="hs-identifier hs-var">CaseE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span class="hs-special">]</span><span>                  </span><span class="annot"><span class="hs-comment">-- ^ @{ case e of m1; m2 }@</span></span><span>
</span><span id="line-2370"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DoE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DoE"><span class="hs-identifier hs-var">DoE</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-type">ModName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span class="hs-special">]</span><span>         </span><span class="hs-comment">-- ^ @{ do { p &lt;- e1; e2 }  }@ or a qualified do if</span><span>
</span><span id="line-2371"></span><span>                                       </span><span class="hs-comment">-- the module name is present</span><span>
</span><span id="line-2372"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MDoE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#MDoE"><span class="hs-identifier hs-var">MDoE</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModName"><span class="hs-identifier hs-type">ModName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span class="hs-special">]</span><span>        </span><span class="hs-comment">-- ^ @{ mdo { x &lt;- e1 y; y &lt;- e2 x; } }@ or a qualified</span><span>
</span><span id="line-2373"></span><span>                                       </span><span class="hs-comment">-- mdo if the module name is present</span><span>
</span><span id="line-2374"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CompE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CompE"><span class="hs-identifier hs-var">CompE</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span class="hs-special">]</span><span>                       </span><span class="hs-comment">-- ^ @{ [ (x,y) | x &lt;- xs, y &lt;- ys ] }@</span><span>
</span><span id="line-2375"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-2376"></span><span>      </span><span class="hs-comment">-- The result expression of the comprehension is</span><span>
</span><span id="line-2377"></span><span>      </span><span class="hs-comment">-- the /last/ of the @'Stmt'@s, and should be a 'NoBindS'.</span><span>
</span><span id="line-2378"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-2379"></span><span>      </span><span class="hs-comment">-- E.g. translation:</span><span>
</span><span id="line-2380"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-2381"></span><span>      </span><span class="hs-comment">-- &gt; [ f x | x &lt;- xs ]</span><span>
</span><span id="line-2382"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-2383"></span><span>      </span><span class="hs-comment">-- &gt; CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]</span><span>
</span><span id="line-2384"></span><span>
</span><span id="line-2385"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArithSeqE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ArithSeqE"><span class="hs-identifier hs-var">ArithSeqE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Range"><span class="hs-identifier hs-type">Range</span></a></span><span>                    </span><span class="annot"><span class="hs-comment">-- ^ @{ [ 1 ,2 .. 10 ] }@</span></span><span>
</span><span id="line-2386"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ListE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ListE"><span class="hs-identifier hs-var">ListE</span></a></span></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-special">]</span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @{ [1,2,3] }@</span></span><span>
</span><span id="line-2387"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SigE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SigE"><span class="hs-identifier hs-var">SigE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @{ e :: t }@</span></span><span>
</span><span id="line-2388"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecConE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecConE"><span class="hs-identifier hs-var">RecConE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FieldExp"><span class="hs-identifier hs-type">FieldExp</span></a></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">-- ^ @{ T { x = y, z = w } }@</span></span><span>
</span><span id="line-2389"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecUpdE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecUpdE"><span class="hs-identifier hs-var">RecUpdE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FieldExp"><span class="hs-identifier hs-type">FieldExp</span></a></span><span class="hs-special">]</span><span>             </span><span class="annot"><span class="hs-comment">-- ^ @{ (f x) { z = w } }@</span></span><span>
</span><span id="line-2390"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="StaticE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StaticE"><span class="hs-identifier hs-var">StaticE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                        </span><span class="annot"><span class="hs-comment">-- ^ @{ static e }@</span></span><span>
</span><span id="line-2391"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnboundVarE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UnboundVarE"><span class="hs-identifier hs-var">UnboundVarE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>                   </span><span class="hs-comment">-- ^ @{ _x }@</span><span>
</span><span id="line-2392"></span><span>                                       </span><span class="hs-comment">--</span><span>
</span><span id="line-2393"></span><span>                                       </span><span class="hs-comment">-- This is used for holes or unresolved</span><span>
</span><span id="line-2394"></span><span>                                       </span><span class="hs-comment">-- identifiers in AST quotes. Note that</span><span>
</span><span id="line-2395"></span><span>                                       </span><span class="hs-comment">-- it could either have a variable name</span><span>
</span><span id="line-2396"></span><span>                                       </span><span class="hs-comment">-- or constructor name.</span><span>
</span><span id="line-2397"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LabelE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LabelE"><span class="hs-identifier hs-var">LabelE</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @{ #x }@ ( Overloaded label )</span></span><span>
</span><span id="line-2398"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ImplicitParamVarE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ImplicitParamVarE"><span class="hs-identifier hs-var">ImplicitParamVarE</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ @{ ?x }@ ( Implicit parameter )</span></span><span>
</span><span id="line-2399"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GetFieldE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#GetFieldE"><span class="hs-identifier hs-var">GetFieldE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>               </span><span class="annot"><span class="hs-comment">-- ^ @{ exp.field }@ ( Overloaded Record Dot )</span></span><span>
</span><span id="line-2400"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ProjectionE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ProjectionE"><span class="hs-identifier hs-var">ProjectionE</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span>      </span><span class="annot"><span class="hs-comment">-- ^ @(.x)@ or @(.x.y)@ (Record projections)</span></span><span>
</span><span id="line-2401"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypedBracketE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypedBracketE"><span class="hs-identifier hs-var">TypedBracketE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^ @[|| e ||]@</span></span><span>
</span><span id="line-2402"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypedSpliceE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypedSpliceE"><span class="hs-identifier hs-var">TypedSpliceE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ @$$e@</span></span><span>
</span><span id="line-2403"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeE"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeE"><span class="hs-identifier hs-var">TypeE</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                         </span><span class="annot"><span class="hs-comment">-- ^ @{ type t }@</span></span><span>
</span><span id="line-2404"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679200772"><span id="local-6989586621679200874"><span id="local-6989586621679200877"><span class="annot"><span class="annottext">Int -&gt; Exp -&gt; FilePath -&gt; FilePath
[Exp] -&gt; FilePath -&gt; FilePath
Exp -&gt; FilePath
(Int -&gt; Exp -&gt; FilePath -&gt; FilePath)
-&gt; (Exp -&gt; FilePath) -&gt; ([Exp] -&gt; FilePath -&gt; FilePath) -&gt; Show Exp
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Exp -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Exp -&gt; FilePath -&gt; FilePath
$cshow :: Exp -&gt; FilePath
show :: Exp -&gt; FilePath
$cshowList :: [Exp] -&gt; FilePath -&gt; FilePath
showList :: [Exp] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200883"><span id="local-6989586621679200952"><span class="annot"><span class="annottext">Exp -&gt; Exp -&gt; Bool
(Exp -&gt; Exp -&gt; Bool) -&gt; (Exp -&gt; Exp -&gt; Bool) -&gt; Eq Exp
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Exp -&gt; Exp -&gt; Bool
== :: Exp -&gt; Exp -&gt; Bool
$c/= :: Exp -&gt; Exp -&gt; Bool
/= :: Exp -&gt; Exp -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679200960"><span id="local-6989586621679201058"><span id="local-6989586621679201061"><span id="local-6989586621679201064"><span id="local-6989586621679201067"><span id="local-6989586621679201070"><span id="local-6989586621679201073"><span class="annot"><span class="annottext">Eq Exp
Eq Exp =&gt;
(Exp -&gt; Exp -&gt; Ordering)
-&gt; (Exp -&gt; Exp -&gt; Bool)
-&gt; (Exp -&gt; Exp -&gt; Bool)
-&gt; (Exp -&gt; Exp -&gt; Bool)
-&gt; (Exp -&gt; Exp -&gt; Bool)
-&gt; (Exp -&gt; Exp -&gt; Exp)
-&gt; (Exp -&gt; Exp -&gt; Exp)
-&gt; Ord Exp
Exp -&gt; Exp -&gt; Bool
Exp -&gt; Exp -&gt; Ordering
Exp -&gt; Exp -&gt; Exp
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Exp -&gt; Exp -&gt; Ordering
compare :: Exp -&gt; Exp -&gt; Ordering
$c&lt; :: Exp -&gt; Exp -&gt; Bool
&lt; :: Exp -&gt; Exp -&gt; Bool
$c&lt;= :: Exp -&gt; Exp -&gt; Bool
&lt;= :: Exp -&gt; Exp -&gt; Bool
$c&gt; :: Exp -&gt; Exp -&gt; Bool
&gt; :: Exp -&gt; Exp -&gt; Bool
$c&gt;= :: Exp -&gt; Exp -&gt; Bool
&gt;= :: Exp -&gt; Exp -&gt; Bool
$cmax :: Exp -&gt; Exp -&gt; Exp
max :: Exp -&gt; Exp -&gt; Exp
$cmin :: Exp -&gt; Exp -&gt; Exp
min :: Exp -&gt; Exp -&gt; Exp
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201081"><span id="local-6989586621679201148"><span id="local-6989586621679201213"><span id="local-6989586621679201215"><span id="local-6989586621679201217"><span id="local-6989586621679201222"><span id="local-6989586621679201227"><span id="local-6989586621679201230"><span id="local-6989586621679201233"><span id="local-6989586621679201236"><span id="local-6989586621679201239"><span id="local-6989586621679201242"><span id="local-6989586621679201247"><span id="local-6989586621679201252"><span class="annot"><span class="annottext">Typeable Exp
Typeable Exp =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Exp -&gt; c Exp)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Exp)
-&gt; (Exp -&gt; Constr)
-&gt; (Exp -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Exp))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Exp))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Exp -&gt; Exp)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Exp -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp)
-&gt; Data Exp
Exp -&gt; Constr
Exp -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Exp -&gt; Exp
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Exp -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Exp
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Exp -&gt; c Exp
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Exp)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Exp)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Exp -&gt; c Exp
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Exp -&gt; c Exp
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Exp
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Exp
$ctoConstr :: Exp -&gt; Constr
toConstr :: Exp -&gt; Constr
$cdataTypeOf :: Exp -&gt; DataType
dataTypeOf :: Exp -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Exp)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Exp)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Exp)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Exp)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Exp -&gt; Exp
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Exp -&gt; Exp
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Exp -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Exp -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp -&gt; m Exp
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201261"><span id="local-6989586621679201263"><span class="annot"><span class="annottext">(forall x. Exp -&gt; Rep Exp x)
-&gt; (forall x. Rep Exp x -&gt; Exp) -&gt; Generic Exp
forall x. Rep Exp x -&gt; Exp
forall x. Exp -&gt; Rep Exp x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Exp -&gt; Rep Exp x
from :: forall x. Exp -&gt; Rep Exp x
$cto :: forall x. Rep Exp x -&gt; Exp
to :: forall x. Rep Exp x -&gt; Exp
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2405"></span><span>
</span><span id="line-2406"></span><span class="hs-keyword">type</span><span> </span><span id="FieldExp"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FieldExp"><span class="hs-identifier hs-var">FieldExp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2407"></span><span>
</span><span id="line-2408"></span><span class="hs-comment">-- Omitted: implicit parameters</span><span>
</span><span id="line-2409"></span><span>
</span><span id="line-2410"></span><span class="hs-keyword">data</span><span> </span><span id="Body"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Body"><span class="hs-identifier hs-var">Body</span></a></span></span><span>
</span><span id="line-2411"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="GuardedB"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#GuardedB"><span class="hs-identifier hs-var">GuardedB</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Guard"><span class="hs-identifier hs-type">Guard</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>   </span><span class="hs-comment">-- ^ @f p { | e1 = e2</span><span>
</span><span id="line-2412"></span><span>                                 </span><span class="hs-comment">--      | e3 = e4 }</span><span>
</span><span id="line-2413"></span><span>                                 </span><span class="hs-comment">-- where ds@</span><span>
</span><span id="line-2414"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NormalB"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NormalB"><span class="hs-identifier hs-var">NormalB</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ @f p { = e } where ds@</span></span><span>
</span><span id="line-2415"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679201268"><span id="local-6989586621679201276"><span id="local-6989586621679201279"><span class="annot"><span class="annottext">Int -&gt; Body -&gt; FilePath -&gt; FilePath
[Body] -&gt; FilePath -&gt; FilePath
Body -&gt; FilePath
(Int -&gt; Body -&gt; FilePath -&gt; FilePath)
-&gt; (Body -&gt; FilePath)
-&gt; ([Body] -&gt; FilePath -&gt; FilePath)
-&gt; Show Body
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Body -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Body -&gt; FilePath -&gt; FilePath
$cshow :: Body -&gt; FilePath
show :: Body -&gt; FilePath
$cshowList :: [Body] -&gt; FilePath -&gt; FilePath
showList :: [Body] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201283"><span id="local-6989586621679201291"><span class="annot"><span class="annottext">Body -&gt; Body -&gt; Bool
(Body -&gt; Body -&gt; Bool) -&gt; (Body -&gt; Body -&gt; Bool) -&gt; Eq Body
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Body -&gt; Body -&gt; Bool
== :: Body -&gt; Body -&gt; Bool
$c/= :: Body -&gt; Body -&gt; Bool
/= :: Body -&gt; Body -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201297"><span id="local-6989586621679201303"><span id="local-6989586621679201309"><span id="local-6989586621679201312"><span id="local-6989586621679201315"><span id="local-6989586621679201318"><span id="local-6989586621679201321"><span class="annot"><span class="annottext">Eq Body
Eq Body =&gt;
(Body -&gt; Body -&gt; Ordering)
-&gt; (Body -&gt; Body -&gt; Bool)
-&gt; (Body -&gt; Body -&gt; Bool)
-&gt; (Body -&gt; Body -&gt; Bool)
-&gt; (Body -&gt; Body -&gt; Bool)
-&gt; (Body -&gt; Body -&gt; Body)
-&gt; (Body -&gt; Body -&gt; Body)
-&gt; Ord Body
Body -&gt; Body -&gt; Bool
Body -&gt; Body -&gt; Ordering
Body -&gt; Body -&gt; Body
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Body -&gt; Body -&gt; Ordering
compare :: Body -&gt; Body -&gt; Ordering
$c&lt; :: Body -&gt; Body -&gt; Bool
&lt; :: Body -&gt; Body -&gt; Bool
$c&lt;= :: Body -&gt; Body -&gt; Bool
&lt;= :: Body -&gt; Body -&gt; Bool
$c&gt; :: Body -&gt; Body -&gt; Bool
&gt; :: Body -&gt; Body -&gt; Bool
$c&gt;= :: Body -&gt; Body -&gt; Bool
&gt;= :: Body -&gt; Body -&gt; Bool
$cmax :: Body -&gt; Body -&gt; Body
max :: Body -&gt; Body -&gt; Body
$cmin :: Body -&gt; Body -&gt; Body
min :: Body -&gt; Body -&gt; Body
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201328"><span id="local-6989586621679201334"><span id="local-6989586621679201340"><span id="local-6989586621679201342"><span id="local-6989586621679201344"><span id="local-6989586621679201349"><span id="local-6989586621679201354"><span id="local-6989586621679201357"><span id="local-6989586621679201360"><span id="local-6989586621679201363"><span id="local-6989586621679201366"><span id="local-6989586621679201369"><span id="local-6989586621679201374"><span id="local-6989586621679201379"><span class="annot"><span class="annottext">Typeable Body
Typeable Body =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Body -&gt; c Body)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Body)
-&gt; (Body -&gt; Constr)
-&gt; (Body -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Body))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Body))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Body -&gt; Body)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Body -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Body -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Body -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Body -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body)
-&gt; Data Body
Body -&gt; Constr
Body -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Body -&gt; Body
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Body -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Body -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Body -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Body -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Body
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Body -&gt; c Body
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Body)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Body)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Body -&gt; c Body
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Body -&gt; c Body
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Body
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Body
$ctoConstr :: Body -&gt; Constr
toConstr :: Body -&gt; Constr
$cdataTypeOf :: Body -&gt; DataType
dataTypeOf :: Body -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Body)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Body)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Body)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Body)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Body -&gt; Body
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Body -&gt; Body
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Body -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Body -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Body -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Body -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Body -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Body -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Body -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Body -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Body -&gt; m Body
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201386"><span id="local-6989586621679201388"><span class="annot"><span class="annottext">(forall x. Body -&gt; Rep Body x)
-&gt; (forall x. Rep Body x -&gt; Body) -&gt; Generic Body
forall x. Rep Body x -&gt; Body
forall x. Body -&gt; Rep Body x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Body -&gt; Rep Body x
from :: forall x. Body -&gt; Rep Body x
$cto :: forall x. Rep Body x -&gt; Body
to :: forall x. Rep Body x -&gt; Body
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2416"></span><span>
</span><span id="line-2417"></span><span class="hs-keyword">data</span><span> </span><span id="Guard"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Guard"><span class="hs-identifier hs-var">Guard</span></a></span></span><span>
</span><span id="line-2418"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NormalG"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NormalG"><span class="hs-identifier hs-var">NormalG</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @f x { | odd x } = x@</span></span><span>
</span><span id="line-2419"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatG"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatG"><span class="hs-identifier hs-var">PatG</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ @f x { | Just y &lt;- x, Just z &lt;- y } = z@</span></span><span>
</span><span id="line-2420"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679201393"><span id="local-6989586621679201400"><span id="local-6989586621679201403"><span class="annot"><span class="annottext">Int -&gt; Guard -&gt; FilePath -&gt; FilePath
[Guard] -&gt; FilePath -&gt; FilePath
Guard -&gt; FilePath
(Int -&gt; Guard -&gt; FilePath -&gt; FilePath)
-&gt; (Guard -&gt; FilePath)
-&gt; ([Guard] -&gt; FilePath -&gt; FilePath)
-&gt; Show Guard
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Guard -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Guard -&gt; FilePath -&gt; FilePath
$cshow :: Guard -&gt; FilePath
show :: Guard -&gt; FilePath
$cshowList :: [Guard] -&gt; FilePath -&gt; FilePath
showList :: [Guard] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201406"><span id="local-6989586621679201413"><span class="annot"><span class="annottext">Guard -&gt; Guard -&gt; Bool
(Guard -&gt; Guard -&gt; Bool) -&gt; (Guard -&gt; Guard -&gt; Bool) -&gt; Eq Guard
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Guard -&gt; Guard -&gt; Bool
== :: Guard -&gt; Guard -&gt; Bool
$c/= :: Guard -&gt; Guard -&gt; Bool
/= :: Guard -&gt; Guard -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201418"><span id="local-6989586621679201423"><span id="local-6989586621679201428"><span id="local-6989586621679201431"><span id="local-6989586621679201434"><span id="local-6989586621679201437"><span id="local-6989586621679201440"><span class="annot"><span class="annottext">Eq Guard
Eq Guard =&gt;
(Guard -&gt; Guard -&gt; Ordering)
-&gt; (Guard -&gt; Guard -&gt; Bool)
-&gt; (Guard -&gt; Guard -&gt; Bool)
-&gt; (Guard -&gt; Guard -&gt; Bool)
-&gt; (Guard -&gt; Guard -&gt; Bool)
-&gt; (Guard -&gt; Guard -&gt; Guard)
-&gt; (Guard -&gt; Guard -&gt; Guard)
-&gt; Ord Guard
Guard -&gt; Guard -&gt; Bool
Guard -&gt; Guard -&gt; Ordering
Guard -&gt; Guard -&gt; Guard
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Guard -&gt; Guard -&gt; Ordering
compare :: Guard -&gt; Guard -&gt; Ordering
$c&lt; :: Guard -&gt; Guard -&gt; Bool
&lt; :: Guard -&gt; Guard -&gt; Bool
$c&lt;= :: Guard -&gt; Guard -&gt; Bool
&lt;= :: Guard -&gt; Guard -&gt; Bool
$c&gt; :: Guard -&gt; Guard -&gt; Bool
&gt; :: Guard -&gt; Guard -&gt; Bool
$c&gt;= :: Guard -&gt; Guard -&gt; Bool
&gt;= :: Guard -&gt; Guard -&gt; Bool
$cmax :: Guard -&gt; Guard -&gt; Guard
max :: Guard -&gt; Guard -&gt; Guard
$cmin :: Guard -&gt; Guard -&gt; Guard
min :: Guard -&gt; Guard -&gt; Guard
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201445"><span id="local-6989586621679201450"><span id="local-6989586621679201455"><span id="local-6989586621679201457"><span id="local-6989586621679201459"><span id="local-6989586621679201464"><span id="local-6989586621679201469"><span id="local-6989586621679201472"><span id="local-6989586621679201475"><span id="local-6989586621679201478"><span id="local-6989586621679201481"><span id="local-6989586621679201484"><span id="local-6989586621679201489"><span id="local-6989586621679201494"><span class="annot"><span class="annottext">Typeable Guard
Typeable Guard =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Guard -&gt; c Guard)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Guard)
-&gt; (Guard -&gt; Constr)
-&gt; (Guard -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Guard))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Guard))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Guard -&gt; Guard)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Guard -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Guard -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Guard -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Guard -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard)
-&gt; Data Guard
Guard -&gt; Constr
Guard -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Guard -&gt; Guard
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Guard -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Guard -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Guard -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Guard -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Guard
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Guard -&gt; c Guard
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Guard)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Guard)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Guard -&gt; c Guard
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Guard -&gt; c Guard
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Guard
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Guard
$ctoConstr :: Guard -&gt; Constr
toConstr :: Guard -&gt; Constr
$cdataTypeOf :: Guard -&gt; DataType
dataTypeOf :: Guard -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Guard)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Guard)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Guard)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Guard)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Guard -&gt; Guard
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Guard -&gt; Guard
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Guard -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Guard -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Guard -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Guard -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Guard -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Guard -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Guard -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Guard -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Guard -&gt; m Guard
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201499"><span id="local-6989586621679201501"><span class="annot"><span class="annottext">(forall x. Guard -&gt; Rep Guard x)
-&gt; (forall x. Rep Guard x -&gt; Guard) -&gt; Generic Guard
forall x. Rep Guard x -&gt; Guard
forall x. Guard -&gt; Rep Guard x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Guard -&gt; Rep Guard x
from :: forall x. Guard -&gt; Rep Guard x
$cto :: forall x. Rep Guard x -&gt; Guard
to :: forall x. Rep Guard x -&gt; Guard
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2421"></span><span>
</span><span id="line-2422"></span><span class="hs-keyword">data</span><span> </span><span id="Stmt"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Stmt"><span class="hs-identifier hs-var">Stmt</span></a></span></span><span>
</span><span id="line-2423"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="BindS"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BindS"><span class="hs-identifier hs-var">BindS</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @p &lt;- e@</span></span><span>
</span><span id="line-2424"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LetS"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LetS"><span class="hs-identifier hs-var">LetS</span></a></span></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span> </span><span class="hs-special">]</span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @{ let { x=e1; y=e2 } }@</span></span><span>
</span><span id="line-2425"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NoBindS"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NoBindS"><span class="hs-identifier hs-var">NoBindS</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @e@</span></span><span>
</span><span id="line-2426"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParS"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ParS"><span class="hs-identifier hs-var">ParS</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ @x &lt;- e1 | s2, s3 | s4@ (in 'CompE')</span></span><span>
</span><span id="line-2427"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecS"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecS"><span class="hs-identifier hs-var">RecS</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span class="hs-special">]</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @rec { s1; s2 }@</span></span><span>
</span><span id="line-2428"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679201508"><span id="local-6989586621679201523"><span id="local-6989586621679201526"><span class="annot"><span class="annottext">Int -&gt; Stmt -&gt; FilePath -&gt; FilePath
[Stmt] -&gt; FilePath -&gt; FilePath
Stmt -&gt; FilePath
(Int -&gt; Stmt -&gt; FilePath -&gt; FilePath)
-&gt; (Stmt -&gt; FilePath)
-&gt; ([Stmt] -&gt; FilePath -&gt; FilePath)
-&gt; Show Stmt
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Stmt -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Stmt -&gt; FilePath -&gt; FilePath
$cshow :: Stmt -&gt; FilePath
show :: Stmt -&gt; FilePath
$cshowList :: [Stmt] -&gt; FilePath -&gt; FilePath
showList :: [Stmt] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201530"><span id="local-6989586621679201542"><span class="annot"><span class="annottext">Stmt -&gt; Stmt -&gt; Bool
(Stmt -&gt; Stmt -&gt; Bool) -&gt; (Stmt -&gt; Stmt -&gt; Bool) -&gt; Eq Stmt
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Stmt -&gt; Stmt -&gt; Bool
== :: Stmt -&gt; Stmt -&gt; Bool
$c/= :: Stmt -&gt; Stmt -&gt; Bool
/= :: Stmt -&gt; Stmt -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201548"><span id="local-6989586621679201559"><span id="local-6989586621679201562"><span id="local-6989586621679201565"><span id="local-6989586621679201568"><span id="local-6989586621679201571"><span id="local-6989586621679201574"><span class="annot"><span class="annottext">Eq Stmt
Eq Stmt =&gt;
(Stmt -&gt; Stmt -&gt; Ordering)
-&gt; (Stmt -&gt; Stmt -&gt; Bool)
-&gt; (Stmt -&gt; Stmt -&gt; Bool)
-&gt; (Stmt -&gt; Stmt -&gt; Bool)
-&gt; (Stmt -&gt; Stmt -&gt; Bool)
-&gt; (Stmt -&gt; Stmt -&gt; Stmt)
-&gt; (Stmt -&gt; Stmt -&gt; Stmt)
-&gt; Ord Stmt
Stmt -&gt; Stmt -&gt; Bool
Stmt -&gt; Stmt -&gt; Ordering
Stmt -&gt; Stmt -&gt; Stmt
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Stmt -&gt; Stmt -&gt; Ordering
compare :: Stmt -&gt; Stmt -&gt; Ordering
$c&lt; :: Stmt -&gt; Stmt -&gt; Bool
&lt; :: Stmt -&gt; Stmt -&gt; Bool
$c&lt;= :: Stmt -&gt; Stmt -&gt; Bool
&lt;= :: Stmt -&gt; Stmt -&gt; Bool
$c&gt; :: Stmt -&gt; Stmt -&gt; Bool
&gt; :: Stmt -&gt; Stmt -&gt; Bool
$c&gt;= :: Stmt -&gt; Stmt -&gt; Bool
&gt;= :: Stmt -&gt; Stmt -&gt; Bool
$cmax :: Stmt -&gt; Stmt -&gt; Stmt
max :: Stmt -&gt; Stmt -&gt; Stmt
$cmin :: Stmt -&gt; Stmt -&gt; Stmt
min :: Stmt -&gt; Stmt -&gt; Stmt
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201580"><span id="local-6989586621679201590"><span id="local-6989586621679201600"><span id="local-6989586621679201602"><span id="local-6989586621679201604"><span id="local-6989586621679201609"><span id="local-6989586621679201614"><span id="local-6989586621679201617"><span id="local-6989586621679201620"><span id="local-6989586621679201623"><span id="local-6989586621679201626"><span id="local-6989586621679201629"><span id="local-6989586621679201634"><span id="local-6989586621679201639"><span class="annot"><span class="annottext">Typeable Stmt
Typeable Stmt =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Stmt -&gt; c Stmt)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Stmt)
-&gt; (Stmt -&gt; Constr)
-&gt; (Stmt -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Stmt))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Stmt))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Stmt -&gt; Stmt)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt)
-&gt; Data Stmt
Stmt -&gt; Constr
Stmt -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Stmt -&gt; Stmt
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Stmt
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Stmt -&gt; c Stmt
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Stmt)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Stmt)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Stmt -&gt; c Stmt
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Stmt -&gt; c Stmt
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Stmt
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Stmt
$ctoConstr :: Stmt -&gt; Constr
toConstr :: Stmt -&gt; Constr
$cdataTypeOf :: Stmt -&gt; DataType
dataTypeOf :: Stmt -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Stmt)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Stmt)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Stmt)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Stmt)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Stmt -&gt; Stmt
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Stmt -&gt; Stmt
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt -&gt; m Stmt
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201646"><span id="local-6989586621679201648"><span class="annot"><span class="annottext">(forall x. Stmt -&gt; Rep Stmt x)
-&gt; (forall x. Rep Stmt x -&gt; Stmt) -&gt; Generic Stmt
forall x. Rep Stmt x -&gt; Stmt
forall x. Stmt -&gt; Rep Stmt x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Stmt -&gt; Rep Stmt x
from :: forall x. Stmt -&gt; Rep Stmt x
$cto :: forall x. Rep Stmt x -&gt; Stmt
to :: forall x. Rep Stmt x -&gt; Stmt
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2429"></span><span>
</span><span id="line-2430"></span><span class="hs-keyword">data</span><span> </span><span id="Range"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Range"><span class="hs-identifier hs-var">Range</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="FromR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FromR"><span class="hs-identifier hs-var">FromR</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="FromThenR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FromThenR"><span class="hs-identifier hs-var">FromThenR</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>
</span><span id="line-2431"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="FromToR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FromToR"><span class="hs-identifier hs-var">FromToR</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="FromThenToR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FromThenToR"><span class="hs-identifier hs-var">FromThenToR</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>
</span><span id="line-2432"></span><span>          </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679201655"><span id="local-6989586621679201669"><span id="local-6989586621679201672"><span class="annot"><span class="annottext">Int -&gt; Range -&gt; FilePath -&gt; FilePath
[Range] -&gt; FilePath -&gt; FilePath
Range -&gt; FilePath
(Int -&gt; Range -&gt; FilePath -&gt; FilePath)
-&gt; (Range -&gt; FilePath)
-&gt; ([Range] -&gt; FilePath -&gt; FilePath)
-&gt; Show Range
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Range -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Range -&gt; FilePath -&gt; FilePath
$cshow :: Range -&gt; FilePath
show :: Range -&gt; FilePath
$cshowList :: [Range] -&gt; FilePath -&gt; FilePath
showList :: [Range] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201675"><span id="local-6989586621679201687"><span class="annot"><span class="annottext">Range -&gt; Range -&gt; Bool
(Range -&gt; Range -&gt; Bool) -&gt; (Range -&gt; Range -&gt; Bool) -&gt; Eq Range
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Range -&gt; Range -&gt; Bool
== :: Range -&gt; Range -&gt; Bool
$c/= :: Range -&gt; Range -&gt; Bool
/= :: Range -&gt; Range -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201692"><span id="local-6989586621679201702"><span id="local-6989586621679201705"><span id="local-6989586621679201708"><span id="local-6989586621679201711"><span id="local-6989586621679201714"><span id="local-6989586621679201717"><span class="annot"><span class="annottext">Eq Range
Eq Range =&gt;
(Range -&gt; Range -&gt; Ordering)
-&gt; (Range -&gt; Range -&gt; Bool)
-&gt; (Range -&gt; Range -&gt; Bool)
-&gt; (Range -&gt; Range -&gt; Bool)
-&gt; (Range -&gt; Range -&gt; Bool)
-&gt; (Range -&gt; Range -&gt; Range)
-&gt; (Range -&gt; Range -&gt; Range)
-&gt; Ord Range
Range -&gt; Range -&gt; Bool
Range -&gt; Range -&gt; Ordering
Range -&gt; Range -&gt; Range
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Range -&gt; Range -&gt; Ordering
compare :: Range -&gt; Range -&gt; Ordering
$c&lt; :: Range -&gt; Range -&gt; Bool
&lt; :: Range -&gt; Range -&gt; Bool
$c&lt;= :: Range -&gt; Range -&gt; Bool
&lt;= :: Range -&gt; Range -&gt; Bool
$c&gt; :: Range -&gt; Range -&gt; Bool
&gt; :: Range -&gt; Range -&gt; Bool
$c&gt;= :: Range -&gt; Range -&gt; Bool
&gt;= :: Range -&gt; Range -&gt; Bool
$cmax :: Range -&gt; Range -&gt; Range
max :: Range -&gt; Range -&gt; Range
$cmin :: Range -&gt; Range -&gt; Range
min :: Range -&gt; Range -&gt; Range
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201722"><span id="local-6989586621679201732"><span id="local-6989586621679201742"><span id="local-6989586621679201744"><span id="local-6989586621679201746"><span id="local-6989586621679201751"><span id="local-6989586621679201756"><span id="local-6989586621679201759"><span id="local-6989586621679201762"><span id="local-6989586621679201765"><span id="local-6989586621679201768"><span id="local-6989586621679201771"><span id="local-6989586621679201776"><span id="local-6989586621679201781"><span class="annot"><span class="annottext">Typeable Range
Typeable Range =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Range -&gt; c Range)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Range)
-&gt; (Range -&gt; Constr)
-&gt; (Range -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Range))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Range))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Range -&gt; Range)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Range -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Range -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Range -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Range -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range)
-&gt; Data Range
Range -&gt; Constr
Range -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Range -&gt; Range
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Range -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Range -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Range -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Range -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Range
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Range -&gt; c Range
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Range)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Range)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Range -&gt; c Range
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Range -&gt; c Range
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Range
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Range
$ctoConstr :: Range -&gt; Constr
toConstr :: Range -&gt; Constr
$cdataTypeOf :: Range -&gt; DataType
dataTypeOf :: Range -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Range)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Range)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Range)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Range)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Range -&gt; Range
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Range -&gt; Range
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Range -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Range -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Range -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Range -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Range -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Range -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Range -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Range -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Range -&gt; m Range
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201786"><span id="local-6989586621679201788"><span class="annot"><span class="annottext">(forall x. Range -&gt; Rep Range x)
-&gt; (forall x. Rep Range x -&gt; Range) -&gt; Generic Range
forall x. Rep Range x -&gt; Range
forall x. Range -&gt; Rep Range x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Range -&gt; Rep Range x
from :: forall x. Range -&gt; Rep Range x
$cto :: forall x. Rep Range x -&gt; Range
to :: forall x. Rep Range x -&gt; Range
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2433"></span><span>
</span><span id="line-2434"></span><span class="hs-keyword">data</span><span> </span><span id="Dec"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-var">Dec</span></a></span></span><span>
</span><span id="line-2435"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="FunD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FunD"><span class="hs-identifier hs-var">FunD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Clause"><span class="hs-identifier hs-type">Clause</span></a></span><span class="hs-special">]</span><span>            </span><span class="annot"><span class="hs-comment">-- ^ @{ f p1 p2 = b where decs }@</span></span><span>
</span><span id="line-2436"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ValD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ValD"><span class="hs-identifier hs-var">ValD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Body"><span class="hs-identifier hs-type">Body</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span>           </span><span class="annot"><span class="hs-comment">-- ^ @{ p = b where decs }@</span></span><span>
</span><span id="line-2437"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DataD"><span class="hs-identifier hs-var">DataD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrVis"><span class="hs-identifier hs-type">BndrVis</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2438"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span class="hs-special">)</span><span>            </span><span class="hs-comment">-- Kind signature (allowed only for GADTs)</span><span>
</span><span id="line-2439"></span><span>          </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivClause"><span class="hs-identifier hs-type">DerivClause</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2440"></span><span>                                  </span><span class="hs-comment">-- ^ @{ data Cxt x =&gt; T x = A x | B (T x)</span><span>
</span><span id="line-2441"></span><span>                                  </span><span class="hs-comment">--       deriving (Z,W)</span><span>
</span><span id="line-2442"></span><span>                                  </span><span class="hs-comment">--       deriving stock Eq }@</span><span>
</span><span id="line-2443"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NewtypeD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NewtypeD"><span class="hs-identifier hs-var">NewtypeD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrVis"><span class="hs-identifier hs-type">BndrVis</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2444"></span><span>             </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- Kind signature</span><span>
</span><span id="line-2445"></span><span>             </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivClause"><span class="hs-identifier hs-type">DerivClause</span></a></span><span class="hs-special">]</span><span>    </span><span class="hs-comment">-- ^ @{ newtype Cxt x =&gt; T x = A (B x)</span><span>
</span><span id="line-2446"></span><span>                                  </span><span class="hs-comment">--       deriving (Z,W Q)</span><span>
</span><span id="line-2447"></span><span>                                  </span><span class="hs-comment">--       deriving stock Eq }@</span><span>
</span><span id="line-2448"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeDataD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeDataD"><span class="hs-identifier hs-var">TypeDataD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrVis"><span class="hs-identifier hs-type">BndrVis</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2449"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span class="hs-special">)</span><span>            </span><span class="hs-comment">-- Kind signature (allowed only for GADTs)</span><span>
</span><span id="line-2450"></span><span>          </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span class="hs-special">]</span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ @{ type data T x = A x | B (T x) }@</span></span><span>
</span><span id="line-2451"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TySynD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TySynD"><span class="hs-identifier hs-var">TySynD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrVis"><span class="hs-identifier hs-type">BndrVis</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @{ type T x = (x,x) }@</span></span><span>
</span><span id="line-2452"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ClassD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ClassD"><span class="hs-identifier hs-var">ClassD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrVis"><span class="hs-identifier hs-type">BndrVis</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2453"></span><span>         </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FunDep"><span class="hs-identifier hs-type">FunDep</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span>           </span><span class="annot"><span class="hs-comment">-- ^ @{ class Eq a =&gt; Ord a where ds }@</span></span><span>
</span><span id="line-2454"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InstanceD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InstanceD"><span class="hs-identifier hs-var">InstanceD</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Overlap"><span class="hs-identifier hs-type">Overlap</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Dec"><span class="hs-identifier hs-type">Dec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2455"></span><span>                                  </span><span class="hs-comment">-- ^ @{ instance {\-\# OVERLAPS \#-\}</span><span>
</span><span id="line-2456"></span><span>                                  </span><span class="hs-comment">--        Show w =&gt; Show [w] where ds }@</span><span>
</span><span id="line-2457"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SigD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SigD"><span class="hs-identifier hs-var">SigD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                </span><span class="annot"><span class="hs-comment">-- ^ @{ length :: [a] -&gt; Int }@</span></span><span>
</span><span id="line-2458"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="KiSigD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#KiSigD"><span class="hs-identifier hs-var">KiSigD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ @{ type TypeRep :: k -&gt; Type }@</span></span><span>
</span><span id="line-2459"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ForeignD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ForeignD"><span class="hs-identifier hs-var">ForeignD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Foreign"><span class="hs-identifier hs-type">Foreign</span></a></span><span>              </span><span class="hs-comment">-- ^ @{ foreign import ... }</span><span>
</span><span id="line-2460"></span><span>                                  </span><span class="hs-comment">--{ foreign export ... }@</span><span>
</span><span id="line-2461"></span><span>
</span><span id="line-2462"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InfixD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixD"><span class="hs-identifier hs-var">InfixD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NamespaceSpecifier"><span class="hs-identifier hs-type">NamespaceSpecifier</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2463"></span><span>                                  </span><span class="annot"><span class="hs-comment">-- ^ @{ infix 3 data foo }@</span></span><span>
</span><span id="line-2464"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DefaultD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DefaultD"><span class="hs-identifier hs-var">DefaultD</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>               </span><span class="annot"><span class="hs-comment">-- ^ @{ default (Integer, Double) }@</span></span><span>
</span><span id="line-2465"></span><span>
</span><span id="line-2466"></span><span>  </span><span class="annot"><span class="hs-comment">-- | pragmas</span></span><span>
</span><span id="line-2467"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PragmaD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PragmaD"><span class="hs-identifier hs-var">PragmaD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pragma"><span class="hs-identifier hs-type">Pragma</span></a></span><span>                </span><span class="annot"><span class="hs-comment">-- ^ @{ {\-\# INLINE [1] foo \#-\} }@</span></span><span>
</span><span id="line-2468"></span><span>
</span><span id="line-2469"></span><span>  </span><span class="annot"><span class="hs-comment">-- | data families (may also appear in [Dec] of 'ClassD' and 'InstanceD')</span></span><span>
</span><span id="line-2470"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataFamilyD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DataFamilyD"><span class="hs-identifier hs-var">DataFamilyD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrVis"><span class="hs-identifier hs-type">BndrVis</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2471"></span><span>               </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2472"></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ @{ data family T a b c :: * }@</span></span><span>
</span><span id="line-2473"></span><span>
</span><span id="line-2474"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataInstD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DataInstD"><span class="hs-identifier hs-var">DataInstD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2475"></span><span>             </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- Kind signature</span><span>
</span><span id="line-2476"></span><span>             </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivClause"><span class="hs-identifier hs-type">DerivClause</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ^ @{ data instance Cxt x =&gt; T [x]</span><span>
</span><span id="line-2477"></span><span>                                  </span><span class="hs-comment">--       = A x | B (T x)</span><span>
</span><span id="line-2478"></span><span>                                  </span><span class="hs-comment">--       deriving (Z,W)</span><span>
</span><span id="line-2479"></span><span>                                  </span><span class="hs-comment">--       deriving stock Eq }@</span><span>
</span><span id="line-2480"></span><span>
</span><span id="line-2481"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NewtypeInstD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NewtypeInstD"><span class="hs-identifier hs-var">NewtypeInstD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-comment">-- Quantified type vars</span><span>
</span><span id="line-2482"></span><span>                 </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- Kind signature</span><span>
</span><span id="line-2483"></span><span>                 </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivClause"><span class="hs-identifier hs-type">DerivClause</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ @{ newtype instance Cxt x =&gt; T [x]</span><span>
</span><span id="line-2484"></span><span>                                   </span><span class="hs-comment">--        = A (B x)</span><span>
</span><span id="line-2485"></span><span>                                   </span><span class="hs-comment">--        deriving (Z,W)</span><span>
</span><span id="line-2486"></span><span>                                   </span><span class="hs-comment">--        deriving stock Eq }@</span><span>
</span><span id="line-2487"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TySynInstD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TySynInstD"><span class="hs-identifier hs-var">TySynInstD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TySynEqn"><span class="hs-identifier hs-type">TySynEqn</span></a></span><span>            </span><span class="annot"><span class="hs-comment">-- ^ @{ type instance ... }@</span></span><span>
</span><span id="line-2488"></span><span>
</span><span id="line-2489"></span><span>  </span><span class="annot"><span class="hs-comment">-- | open type families (may also appear in [Dec] of 'ClassD' and 'InstanceD')</span></span><span>
</span><span id="line-2490"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="OpenTypeFamilyD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#OpenTypeFamilyD"><span class="hs-identifier hs-var">OpenTypeFamilyD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeFamilyHead"><span class="hs-identifier hs-type">TypeFamilyHead</span></a></span><span>
</span><span id="line-2491"></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ @{ type family T a b c = (r :: *) | r -&gt; a b }@</span></span><span>
</span><span id="line-2492"></span><span>
</span><span id="line-2493"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ClosedTypeFamilyD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ClosedTypeFamilyD"><span class="hs-identifier hs-var">ClosedTypeFamilyD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeFamilyHead"><span class="hs-identifier hs-type">TypeFamilyHead</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TySynEqn"><span class="hs-identifier hs-type">TySynEqn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2494"></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @{ type family F a b = (r :: *) | r -&gt; a where ... }@</span></span><span>
</span><span id="line-2495"></span><span>
</span><span id="line-2496"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RoleAnnotD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RoleAnnotD"><span class="hs-identifier hs-var">RoleAnnotD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Role"><span class="hs-identifier hs-type">Role</span></a></span><span class="hs-special">]</span><span>     </span><span class="annot"><span class="hs-comment">-- ^ @{ type role T nominal representational }@</span></span><span>
</span><span id="line-2497"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="StandaloneDerivD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StandaloneDerivD"><span class="hs-identifier hs-var">StandaloneDerivD</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivStrategy"><span class="hs-identifier hs-type">DerivStrategy</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2498"></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @{ deriving stock instance Ord a =&gt; Ord (Foo a) }@</span></span><span>
</span><span id="line-2499"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DefaultSigD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DefaultSigD"><span class="hs-identifier hs-var">DefaultSigD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ @{ default size :: Data a =&gt; a -&gt; Int }@</span></span><span>
</span><span id="line-2500"></span><span>
</span><span id="line-2501"></span><span>  </span><span class="annot"><span class="hs-comment">-- | Pattern Synonyms</span></span><span>
</span><span id="line-2502"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSynD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynD"><span class="hs-identifier hs-var">PatSynD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynArgs"><span class="hs-identifier hs-type">PatSynArgs</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynDir"><span class="hs-identifier hs-type">PatSynDir</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span>
</span><span id="line-2503"></span><span>      </span><span class="hs-comment">-- ^ @{ pattern P v1 v2 .. vn &lt;- p }@  unidirectional           or</span><span>
</span><span id="line-2504"></span><span>      </span><span class="hs-comment">--   @{ pattern P v1 v2 .. vn = p  }@  implicit bidirectional   or</span><span>
</span><span id="line-2505"></span><span>      </span><span class="hs-comment">--   @{ pattern P v1 v2 .. vn &lt;- p</span><span>
</span><span id="line-2506"></span><span>      </span><span class="hs-comment">--        where P v1 v2 .. vn = e  }@  explicit bidirectional</span><span>
</span><span id="line-2507"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-2508"></span><span>      </span><span class="hs-comment">-- also, besides prefix pattern synonyms, both infix and record</span><span>
</span><span id="line-2509"></span><span>      </span><span class="hs-comment">-- pattern synonyms are supported. See 'PatSynArgs' for details</span><span>
</span><span id="line-2510"></span><span>
</span><span id="line-2511"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSynSigD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynSigD"><span class="hs-identifier hs-var">PatSynSigD</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynType"><span class="hs-identifier hs-type">PatSynType</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ A pattern synonym's type signature.</span></span><span>
</span><span id="line-2512"></span><span>
</span><span id="line-2513"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ImplicitParamBindD"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ImplicitParamBindD"><span class="hs-identifier hs-var">ImplicitParamBindD</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>
</span><span id="line-2514"></span><span>      </span><span class="hs-comment">-- ^ @{ ?x = expr }@</span><span>
</span><span id="line-2515"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-2516"></span><span>      </span><span class="hs-comment">-- Implicit parameter binding declaration. Can only be used in let</span><span>
</span><span id="line-2517"></span><span>      </span><span class="hs-comment">-- and where clauses which consist entirely of implicit bindings.</span><span>
</span><span id="line-2518"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679201814"><span id="local-6989586621679201938"><span id="local-6989586621679201941"><span class="annot"><span class="annottext">Int -&gt; Dec -&gt; FilePath -&gt; FilePath
[Dec] -&gt; FilePath -&gt; FilePath
Dec -&gt; FilePath
(Int -&gt; Dec -&gt; FilePath -&gt; FilePath)
-&gt; (Dec -&gt; FilePath) -&gt; ([Dec] -&gt; FilePath -&gt; FilePath) -&gt; Show Dec
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Dec -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Dec -&gt; FilePath -&gt; FilePath
$cshow :: Dec -&gt; FilePath
show :: Dec -&gt; FilePath
$cshowList :: [Dec] -&gt; FilePath -&gt; FilePath
showList :: [Dec] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679201956"><span id="local-6989586621679202056"><span class="annot"><span class="annottext">Dec -&gt; Dec -&gt; Bool
(Dec -&gt; Dec -&gt; Bool) -&gt; (Dec -&gt; Dec -&gt; Bool) -&gt; Eq Dec
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Dec -&gt; Dec -&gt; Bool
== :: Dec -&gt; Dec -&gt; Bool
$c/= :: Dec -&gt; Dec -&gt; Bool
/= :: Dec -&gt; Dec -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202073"><span id="local-6989586621679202193"><span id="local-6989586621679202196"><span id="local-6989586621679202199"><span id="local-6989586621679202202"><span id="local-6989586621679202205"><span id="local-6989586621679202208"><span class="annot"><span class="annottext">Eq Dec
Eq Dec =&gt;
(Dec -&gt; Dec -&gt; Ordering)
-&gt; (Dec -&gt; Dec -&gt; Bool)
-&gt; (Dec -&gt; Dec -&gt; Bool)
-&gt; (Dec -&gt; Dec -&gt; Bool)
-&gt; (Dec -&gt; Dec -&gt; Bool)
-&gt; (Dec -&gt; Dec -&gt; Dec)
-&gt; (Dec -&gt; Dec -&gt; Dec)
-&gt; Ord Dec
Dec -&gt; Dec -&gt; Bool
Dec -&gt; Dec -&gt; Ordering
Dec -&gt; Dec -&gt; Dec
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Dec -&gt; Dec -&gt; Ordering
compare :: Dec -&gt; Dec -&gt; Ordering
$c&lt; :: Dec -&gt; Dec -&gt; Bool
&lt; :: Dec -&gt; Dec -&gt; Bool
$c&lt;= :: Dec -&gt; Dec -&gt; Bool
&lt;= :: Dec -&gt; Dec -&gt; Bool
$c&gt; :: Dec -&gt; Dec -&gt; Bool
&gt; :: Dec -&gt; Dec -&gt; Bool
$c&gt;= :: Dec -&gt; Dec -&gt; Bool
&gt;= :: Dec -&gt; Dec -&gt; Bool
$cmax :: Dec -&gt; Dec -&gt; Dec
max :: Dec -&gt; Dec -&gt; Dec
$cmin :: Dec -&gt; Dec -&gt; Dec
min :: Dec -&gt; Dec -&gt; Dec
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202225"><span id="local-6989586621679202323"><span id="local-6989586621679202414"><span id="local-6989586621679202416"><span id="local-6989586621679202418"><span id="local-6989586621679202423"><span id="local-6989586621679202428"><span id="local-6989586621679202431"><span id="local-6989586621679202434"><span id="local-6989586621679202437"><span id="local-6989586621679202440"><span id="local-6989586621679202443"><span id="local-6989586621679202448"><span id="local-6989586621679202453"><span class="annot"><span class="annottext">Typeable Dec
Typeable Dec =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Dec -&gt; c Dec)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Dec)
-&gt; (Dec -&gt; Constr)
-&gt; (Dec -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Dec))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Dec))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Dec -&gt; Dec)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Dec -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Dec -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Dec -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Dec -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec)
-&gt; Data Dec
Dec -&gt; Constr
Dec -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Dec -&gt; Dec
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Dec -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Dec -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Dec -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Dec -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Dec
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Dec -&gt; c Dec
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Dec)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Dec)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Dec -&gt; c Dec
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Dec -&gt; c Dec
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Dec
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Dec
$ctoConstr :: Dec -&gt; Constr
toConstr :: Dec -&gt; Constr
$cdataTypeOf :: Dec -&gt; DataType
dataTypeOf :: Dec -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Dec)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Dec)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Dec)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Dec)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Dec -&gt; Dec
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Dec -&gt; Dec
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Dec -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Dec -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Dec -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Dec -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Dec -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Dec -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Dec -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Dec -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Dec -&gt; m Dec
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202473"><span id="local-6989586621679202475"><span class="annot"><span class="annottext">(forall x. Dec -&gt; Rep Dec x)
-&gt; (forall x. Rep Dec x -&gt; Dec) -&gt; Generic Dec
forall x. Rep Dec x -&gt; Dec
forall x. Dec -&gt; Rep Dec x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Dec -&gt; Rep Dec x
from :: forall x. Dec -&gt; Rep Dec x
$cto :: forall x. Rep Dec x -&gt; Dec
to :: forall x. Rep Dec x -&gt; Dec
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2519"></span><span>
</span><span id="line-2520"></span><span class="hs-comment">-- | A way to specify a namespace to look in when GHC needs to find</span><span>
</span><span id="line-2521"></span><span class="hs-comment">--   a name's source</span><span>
</span><span id="line-2522"></span><span class="hs-keyword">data</span><span> </span><span id="NamespaceSpecifier"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NamespaceSpecifier"><span class="hs-identifier hs-var">NamespaceSpecifier</span></a></span></span><span>
</span><span id="line-2523"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NoNamespaceSpecifier"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NoNamespaceSpecifier"><span class="hs-identifier hs-var">NoNamespaceSpecifier</span></a></span></span><span>   </span><span class="hs-comment">-- ^ Name may be everything; If there are two</span><span>
</span><span id="line-2524"></span><span>                           </span><span class="hs-comment">--   names in different namespaces, then consider both</span><span>
</span><span id="line-2525"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeNamespaceSpecifier"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeNamespaceSpecifier"><span class="hs-identifier hs-var">TypeNamespaceSpecifier</span></a></span></span><span> </span><span class="hs-comment">-- ^ Name should be a type-level entity, such as a</span><span>
</span><span id="line-2526"></span><span>                           </span><span class="hs-comment">--   data type, type alias, type family, type class,</span><span>
</span><span id="line-2527"></span><span>                           </span><span class="hs-comment">--   or type variable</span><span>
</span><span id="line-2528"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataNamespaceSpecifier"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DataNamespaceSpecifier"><span class="hs-identifier hs-var">DataNamespaceSpecifier</span></a></span></span><span> </span><span class="hs-comment">-- ^ Name should be a term-level entity, such as a</span><span>
</span><span id="line-2529"></span><span>                           </span><span class="hs-comment">--   function, data constructor, or pattern synonym</span><span>
</span><span id="line-2530"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679202478"><span id="local-6989586621679202480"><span id="local-6989586621679202483"><span class="annot"><span class="annottext">Int -&gt; NamespaceSpecifier -&gt; FilePath -&gt; FilePath
[NamespaceSpecifier] -&gt; FilePath -&gt; FilePath
NamespaceSpecifier -&gt; FilePath
(Int -&gt; NamespaceSpecifier -&gt; FilePath -&gt; FilePath)
-&gt; (NamespaceSpecifier -&gt; FilePath)
-&gt; ([NamespaceSpecifier] -&gt; FilePath -&gt; FilePath)
-&gt; Show NamespaceSpecifier
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; NamespaceSpecifier -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; NamespaceSpecifier -&gt; FilePath -&gt; FilePath
$cshow :: NamespaceSpecifier -&gt; FilePath
show :: NamespaceSpecifier -&gt; FilePath
$cshowList :: [NamespaceSpecifier] -&gt; FilePath -&gt; FilePath
showList :: [NamespaceSpecifier] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202486"><span id="local-6989586621679202490"><span class="annot"><span class="annottext">NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
(NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool)
-&gt; (NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool)
-&gt; Eq NamespaceSpecifier
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
== :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
$c/= :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
/= :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202495"><span id="local-6989586621679202499"><span id="local-6989586621679202503"><span id="local-6989586621679202506"><span id="local-6989586621679202509"><span id="local-6989586621679202512"><span id="local-6989586621679202515"><span class="annot"><span class="annottext">Eq NamespaceSpecifier
Eq NamespaceSpecifier =&gt;
(NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Ordering)
-&gt; (NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool)
-&gt; (NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool)
-&gt; (NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool)
-&gt; (NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool)
-&gt; (NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; NamespaceSpecifier)
-&gt; (NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; NamespaceSpecifier)
-&gt; Ord NamespaceSpecifier
NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Ordering
NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; NamespaceSpecifier
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Ordering
compare :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Ordering
$c&lt; :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
&lt; :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
$c&lt;= :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
&lt;= :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
$c&gt; :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
&gt; :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
$c&gt;= :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
&gt;= :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; Bool
$cmax :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; NamespaceSpecifier
max :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; NamespaceSpecifier
$cmin :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; NamespaceSpecifier
min :: NamespaceSpecifier -&gt; NamespaceSpecifier -&gt; NamespaceSpecifier
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202520"><span id="local-6989586621679202522"><span id="local-6989586621679202524"><span id="local-6989586621679202526"><span id="local-6989586621679202528"><span id="local-6989586621679202533"><span id="local-6989586621679202538"><span id="local-6989586621679202541"><span id="local-6989586621679202544"><span id="local-6989586621679202547"><span id="local-6989586621679202550"><span id="local-6989586621679202553"><span id="local-6989586621679202558"><span id="local-6989586621679202563"><span class="annot"><span class="annottext">Typeable NamespaceSpecifier
Typeable NamespaceSpecifier =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; NamespaceSpecifier
 -&gt; c NamespaceSpecifier)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NamespaceSpecifier)
-&gt; (NamespaceSpecifier -&gt; Constr)
-&gt; (NamespaceSpecifier -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NamespaceSpecifier))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c NamespaceSpecifier))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; NamespaceSpecifier -&gt; NamespaceSpecifier)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NamespaceSpecifier -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NamespaceSpecifier -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; NamespaceSpecifier -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NamespaceSpecifier -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier)
-&gt; Data NamespaceSpecifier
NamespaceSpecifier -&gt; Constr
NamespaceSpecifier -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; NamespaceSpecifier -&gt; NamespaceSpecifier
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NamespaceSpecifier -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NamespaceSpecifier -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NamespaceSpecifier -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NamespaceSpecifier -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NamespaceSpecifier
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; NamespaceSpecifier
-&gt; c NamespaceSpecifier
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NamespaceSpecifier)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NamespaceSpecifier)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; NamespaceSpecifier
-&gt; c NamespaceSpecifier
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; NamespaceSpecifier
-&gt; c NamespaceSpecifier
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NamespaceSpecifier
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c NamespaceSpecifier
$ctoConstr :: NamespaceSpecifier -&gt; Constr
toConstr :: NamespaceSpecifier -&gt; Constr
$cdataTypeOf :: NamespaceSpecifier -&gt; DataType
dataTypeOf :: NamespaceSpecifier -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NamespaceSpecifier)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c NamespaceSpecifier)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NamespaceSpecifier)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c NamespaceSpecifier)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; NamespaceSpecifier -&gt; NamespaceSpecifier
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; NamespaceSpecifier -&gt; NamespaceSpecifier
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NamespaceSpecifier -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NamespaceSpecifier -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NamespaceSpecifier -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; NamespaceSpecifier -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NamespaceSpecifier -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; NamespaceSpecifier -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NamespaceSpecifier -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; NamespaceSpecifier -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; NamespaceSpecifier -&gt; m NamespaceSpecifier
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202568"><span id="local-6989586621679202570"><span class="annot"><span class="annottext">(forall x. NamespaceSpecifier -&gt; Rep NamespaceSpecifier x)
-&gt; (forall x. Rep NamespaceSpecifier x -&gt; NamespaceSpecifier)
-&gt; Generic NamespaceSpecifier
forall x. Rep NamespaceSpecifier x -&gt; NamespaceSpecifier
forall x. NamespaceSpecifier -&gt; Rep NamespaceSpecifier x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. NamespaceSpecifier -&gt; Rep NamespaceSpecifier x
from :: forall x. NamespaceSpecifier -&gt; Rep NamespaceSpecifier x
$cto :: forall x. Rep NamespaceSpecifier x -&gt; NamespaceSpecifier
to :: forall x. Rep NamespaceSpecifier x -&gt; NamespaceSpecifier
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2531"></span><span>
</span><span id="line-2532"></span><span class="annot"><span class="hs-comment">-- | Varieties of allowed instance overlap.</span></span><span>
</span><span id="line-2533"></span><span class="hs-keyword">data</span><span> </span><span id="Overlap"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Overlap"><span class="hs-identifier hs-var">Overlap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Overlappable"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Overlappable"><span class="hs-identifier hs-var">Overlappable</span></a></span></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ May be overlapped by more specific instances</span></span><span>
</span><span id="line-2534"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="Overlapping"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Overlapping"><span class="hs-identifier hs-var">Overlapping</span></a></span></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ May overlap a more general instance</span></span><span>
</span><span id="line-2535"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="Overlaps"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Overlaps"><span class="hs-identifier hs-var">Overlaps</span></a></span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Both 'Overlapping' and 'Overlappable'</span></span><span>
</span><span id="line-2536"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="Incoherent"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Incoherent"><span class="hs-identifier hs-var">Incoherent</span></a></span></span><span>     </span><span class="hs-comment">-- ^ Both 'Overlapping' and 'Overlappable', and</span><span>
</span><span id="line-2537"></span><span>                              </span><span class="hs-comment">-- pick an arbitrary one if multiple choices are</span><span>
</span><span id="line-2538"></span><span>                              </span><span class="hs-comment">-- available.</span><span>
</span><span id="line-2539"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679202573"><span id="local-6989586621679202575"><span id="local-6989586621679202578"><span class="annot"><span class="annottext">Int -&gt; Overlap -&gt; FilePath -&gt; FilePath
[Overlap] -&gt; FilePath -&gt; FilePath
Overlap -&gt; FilePath
(Int -&gt; Overlap -&gt; FilePath -&gt; FilePath)
-&gt; (Overlap -&gt; FilePath)
-&gt; ([Overlap] -&gt; FilePath -&gt; FilePath)
-&gt; Show Overlap
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Overlap -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Overlap -&gt; FilePath -&gt; FilePath
$cshow :: Overlap -&gt; FilePath
show :: Overlap -&gt; FilePath
$cshowList :: [Overlap] -&gt; FilePath -&gt; FilePath
showList :: [Overlap] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202581"><span id="local-6989586621679202585"><span class="annot"><span class="annottext">Overlap -&gt; Overlap -&gt; Bool
(Overlap -&gt; Overlap -&gt; Bool)
-&gt; (Overlap -&gt; Overlap -&gt; Bool) -&gt; Eq Overlap
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Overlap -&gt; Overlap -&gt; Bool
== :: Overlap -&gt; Overlap -&gt; Bool
$c/= :: Overlap -&gt; Overlap -&gt; Bool
/= :: Overlap -&gt; Overlap -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202590"><span id="local-6989586621679202594"><span id="local-6989586621679202598"><span id="local-6989586621679202601"><span id="local-6989586621679202604"><span id="local-6989586621679202607"><span id="local-6989586621679202610"><span class="annot"><span class="annottext">Eq Overlap
Eq Overlap =&gt;
(Overlap -&gt; Overlap -&gt; Ordering)
-&gt; (Overlap -&gt; Overlap -&gt; Bool)
-&gt; (Overlap -&gt; Overlap -&gt; Bool)
-&gt; (Overlap -&gt; Overlap -&gt; Bool)
-&gt; (Overlap -&gt; Overlap -&gt; Bool)
-&gt; (Overlap -&gt; Overlap -&gt; Overlap)
-&gt; (Overlap -&gt; Overlap -&gt; Overlap)
-&gt; Ord Overlap
Overlap -&gt; Overlap -&gt; Bool
Overlap -&gt; Overlap -&gt; Ordering
Overlap -&gt; Overlap -&gt; Overlap
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Overlap -&gt; Overlap -&gt; Ordering
compare :: Overlap -&gt; Overlap -&gt; Ordering
$c&lt; :: Overlap -&gt; Overlap -&gt; Bool
&lt; :: Overlap -&gt; Overlap -&gt; Bool
$c&lt;= :: Overlap -&gt; Overlap -&gt; Bool
&lt;= :: Overlap -&gt; Overlap -&gt; Bool
$c&gt; :: Overlap -&gt; Overlap -&gt; Bool
&gt; :: Overlap -&gt; Overlap -&gt; Bool
$c&gt;= :: Overlap -&gt; Overlap -&gt; Bool
&gt;= :: Overlap -&gt; Overlap -&gt; Bool
$cmax :: Overlap -&gt; Overlap -&gt; Overlap
max :: Overlap -&gt; Overlap -&gt; Overlap
$cmin :: Overlap -&gt; Overlap -&gt; Overlap
min :: Overlap -&gt; Overlap -&gt; Overlap
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202615"><span id="local-6989586621679202617"><span id="local-6989586621679202619"><span id="local-6989586621679202621"><span id="local-6989586621679202623"><span id="local-6989586621679202628"><span id="local-6989586621679202633"><span id="local-6989586621679202636"><span id="local-6989586621679202639"><span id="local-6989586621679202642"><span id="local-6989586621679202645"><span id="local-6989586621679202648"><span id="local-6989586621679202653"><span id="local-6989586621679202658"><span class="annot"><span class="annottext">Typeable Overlap
Typeable Overlap =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Overlap -&gt; c Overlap)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Overlap)
-&gt; (Overlap -&gt; Constr)
-&gt; (Overlap -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Overlap))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Overlap))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Overlap -&gt; Overlap)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap)
-&gt; Data Overlap
Overlap -&gt; Constr
Overlap -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Overlap -&gt; Overlap
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Overlap
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Overlap -&gt; c Overlap
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Overlap)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Overlap)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Overlap -&gt; c Overlap
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Overlap -&gt; c Overlap
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Overlap
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Overlap
$ctoConstr :: Overlap -&gt; Constr
toConstr :: Overlap -&gt; Constr
$cdataTypeOf :: Overlap -&gt; DataType
dataTypeOf :: Overlap -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Overlap)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Overlap)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Overlap)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Overlap)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Overlap -&gt; Overlap
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Overlap -&gt; Overlap
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap -&gt; m Overlap
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202663"><span id="local-6989586621679202665"><span class="annot"><span class="annottext">(forall x. Overlap -&gt; Rep Overlap x)
-&gt; (forall x. Rep Overlap x -&gt; Overlap) -&gt; Generic Overlap
forall x. Rep Overlap x -&gt; Overlap
forall x. Overlap -&gt; Rep Overlap x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Overlap -&gt; Rep Overlap x
from :: forall x. Overlap -&gt; Rep Overlap x
$cto :: forall x. Rep Overlap x -&gt; Overlap
to :: forall x. Rep Overlap x -&gt; Overlap
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2540"></span><span>
</span><span id="line-2541"></span><span class="annot"><span class="hs-comment">-- | A single @deriving@ clause at the end of a datatype.</span></span><span>
</span><span id="line-2542"></span><span class="hs-keyword">data</span><span> </span><span id="DerivClause"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivClause"><span class="hs-identifier hs-var">DerivClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DerivClause"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivClause"><span class="hs-identifier hs-var">DerivClause</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivStrategy"><span class="hs-identifier hs-type">DerivStrategy</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span>
</span><span id="line-2543"></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @{ deriving stock (Eq, Ord) }@</span></span><span>
</span><span id="line-2544"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679202669"><span id="local-6989586621679202676"><span id="local-6989586621679202679"><span class="annot"><span class="annottext">Int -&gt; DerivClause -&gt; FilePath -&gt; FilePath
[DerivClause] -&gt; FilePath -&gt; FilePath
DerivClause -&gt; FilePath
(Int -&gt; DerivClause -&gt; FilePath -&gt; FilePath)
-&gt; (DerivClause -&gt; FilePath)
-&gt; ([DerivClause] -&gt; FilePath -&gt; FilePath)
-&gt; Show DerivClause
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; DerivClause -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; DerivClause -&gt; FilePath -&gt; FilePath
$cshow :: DerivClause -&gt; FilePath
show :: DerivClause -&gt; FilePath
$cshowList :: [DerivClause] -&gt; FilePath -&gt; FilePath
showList :: [DerivClause] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202682"><span id="local-6989586621679202688"><span class="annot"><span class="annottext">DerivClause -&gt; DerivClause -&gt; Bool
(DerivClause -&gt; DerivClause -&gt; Bool)
-&gt; (DerivClause -&gt; DerivClause -&gt; Bool) -&gt; Eq DerivClause
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: DerivClause -&gt; DerivClause -&gt; Bool
== :: DerivClause -&gt; DerivClause -&gt; Bool
$c/= :: DerivClause -&gt; DerivClause -&gt; Bool
/= :: DerivClause -&gt; DerivClause -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202693"><span id="local-6989586621679202699"><span id="local-6989586621679202705"><span id="local-6989586621679202708"><span id="local-6989586621679202711"><span id="local-6989586621679202714"><span id="local-6989586621679202717"><span class="annot"><span class="annottext">Eq DerivClause
Eq DerivClause =&gt;
(DerivClause -&gt; DerivClause -&gt; Ordering)
-&gt; (DerivClause -&gt; DerivClause -&gt; Bool)
-&gt; (DerivClause -&gt; DerivClause -&gt; Bool)
-&gt; (DerivClause -&gt; DerivClause -&gt; Bool)
-&gt; (DerivClause -&gt; DerivClause -&gt; Bool)
-&gt; (DerivClause -&gt; DerivClause -&gt; DerivClause)
-&gt; (DerivClause -&gt; DerivClause -&gt; DerivClause)
-&gt; Ord DerivClause
DerivClause -&gt; DerivClause -&gt; Bool
DerivClause -&gt; DerivClause -&gt; Ordering
DerivClause -&gt; DerivClause -&gt; DerivClause
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: DerivClause -&gt; DerivClause -&gt; Ordering
compare :: DerivClause -&gt; DerivClause -&gt; Ordering
$c&lt; :: DerivClause -&gt; DerivClause -&gt; Bool
&lt; :: DerivClause -&gt; DerivClause -&gt; Bool
$c&lt;= :: DerivClause -&gt; DerivClause -&gt; Bool
&lt;= :: DerivClause -&gt; DerivClause -&gt; Bool
$c&gt; :: DerivClause -&gt; DerivClause -&gt; Bool
&gt; :: DerivClause -&gt; DerivClause -&gt; Bool
$c&gt;= :: DerivClause -&gt; DerivClause -&gt; Bool
&gt;= :: DerivClause -&gt; DerivClause -&gt; Bool
$cmax :: DerivClause -&gt; DerivClause -&gt; DerivClause
max :: DerivClause -&gt; DerivClause -&gt; DerivClause
$cmin :: DerivClause -&gt; DerivClause -&gt; DerivClause
min :: DerivClause -&gt; DerivClause -&gt; DerivClause
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202722"><span id="local-6989586621679202728"><span id="local-6989586621679202734"><span id="local-6989586621679202736"><span id="local-6989586621679202738"><span id="local-6989586621679202743"><span id="local-6989586621679202748"><span id="local-6989586621679202751"><span id="local-6989586621679202754"><span id="local-6989586621679202757"><span id="local-6989586621679202760"><span id="local-6989586621679202763"><span id="local-6989586621679202768"><span id="local-6989586621679202773"><span class="annot"><span class="annottext">Typeable DerivClause
Typeable DerivClause =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; DerivClause -&gt; c DerivClause)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DerivClause)
-&gt; (DerivClause -&gt; Constr)
-&gt; (DerivClause -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DerivClause))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DerivClause))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DerivClause -&gt; DerivClause)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivClause -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivClause -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivClause -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivClause -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause)
-&gt; Data DerivClause
DerivClause -&gt; Constr
DerivClause -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; DerivClause -&gt; DerivClause
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivClause -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivClause -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivClause -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivClause -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DerivClause
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivClause -&gt; c DerivClause
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DerivClause)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DerivClause)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivClause -&gt; c DerivClause
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivClause -&gt; c DerivClause
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DerivClause
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DerivClause
$ctoConstr :: DerivClause -&gt; Constr
toConstr :: DerivClause -&gt; Constr
$cdataTypeOf :: DerivClause -&gt; DataType
dataTypeOf :: DerivClause -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DerivClause)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DerivClause)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DerivClause)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DerivClause)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DerivClause -&gt; DerivClause
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DerivClause -&gt; DerivClause
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivClause -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivClause -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivClause -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivClause -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivClause -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivClause -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivClause -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivClause -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivClause -&gt; m DerivClause
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202778"><span id="local-6989586621679202780"><span class="annot"><span class="annottext">(forall x. DerivClause -&gt; Rep DerivClause x)
-&gt; (forall x. Rep DerivClause x -&gt; DerivClause)
-&gt; Generic DerivClause
forall x. Rep DerivClause x -&gt; DerivClause
forall x. DerivClause -&gt; Rep DerivClause x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. DerivClause -&gt; Rep DerivClause x
from :: forall x. DerivClause -&gt; Rep DerivClause x
$cto :: forall x. Rep DerivClause x -&gt; DerivClause
to :: forall x. Rep DerivClause x -&gt; DerivClause
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2545"></span><span>
</span><span id="line-2546"></span><span class="annot"><span class="hs-comment">-- | What the user explicitly requests when deriving an instance.</span></span><span>
</span><span id="line-2547"></span><span class="hs-keyword">data</span><span> </span><span id="DerivStrategy"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DerivStrategy"><span class="hs-identifier hs-var">DerivStrategy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="StockStrategy"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StockStrategy"><span class="hs-identifier hs-var">StockStrategy</span></a></span></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ A \&quot;standard\&quot; derived instance</span></span><span>
</span><span id="line-2548"></span><span>                   </span><span class="hs-glyph">|</span><span> </span><span id="AnyclassStrategy"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnyclassStrategy"><span class="hs-identifier hs-var">AnyclassStrategy</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @-XDeriveAnyClass@</span></span><span>
</span><span id="line-2549"></span><span>                   </span><span class="hs-glyph">|</span><span> </span><span id="NewtypeStrategy"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NewtypeStrategy"><span class="hs-identifier hs-var">NewtypeStrategy</span></a></span></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @-XGeneralizedNewtypeDeriving@</span></span><span>
</span><span id="line-2550"></span><span>                   </span><span class="hs-glyph">|</span><span> </span><span id="ViaStrategy"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ViaStrategy"><span class="hs-identifier hs-var">ViaStrategy</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @-XDerivingVia@</span></span><span>
</span><span id="line-2551"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679202787"><span id="local-6989586621679202791"><span id="local-6989586621679202794"><span class="annot"><span class="annottext">Int -&gt; DerivStrategy -&gt; FilePath -&gt; FilePath
[DerivStrategy] -&gt; FilePath -&gt; FilePath
DerivStrategy -&gt; FilePath
(Int -&gt; DerivStrategy -&gt; FilePath -&gt; FilePath)
-&gt; (DerivStrategy -&gt; FilePath)
-&gt; ([DerivStrategy] -&gt; FilePath -&gt; FilePath)
-&gt; Show DerivStrategy
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; DerivStrategy -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; DerivStrategy -&gt; FilePath -&gt; FilePath
$cshow :: DerivStrategy -&gt; FilePath
show :: DerivStrategy -&gt; FilePath
$cshowList :: [DerivStrategy] -&gt; FilePath -&gt; FilePath
showList :: [DerivStrategy] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202797"><span id="local-6989586621679202802"><span class="annot"><span class="annottext">DerivStrategy -&gt; DerivStrategy -&gt; Bool
(DerivStrategy -&gt; DerivStrategy -&gt; Bool)
-&gt; (DerivStrategy -&gt; DerivStrategy -&gt; Bool) -&gt; Eq DerivStrategy
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
== :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
$c/= :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
/= :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202807"><span id="local-6989586621679202812"><span id="local-6989586621679202815"><span id="local-6989586621679202818"><span id="local-6989586621679202821"><span id="local-6989586621679202824"><span id="local-6989586621679202827"><span class="annot"><span class="annottext">Eq DerivStrategy
Eq DerivStrategy =&gt;
(DerivStrategy -&gt; DerivStrategy -&gt; Ordering)
-&gt; (DerivStrategy -&gt; DerivStrategy -&gt; Bool)
-&gt; (DerivStrategy -&gt; DerivStrategy -&gt; Bool)
-&gt; (DerivStrategy -&gt; DerivStrategy -&gt; Bool)
-&gt; (DerivStrategy -&gt; DerivStrategy -&gt; Bool)
-&gt; (DerivStrategy -&gt; DerivStrategy -&gt; DerivStrategy)
-&gt; (DerivStrategy -&gt; DerivStrategy -&gt; DerivStrategy)
-&gt; Ord DerivStrategy
DerivStrategy -&gt; DerivStrategy -&gt; Bool
DerivStrategy -&gt; DerivStrategy -&gt; Ordering
DerivStrategy -&gt; DerivStrategy -&gt; DerivStrategy
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: DerivStrategy -&gt; DerivStrategy -&gt; Ordering
compare :: DerivStrategy -&gt; DerivStrategy -&gt; Ordering
$c&lt; :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
&lt; :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
$c&lt;= :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
&lt;= :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
$c&gt; :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
&gt; :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
$c&gt;= :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
&gt;= :: DerivStrategy -&gt; DerivStrategy -&gt; Bool
$cmax :: DerivStrategy -&gt; DerivStrategy -&gt; DerivStrategy
max :: DerivStrategy -&gt; DerivStrategy -&gt; DerivStrategy
$cmin :: DerivStrategy -&gt; DerivStrategy -&gt; DerivStrategy
min :: DerivStrategy -&gt; DerivStrategy -&gt; DerivStrategy
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202832"><span id="local-6989586621679202835"><span id="local-6989586621679202838"><span id="local-6989586621679202840"><span id="local-6989586621679202842"><span id="local-6989586621679202847"><span id="local-6989586621679202852"><span id="local-6989586621679202855"><span id="local-6989586621679202858"><span id="local-6989586621679202861"><span id="local-6989586621679202864"><span id="local-6989586621679202867"><span id="local-6989586621679202872"><span id="local-6989586621679202877"><span class="annot"><span class="annottext">Typeable DerivStrategy
Typeable DerivStrategy =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; DerivStrategy -&gt; c DerivStrategy)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DerivStrategy)
-&gt; (DerivStrategy -&gt; Constr)
-&gt; (DerivStrategy -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DerivStrategy))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DerivStrategy))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DerivStrategy -&gt; DerivStrategy)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy)
-&gt; Data DerivStrategy
DerivStrategy -&gt; Constr
DerivStrategy -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; DerivStrategy -&gt; DerivStrategy
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DerivStrategy
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivStrategy -&gt; c DerivStrategy
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DerivStrategy)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DerivStrategy)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivStrategy -&gt; c DerivStrategy
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivStrategy -&gt; c DerivStrategy
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DerivStrategy
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DerivStrategy
$ctoConstr :: DerivStrategy -&gt; Constr
toConstr :: DerivStrategy -&gt; Constr
$cdataTypeOf :: DerivStrategy -&gt; DataType
dataTypeOf :: DerivStrategy -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DerivStrategy)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DerivStrategy)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DerivStrategy)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DerivStrategy)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DerivStrategy -&gt; DerivStrategy
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DerivStrategy -&gt; DerivStrategy
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DerivStrategy -&gt; m DerivStrategy
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202882"><span id="local-6989586621679202884"><span class="annot"><span class="annottext">(forall x. DerivStrategy -&gt; Rep DerivStrategy x)
-&gt; (forall x. Rep DerivStrategy x -&gt; DerivStrategy)
-&gt; Generic DerivStrategy
forall x. Rep DerivStrategy x -&gt; DerivStrategy
forall x. DerivStrategy -&gt; Rep DerivStrategy x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. DerivStrategy -&gt; Rep DerivStrategy x
from :: forall x. DerivStrategy -&gt; Rep DerivStrategy x
$cto :: forall x. Rep DerivStrategy x -&gt; DerivStrategy
to :: forall x. Rep DerivStrategy x -&gt; DerivStrategy
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2552"></span><span>
</span><span id="line-2553"></span><span class="hs-comment">-- | A pattern synonym's type. Note that a pattern synonym's /fully/</span><span>
</span><span id="line-2554"></span><span class="hs-comment">-- specified type has a peculiar shape coming with two forall</span><span>
</span><span id="line-2555"></span><span class="hs-comment">-- quantifiers and two constraint contexts. For example, consider the</span><span>
</span><span id="line-2556"></span><span class="hs-comment">-- pattern synonym</span><span>
</span><span id="line-2557"></span><span class="hs-comment">--</span><span>
</span><span id="line-2558"></span><span class="hs-comment">-- &gt; pattern P x1 x2 ... xn = &lt;some-pattern&gt;</span><span>
</span><span id="line-2559"></span><span class="hs-comment">--</span><span>
</span><span id="line-2560"></span><span class="hs-comment">-- P's complete type is of the following form</span><span>
</span><span id="line-2561"></span><span class="hs-comment">--</span><span>
</span><span id="line-2562"></span><span class="hs-comment">-- &gt; pattern P :: forall universals.   required constraints</span><span>
</span><span id="line-2563"></span><span class="hs-comment">-- &gt;           =&gt; forall existentials. provided constraints</span><span>
</span><span id="line-2564"></span><span class="hs-comment">-- &gt;           =&gt; t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; t</span><span>
</span><span id="line-2565"></span><span class="hs-comment">--</span><span>
</span><span id="line-2566"></span><span class="hs-comment">-- consisting of four parts:</span><span>
</span><span id="line-2567"></span><span class="hs-comment">--</span><span>
</span><span id="line-2568"></span><span class="hs-comment">--   1. the (possibly empty lists of) universally quantified type</span><span>
</span><span id="line-2569"></span><span class="hs-comment">--      variables and required constraints on them.</span><span>
</span><span id="line-2570"></span><span class="hs-comment">--   2. the (possibly empty lists of) existentially quantified</span><span>
</span><span id="line-2571"></span><span class="hs-comment">--      type variables and the provided constraints on them.</span><span>
</span><span id="line-2572"></span><span class="hs-comment">--   3. the types @t1@, @t2@, .., @tn@ of @x1@, @x2@, .., @xn@, respectively</span><span>
</span><span id="line-2573"></span><span class="hs-comment">--   4. the type @t@ of @\&lt;some-pattern\&gt;@, mentioning only universals.</span><span>
</span><span id="line-2574"></span><span class="hs-comment">--</span><span>
</span><span id="line-2575"></span><span class="hs-comment">-- Pattern synonym types interact with TH when (a) reifying a pattern</span><span>
</span><span id="line-2576"></span><span class="hs-comment">-- synonym, (b) pretty printing, or (c) specifying a pattern synonym's</span><span>
</span><span id="line-2577"></span><span class="hs-comment">-- type signature explicitly:</span><span>
</span><span id="line-2578"></span><span class="hs-comment">--</span><span>
</span><span id="line-2579"></span><span class="hs-comment">--   * Reification always returns a pattern synonym's /fully/ specified</span><span>
</span><span id="line-2580"></span><span class="hs-comment">--     type in abstract syntax.</span><span>
</span><span id="line-2581"></span><span class="hs-comment">--</span><span>
</span><span id="line-2582"></span><span class="hs-comment">--   * Pretty printing via 'Language.Haskell.TH.Ppr.pprPatSynType' abbreviates</span><span>
</span><span id="line-2583"></span><span class="hs-comment">--     a pattern synonym's type unambiguously in concrete syntax: The rule of</span><span>
</span><span id="line-2584"></span><span class="hs-comment">--     thumb is to print initial empty universals and the required</span><span>
</span><span id="line-2585"></span><span class="hs-comment">--     context as @() =&gt;@, if existentials and a provided context</span><span>
</span><span id="line-2586"></span><span class="hs-comment">--     follow. If only universals and their required context, but no</span><span>
</span><span id="line-2587"></span><span class="hs-comment">--     existentials are specified, only the universals and their</span><span>
</span><span id="line-2588"></span><span class="hs-comment">--     required context are printed. If both or none are specified, so</span><span>
</span><span id="line-2589"></span><span class="hs-comment">--     both (or none) are printed.</span><span>
</span><span id="line-2590"></span><span class="hs-comment">--</span><span>
</span><span id="line-2591"></span><span class="hs-comment">--   * When specifying a pattern synonym's type explicitly with</span><span>
</span><span id="line-2592"></span><span class="hs-comment">--     'PatSynSigD' either one of the universals, the existentials, or</span><span>
</span><span id="line-2593"></span><span class="hs-comment">--     their contexts may be left empty.</span><span>
</span><span id="line-2594"></span><span class="hs-comment">--</span><span>
</span><span id="line-2595"></span><span class="hs-comment">-- See the GHC user's guide for more information on pattern synonyms</span><span>
</span><span id="line-2596"></span><span class="hs-comment">-- and their types:</span><span>
</span><span id="line-2597"></span><span class="hs-comment">-- &lt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms&gt;.</span><span>
</span><span id="line-2598"></span><span class="hs-keyword">type</span><span> </span><span id="PatSynType"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynType"><span class="hs-identifier hs-var">PatSynType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2599"></span><span>
</span><span id="line-2600"></span><span class="hs-comment">-- | Common elements of 'OpenTypeFamilyD' and 'ClosedTypeFamilyD'. By</span><span>
</span><span id="line-2601"></span><span class="hs-comment">-- analogy with &quot;head&quot; for type classes and type class instances as</span><span>
</span><span id="line-2602"></span><span class="hs-comment">-- defined in /Type classes: an exploration of the design space/, the</span><span>
</span><span id="line-2603"></span><span class="hs-comment">-- @TypeFamilyHead@ is defined to be the elements of the declaration</span><span>
</span><span id="line-2604"></span><span class="hs-comment">-- between @type family@ and @where@.</span><span>
</span><span id="line-2605"></span><span class="hs-keyword">data</span><span> </span><span id="TypeFamilyHead"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeFamilyHead"><span class="hs-identifier hs-var">TypeFamilyHead</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2606"></span><span>  </span><span id="TypeFamilyHead"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeFamilyHead"><span class="hs-identifier hs-var">TypeFamilyHead</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrVis"><span class="hs-identifier hs-type">BndrVis</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FamilyResultSig"><span class="hs-identifier hs-type">FamilyResultSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InjectivityAnn"><span class="hs-identifier hs-type">InjectivityAnn</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2607"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679202888"><span id="local-6989586621679202898"><span id="local-6989586621679202901"><span class="annot"><span class="annottext">Int -&gt; TypeFamilyHead -&gt; FilePath -&gt; FilePath
[TypeFamilyHead] -&gt; FilePath -&gt; FilePath
TypeFamilyHead -&gt; FilePath
(Int -&gt; TypeFamilyHead -&gt; FilePath -&gt; FilePath)
-&gt; (TypeFamilyHead -&gt; FilePath)
-&gt; ([TypeFamilyHead] -&gt; FilePath -&gt; FilePath)
-&gt; Show TypeFamilyHead
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; TypeFamilyHead -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; TypeFamilyHead -&gt; FilePath -&gt; FilePath
$cshow :: TypeFamilyHead -&gt; FilePath
show :: TypeFamilyHead -&gt; FilePath
$cshowList :: [TypeFamilyHead] -&gt; FilePath -&gt; FilePath
showList :: [TypeFamilyHead] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202906"><span id="local-6989586621679202915"><span class="annot"><span class="annottext">TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
(TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool)
-&gt; (TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool) -&gt; Eq TypeFamilyHead
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
== :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
$c/= :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
/= :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202922"><span id="local-6989586621679202931"><span id="local-6989586621679202939"><span id="local-6989586621679202942"><span id="local-6989586621679202945"><span id="local-6989586621679202948"><span id="local-6989586621679202951"><span class="annot"><span class="annottext">Eq TypeFamilyHead
Eq TypeFamilyHead =&gt;
(TypeFamilyHead -&gt; TypeFamilyHead -&gt; Ordering)
-&gt; (TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool)
-&gt; (TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool)
-&gt; (TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool)
-&gt; (TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool)
-&gt; (TypeFamilyHead -&gt; TypeFamilyHead -&gt; TypeFamilyHead)
-&gt; (TypeFamilyHead -&gt; TypeFamilyHead -&gt; TypeFamilyHead)
-&gt; Ord TypeFamilyHead
TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
TypeFamilyHead -&gt; TypeFamilyHead -&gt; Ordering
TypeFamilyHead -&gt; TypeFamilyHead -&gt; TypeFamilyHead
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Ordering
compare :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Ordering
$c&lt; :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
&lt; :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
$c&lt;= :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
&lt;= :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
$c&gt; :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
&gt; :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
$c&gt;= :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
&gt;= :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; Bool
$cmax :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; TypeFamilyHead
max :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; TypeFamilyHead
$cmin :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; TypeFamilyHead
min :: TypeFamilyHead -&gt; TypeFamilyHead -&gt; TypeFamilyHead
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679202959"><span id="local-6989586621679202968"><span id="local-6989586621679202976"><span id="local-6989586621679202978"><span id="local-6989586621679202980"><span id="local-6989586621679202985"><span id="local-6989586621679202990"><span id="local-6989586621679202993"><span id="local-6989586621679202996"><span id="local-6989586621679202999"><span id="local-6989586621679203002"><span id="local-6989586621679203005"><span id="local-6989586621679203010"><span id="local-6989586621679203015"><span class="annot"><span class="annottext">Typeable TypeFamilyHead
Typeable TypeFamilyHead =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; TypeFamilyHead -&gt; c TypeFamilyHead)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeFamilyHead)
-&gt; (TypeFamilyHead -&gt; Constr)
-&gt; (TypeFamilyHead -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TypeFamilyHead))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c TypeFamilyHead))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; TypeFamilyHead -&gt; TypeFamilyHead)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeFamilyHead -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeFamilyHead -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; TypeFamilyHead -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeFamilyHead -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; TypeFamilyHead -&gt; m TypeFamilyHead)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; TypeFamilyHead -&gt; m TypeFamilyHead)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; TypeFamilyHead -&gt; m TypeFamilyHead)
-&gt; Data TypeFamilyHead
TypeFamilyHead -&gt; Constr
TypeFamilyHead -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; TypeFamilyHead -&gt; TypeFamilyHead
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeFamilyHead -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TypeFamilyHead -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeFamilyHead -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeFamilyHead -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TypeFamilyHead -&gt; m TypeFamilyHead
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TypeFamilyHead -&gt; m TypeFamilyHead
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeFamilyHead
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeFamilyHead -&gt; c TypeFamilyHead
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TypeFamilyHead)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c TypeFamilyHead)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeFamilyHead -&gt; c TypeFamilyHead
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeFamilyHead -&gt; c TypeFamilyHead
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeFamilyHead
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeFamilyHead
$ctoConstr :: TypeFamilyHead -&gt; Constr
toConstr :: TypeFamilyHead -&gt; Constr
$cdataTypeOf :: TypeFamilyHead -&gt; DataType
dataTypeOf :: TypeFamilyHead -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TypeFamilyHead)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TypeFamilyHead)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c TypeFamilyHead)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c TypeFamilyHead)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TypeFamilyHead -&gt; TypeFamilyHead
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TypeFamilyHead -&gt; TypeFamilyHead
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeFamilyHead -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeFamilyHead -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeFamilyHead -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeFamilyHead -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TypeFamilyHead -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TypeFamilyHead -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeFamilyHead -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeFamilyHead -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TypeFamilyHead -&gt; m TypeFamilyHead
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TypeFamilyHead -&gt; m TypeFamilyHead
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TypeFamilyHead -&gt; m TypeFamilyHead
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TypeFamilyHead -&gt; m TypeFamilyHead
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TypeFamilyHead -&gt; m TypeFamilyHead
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TypeFamilyHead -&gt; m TypeFamilyHead
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203023"><span id="local-6989586621679203025"><span class="annot"><span class="annottext">(forall x. TypeFamilyHead -&gt; Rep TypeFamilyHead x)
-&gt; (forall x. Rep TypeFamilyHead x -&gt; TypeFamilyHead)
-&gt; Generic TypeFamilyHead
forall x. Rep TypeFamilyHead x -&gt; TypeFamilyHead
forall x. TypeFamilyHead -&gt; Rep TypeFamilyHead x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. TypeFamilyHead -&gt; Rep TypeFamilyHead x
from :: forall x. TypeFamilyHead -&gt; Rep TypeFamilyHead x
$cto :: forall x. Rep TypeFamilyHead x -&gt; TypeFamilyHead
to :: forall x. Rep TypeFamilyHead x -&gt; TypeFamilyHead
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2608"></span><span>
</span><span id="line-2609"></span><span class="hs-comment">-- | One equation of a type family instance or closed type family. The</span><span>
</span><span id="line-2610"></span><span class="hs-comment">-- arguments are the left-hand-side type and the right-hand-side result.</span><span>
</span><span id="line-2611"></span><span class="hs-comment">--</span><span>
</span><span id="line-2612"></span><span class="hs-comment">-- For instance, if you had the following type family:</span><span>
</span><span id="line-2613"></span><span class="hs-comment">--</span><span>
</span><span id="line-2614"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-2615"></span><span class="hs-comment">-- type family Foo (a :: k) :: k where</span><span>
</span><span id="line-2616"></span><span class="hs-comment">--   forall k (a :: k). Foo \@k a = a</span><span>
</span><span id="line-2617"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-2618"></span><span class="hs-comment">--</span><span>
</span><span id="line-2619"></span><span class="hs-comment">-- The @Foo \@k a = a@ equation would be represented as follows:</span><span>
</span><span id="line-2620"></span><span class="hs-comment">--</span><span>
</span><span id="line-2621"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-2622"></span><span class="hs-comment">-- 'TySynEqn' ('Just' ['PlainTV' k, 'KindedTV' a ('VarT' k)])</span><span>
</span><span id="line-2623"></span><span class="hs-comment">--            ('AppT' ('AppKindT' ('ConT' ''Foo) ('VarT' k)) ('VarT' a))</span><span>
</span><span id="line-2624"></span><span class="hs-comment">--            ('VarT' a)</span><span>
</span><span id="line-2625"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-2626"></span><span class="hs-keyword">data</span><span> </span><span id="TySynEqn"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TySynEqn"><span class="hs-identifier hs-var">TySynEqn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="TySynEqn"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TySynEqn"><span class="hs-identifier hs-var">TySynEqn</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2627"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679203032"><span id="local-6989586621679203039"><span id="local-6989586621679203042"><span class="annot"><span class="annottext">Int -&gt; TySynEqn -&gt; FilePath -&gt; FilePath
[TySynEqn] -&gt; FilePath -&gt; FilePath
TySynEqn -&gt; FilePath
(Int -&gt; TySynEqn -&gt; FilePath -&gt; FilePath)
-&gt; (TySynEqn -&gt; FilePath)
-&gt; ([TySynEqn] -&gt; FilePath -&gt; FilePath)
-&gt; Show TySynEqn
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; TySynEqn -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; TySynEqn -&gt; FilePath -&gt; FilePath
$cshow :: TySynEqn -&gt; FilePath
show :: TySynEqn -&gt; FilePath
$cshowList :: [TySynEqn] -&gt; FilePath -&gt; FilePath
showList :: [TySynEqn] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203047"><span id="local-6989586621679203053"><span class="annot"><span class="annottext">TySynEqn -&gt; TySynEqn -&gt; Bool
(TySynEqn -&gt; TySynEqn -&gt; Bool)
-&gt; (TySynEqn -&gt; TySynEqn -&gt; Bool) -&gt; Eq TySynEqn
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: TySynEqn -&gt; TySynEqn -&gt; Bool
== :: TySynEqn -&gt; TySynEqn -&gt; Bool
$c/= :: TySynEqn -&gt; TySynEqn -&gt; Bool
/= :: TySynEqn -&gt; TySynEqn -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203060"><span id="local-6989586621679203066"><span id="local-6989586621679203072"><span id="local-6989586621679203075"><span id="local-6989586621679203078"><span id="local-6989586621679203081"><span id="local-6989586621679203084"><span class="annot"><span class="annottext">Eq TySynEqn
Eq TySynEqn =&gt;
(TySynEqn -&gt; TySynEqn -&gt; Ordering)
-&gt; (TySynEqn -&gt; TySynEqn -&gt; Bool)
-&gt; (TySynEqn -&gt; TySynEqn -&gt; Bool)
-&gt; (TySynEqn -&gt; TySynEqn -&gt; Bool)
-&gt; (TySynEqn -&gt; TySynEqn -&gt; Bool)
-&gt; (TySynEqn -&gt; TySynEqn -&gt; TySynEqn)
-&gt; (TySynEqn -&gt; TySynEqn -&gt; TySynEqn)
-&gt; Ord TySynEqn
TySynEqn -&gt; TySynEqn -&gt; Bool
TySynEqn -&gt; TySynEqn -&gt; Ordering
TySynEqn -&gt; TySynEqn -&gt; TySynEqn
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: TySynEqn -&gt; TySynEqn -&gt; Ordering
compare :: TySynEqn -&gt; TySynEqn -&gt; Ordering
$c&lt; :: TySynEqn -&gt; TySynEqn -&gt; Bool
&lt; :: TySynEqn -&gt; TySynEqn -&gt; Bool
$c&lt;= :: TySynEqn -&gt; TySynEqn -&gt; Bool
&lt;= :: TySynEqn -&gt; TySynEqn -&gt; Bool
$c&gt; :: TySynEqn -&gt; TySynEqn -&gt; Bool
&gt; :: TySynEqn -&gt; TySynEqn -&gt; Bool
$c&gt;= :: TySynEqn -&gt; TySynEqn -&gt; Bool
&gt;= :: TySynEqn -&gt; TySynEqn -&gt; Bool
$cmax :: TySynEqn -&gt; TySynEqn -&gt; TySynEqn
max :: TySynEqn -&gt; TySynEqn -&gt; TySynEqn
$cmin :: TySynEqn -&gt; TySynEqn -&gt; TySynEqn
min :: TySynEqn -&gt; TySynEqn -&gt; TySynEqn
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203093"><span id="local-6989586621679203099"><span id="local-6989586621679203105"><span id="local-6989586621679203107"><span id="local-6989586621679203109"><span id="local-6989586621679203114"><span id="local-6989586621679203119"><span id="local-6989586621679203122"><span id="local-6989586621679203125"><span id="local-6989586621679203128"><span id="local-6989586621679203131"><span id="local-6989586621679203134"><span id="local-6989586621679203139"><span id="local-6989586621679203144"><span class="annot"><span class="annottext">Typeable TySynEqn
Typeable TySynEqn =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; TySynEqn -&gt; c TySynEqn)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TySynEqn)
-&gt; (TySynEqn -&gt; Constr)
-&gt; (TySynEqn -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TySynEqn))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TySynEqn))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; TySynEqn -&gt; TySynEqn)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TySynEqn -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TySynEqn -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TySynEqn -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TySynEqn -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn)
-&gt; Data TySynEqn
TySynEqn -&gt; Constr
TySynEqn -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; TySynEqn -&gt; TySynEqn
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TySynEqn -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TySynEqn -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TySynEqn -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TySynEqn -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TySynEqn
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TySynEqn -&gt; c TySynEqn
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TySynEqn)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TySynEqn)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TySynEqn -&gt; c TySynEqn
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TySynEqn -&gt; c TySynEqn
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TySynEqn
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TySynEqn
$ctoConstr :: TySynEqn -&gt; Constr
toConstr :: TySynEqn -&gt; Constr
$cdataTypeOf :: TySynEqn -&gt; DataType
dataTypeOf :: TySynEqn -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TySynEqn)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TySynEqn)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TySynEqn)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TySynEqn)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TySynEqn -&gt; TySynEqn
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TySynEqn -&gt; TySynEqn
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TySynEqn -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TySynEqn -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TySynEqn -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TySynEqn -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TySynEqn -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TySynEqn -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TySynEqn -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TySynEqn -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TySynEqn -&gt; m TySynEqn
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203153"><span id="local-6989586621679203155"><span class="annot"><span class="annottext">(forall x. TySynEqn -&gt; Rep TySynEqn x)
-&gt; (forall x. Rep TySynEqn x -&gt; TySynEqn) -&gt; Generic TySynEqn
forall x. Rep TySynEqn x -&gt; TySynEqn
forall x. TySynEqn -&gt; Rep TySynEqn x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. TySynEqn -&gt; Rep TySynEqn x
from :: forall x. TySynEqn -&gt; Rep TySynEqn x
$cto :: forall x. Rep TySynEqn x -&gt; TySynEqn
to :: forall x. Rep TySynEqn x -&gt; TySynEqn
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2628"></span><span>
</span><span id="line-2629"></span><span class="hs-keyword">data</span><span> </span><span id="FunDep"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FunDep"><span class="hs-identifier hs-var">FunDep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="FunDep"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FunDep"><span class="hs-identifier hs-var">FunDep</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2630"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679203159"><span id="local-6989586621679203165"><span id="local-6989586621679203168"><span class="annot"><span class="annottext">Int -&gt; FunDep -&gt; FilePath -&gt; FilePath
[FunDep] -&gt; FilePath -&gt; FilePath
FunDep -&gt; FilePath
(Int -&gt; FunDep -&gt; FilePath -&gt; FilePath)
-&gt; (FunDep -&gt; FilePath)
-&gt; ([FunDep] -&gt; FilePath -&gt; FilePath)
-&gt; Show FunDep
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; FunDep -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; FunDep -&gt; FilePath -&gt; FilePath
$cshow :: FunDep -&gt; FilePath
show :: FunDep -&gt; FilePath
$cshowList :: [FunDep] -&gt; FilePath -&gt; FilePath
showList :: [FunDep] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203171"><span id="local-6989586621679203176"><span class="annot"><span class="annottext">FunDep -&gt; FunDep -&gt; Bool
(FunDep -&gt; FunDep -&gt; Bool)
-&gt; (FunDep -&gt; FunDep -&gt; Bool) -&gt; Eq FunDep
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: FunDep -&gt; FunDep -&gt; Bool
== :: FunDep -&gt; FunDep -&gt; Bool
$c/= :: FunDep -&gt; FunDep -&gt; Bool
/= :: FunDep -&gt; FunDep -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203181"><span id="local-6989586621679203186"><span id="local-6989586621679203191"><span id="local-6989586621679203194"><span id="local-6989586621679203197"><span id="local-6989586621679203200"><span id="local-6989586621679203203"><span class="annot"><span class="annottext">Eq FunDep
Eq FunDep =&gt;
(FunDep -&gt; FunDep -&gt; Ordering)
-&gt; (FunDep -&gt; FunDep -&gt; Bool)
-&gt; (FunDep -&gt; FunDep -&gt; Bool)
-&gt; (FunDep -&gt; FunDep -&gt; Bool)
-&gt; (FunDep -&gt; FunDep -&gt; Bool)
-&gt; (FunDep -&gt; FunDep -&gt; FunDep)
-&gt; (FunDep -&gt; FunDep -&gt; FunDep)
-&gt; Ord FunDep
FunDep -&gt; FunDep -&gt; Bool
FunDep -&gt; FunDep -&gt; Ordering
FunDep -&gt; FunDep -&gt; FunDep
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: FunDep -&gt; FunDep -&gt; Ordering
compare :: FunDep -&gt; FunDep -&gt; Ordering
$c&lt; :: FunDep -&gt; FunDep -&gt; Bool
&lt; :: FunDep -&gt; FunDep -&gt; Bool
$c&lt;= :: FunDep -&gt; FunDep -&gt; Bool
&lt;= :: FunDep -&gt; FunDep -&gt; Bool
$c&gt; :: FunDep -&gt; FunDep -&gt; Bool
&gt; :: FunDep -&gt; FunDep -&gt; Bool
$c&gt;= :: FunDep -&gt; FunDep -&gt; Bool
&gt;= :: FunDep -&gt; FunDep -&gt; Bool
$cmax :: FunDep -&gt; FunDep -&gt; FunDep
max :: FunDep -&gt; FunDep -&gt; FunDep
$cmin :: FunDep -&gt; FunDep -&gt; FunDep
min :: FunDep -&gt; FunDep -&gt; FunDep
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203208"><span id="local-6989586621679203213"><span id="local-6989586621679203218"><span id="local-6989586621679203220"><span id="local-6989586621679203222"><span id="local-6989586621679203227"><span id="local-6989586621679203232"><span id="local-6989586621679203235"><span id="local-6989586621679203238"><span id="local-6989586621679203241"><span id="local-6989586621679203244"><span id="local-6989586621679203247"><span id="local-6989586621679203252"><span id="local-6989586621679203257"><span class="annot"><span class="annottext">Typeable FunDep
Typeable FunDep =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; FunDep -&gt; c FunDep)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FunDep)
-&gt; (FunDep -&gt; Constr)
-&gt; (FunDep -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FunDep))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c FunDep))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; FunDep -&gt; FunDep)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep)
-&gt; Data FunDep
FunDep -&gt; Constr
FunDep -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; FunDep -&gt; FunDep
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FunDep
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FunDep -&gt; c FunDep
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FunDep)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c FunDep)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FunDep -&gt; c FunDep
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FunDep -&gt; c FunDep
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FunDep
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FunDep
$ctoConstr :: FunDep -&gt; Constr
toConstr :: FunDep -&gt; Constr
$cdataTypeOf :: FunDep -&gt; DataType
dataTypeOf :: FunDep -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FunDep)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FunDep)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c FunDep)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c FunDep)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FunDep -&gt; FunDep
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FunDep -&gt; FunDep
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep -&gt; m FunDep
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203262"><span id="local-6989586621679203264"><span class="annot"><span class="annottext">(forall x. FunDep -&gt; Rep FunDep x)
-&gt; (forall x. Rep FunDep x -&gt; FunDep) -&gt; Generic FunDep
forall x. Rep FunDep x -&gt; FunDep
forall x. FunDep -&gt; Rep FunDep x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. FunDep -&gt; Rep FunDep x
from :: forall x. FunDep -&gt; Rep FunDep x
$cto :: forall x. Rep FunDep x -&gt; FunDep
to :: forall x. Rep FunDep x -&gt; FunDep
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2631"></span><span>
</span><span id="line-2632"></span><span class="hs-keyword">data</span><span> </span><span id="Foreign"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Foreign"><span class="hs-identifier hs-var">Foreign</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ImportF"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ImportF"><span class="hs-identifier hs-var">ImportF</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Callconv"><span class="hs-identifier hs-type">Callconv</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Safety"><span class="hs-identifier hs-type">Safety</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2633"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="ExportF"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ExportF"><span class="hs-identifier hs-var">ExportF</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Callconv"><span class="hs-identifier hs-type">Callconv</span></a></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2634"></span><span>         </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679203269"><span id="local-6989586621679203285"><span id="local-6989586621679203288"><span class="annot"><span class="annottext">Int -&gt; Foreign -&gt; FilePath -&gt; FilePath
[Foreign] -&gt; FilePath -&gt; FilePath
Foreign -&gt; FilePath
(Int -&gt; Foreign -&gt; FilePath -&gt; FilePath)
-&gt; (Foreign -&gt; FilePath)
-&gt; ([Foreign] -&gt; FilePath -&gt; FilePath)
-&gt; Show Foreign
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Foreign -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Foreign -&gt; FilePath -&gt; FilePath
$cshow :: Foreign -&gt; FilePath
show :: Foreign -&gt; FilePath
$cshowList :: [Foreign] -&gt; FilePath -&gt; FilePath
showList :: [Foreign] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203291"><span id="local-6989586621679203307"><span class="annot"><span class="annottext">Foreign -&gt; Foreign -&gt; Bool
(Foreign -&gt; Foreign -&gt; Bool)
-&gt; (Foreign -&gt; Foreign -&gt; Bool) -&gt; Eq Foreign
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Foreign -&gt; Foreign -&gt; Bool
== :: Foreign -&gt; Foreign -&gt; Bool
$c/= :: Foreign -&gt; Foreign -&gt; Bool
/= :: Foreign -&gt; Foreign -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203312"><span id="local-6989586621679203326"><span id="local-6989586621679203338"><span id="local-6989586621679203341"><span id="local-6989586621679203344"><span id="local-6989586621679203347"><span id="local-6989586621679203350"><span class="annot"><span class="annottext">Eq Foreign
Eq Foreign =&gt;
(Foreign -&gt; Foreign -&gt; Ordering)
-&gt; (Foreign -&gt; Foreign -&gt; Bool)
-&gt; (Foreign -&gt; Foreign -&gt; Bool)
-&gt; (Foreign -&gt; Foreign -&gt; Bool)
-&gt; (Foreign -&gt; Foreign -&gt; Bool)
-&gt; (Foreign -&gt; Foreign -&gt; Foreign)
-&gt; (Foreign -&gt; Foreign -&gt; Foreign)
-&gt; Ord Foreign
Foreign -&gt; Foreign -&gt; Bool
Foreign -&gt; Foreign -&gt; Ordering
Foreign -&gt; Foreign -&gt; Foreign
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Foreign -&gt; Foreign -&gt; Ordering
compare :: Foreign -&gt; Foreign -&gt; Ordering
$c&lt; :: Foreign -&gt; Foreign -&gt; Bool
&lt; :: Foreign -&gt; Foreign -&gt; Bool
$c&lt;= :: Foreign -&gt; Foreign -&gt; Bool
&lt;= :: Foreign -&gt; Foreign -&gt; Bool
$c&gt; :: Foreign -&gt; Foreign -&gt; Bool
&gt; :: Foreign -&gt; Foreign -&gt; Bool
$c&gt;= :: Foreign -&gt; Foreign -&gt; Bool
&gt;= :: Foreign -&gt; Foreign -&gt; Bool
$cmax :: Foreign -&gt; Foreign -&gt; Foreign
max :: Foreign -&gt; Foreign -&gt; Foreign
$cmin :: Foreign -&gt; Foreign -&gt; Foreign
min :: Foreign -&gt; Foreign -&gt; Foreign
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203355"><span id="local-6989586621679203369"><span id="local-6989586621679203381"><span id="local-6989586621679203383"><span id="local-6989586621679203385"><span id="local-6989586621679203390"><span id="local-6989586621679203395"><span id="local-6989586621679203398"><span id="local-6989586621679203401"><span id="local-6989586621679203404"><span id="local-6989586621679203407"><span id="local-6989586621679203410"><span id="local-6989586621679203415"><span id="local-6989586621679203420"><span class="annot"><span class="annottext">Typeable Foreign
Typeable Foreign =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Foreign -&gt; c Foreign)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Foreign)
-&gt; (Foreign -&gt; Constr)
-&gt; (Foreign -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Foreign))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Foreign))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Foreign -&gt; Foreign)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Foreign -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Foreign -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Foreign -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Foreign -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign)
-&gt; Data Foreign
Foreign -&gt; Constr
Foreign -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Foreign -&gt; Foreign
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Foreign -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Foreign -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Foreign -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Foreign -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Foreign
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Foreign -&gt; c Foreign
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Foreign)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Foreign)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Foreign -&gt; c Foreign
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Foreign -&gt; c Foreign
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Foreign
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Foreign
$ctoConstr :: Foreign -&gt; Constr
toConstr :: Foreign -&gt; Constr
$cdataTypeOf :: Foreign -&gt; DataType
dataTypeOf :: Foreign -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Foreign)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Foreign)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Foreign)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Foreign)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Foreign -&gt; Foreign
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Foreign -&gt; Foreign
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Foreign -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Foreign -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Foreign -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Foreign -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Foreign -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Foreign -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Foreign -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Foreign -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Foreign -&gt; m Foreign
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203425"><span id="local-6989586621679203427"><span class="annot"><span class="annottext">(forall x. Foreign -&gt; Rep Foreign x)
-&gt; (forall x. Rep Foreign x -&gt; Foreign) -&gt; Generic Foreign
forall x. Rep Foreign x -&gt; Foreign
forall x. Foreign -&gt; Rep Foreign x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Foreign -&gt; Rep Foreign x
from :: forall x. Foreign -&gt; Rep Foreign x
$cto :: forall x. Rep Foreign x -&gt; Foreign
to :: forall x. Rep Foreign x -&gt; Foreign
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2635"></span><span>
</span><span id="line-2636"></span><span class="hs-comment">-- keep Callconv in sync with module ForeignCall in ghc/compiler/GHC/Types/ForeignCall.hs</span><span>
</span><span id="line-2637"></span><span class="hs-keyword">data</span><span> </span><span id="Callconv"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Callconv"><span class="hs-identifier hs-var">Callconv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="CCall"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CCall"><span class="hs-identifier hs-var">CCall</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="StdCall"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StdCall"><span class="hs-identifier hs-var">StdCall</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="CApi"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CApi"><span class="hs-identifier hs-var">CApi</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Prim"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Prim"><span class="hs-identifier hs-var">Prim</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="JavaScript"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#JavaScript"><span class="hs-identifier hs-var">JavaScript</span></a></span></span><span>
</span><span id="line-2638"></span><span>          </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679203435"><span id="local-6989586621679203437"><span id="local-6989586621679203440"><span class="annot"><span class="annottext">Int -&gt; Callconv -&gt; FilePath -&gt; FilePath
[Callconv] -&gt; FilePath -&gt; FilePath
Callconv -&gt; FilePath
(Int -&gt; Callconv -&gt; FilePath -&gt; FilePath)
-&gt; (Callconv -&gt; FilePath)
-&gt; ([Callconv] -&gt; FilePath -&gt; FilePath)
-&gt; Show Callconv
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Callconv -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Callconv -&gt; FilePath -&gt; FilePath
$cshow :: Callconv -&gt; FilePath
show :: Callconv -&gt; FilePath
$cshowList :: [Callconv] -&gt; FilePath -&gt; FilePath
showList :: [Callconv] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203443"><span id="local-6989586621679203447"><span class="annot"><span class="annottext">Callconv -&gt; Callconv -&gt; Bool
(Callconv -&gt; Callconv -&gt; Bool)
-&gt; (Callconv -&gt; Callconv -&gt; Bool) -&gt; Eq Callconv
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Callconv -&gt; Callconv -&gt; Bool
== :: Callconv -&gt; Callconv -&gt; Bool
$c/= :: Callconv -&gt; Callconv -&gt; Bool
/= :: Callconv -&gt; Callconv -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203452"><span id="local-6989586621679203456"><span id="local-6989586621679203460"><span id="local-6989586621679203463"><span id="local-6989586621679203466"><span id="local-6989586621679203469"><span id="local-6989586621679203472"><span class="annot"><span class="annottext">Eq Callconv
Eq Callconv =&gt;
(Callconv -&gt; Callconv -&gt; Ordering)
-&gt; (Callconv -&gt; Callconv -&gt; Bool)
-&gt; (Callconv -&gt; Callconv -&gt; Bool)
-&gt; (Callconv -&gt; Callconv -&gt; Bool)
-&gt; (Callconv -&gt; Callconv -&gt; Bool)
-&gt; (Callconv -&gt; Callconv -&gt; Callconv)
-&gt; (Callconv -&gt; Callconv -&gt; Callconv)
-&gt; Ord Callconv
Callconv -&gt; Callconv -&gt; Bool
Callconv -&gt; Callconv -&gt; Ordering
Callconv -&gt; Callconv -&gt; Callconv
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Callconv -&gt; Callconv -&gt; Ordering
compare :: Callconv -&gt; Callconv -&gt; Ordering
$c&lt; :: Callconv -&gt; Callconv -&gt; Bool
&lt; :: Callconv -&gt; Callconv -&gt; Bool
$c&lt;= :: Callconv -&gt; Callconv -&gt; Bool
&lt;= :: Callconv -&gt; Callconv -&gt; Bool
$c&gt; :: Callconv -&gt; Callconv -&gt; Bool
&gt; :: Callconv -&gt; Callconv -&gt; Bool
$c&gt;= :: Callconv -&gt; Callconv -&gt; Bool
&gt;= :: Callconv -&gt; Callconv -&gt; Bool
$cmax :: Callconv -&gt; Callconv -&gt; Callconv
max :: Callconv -&gt; Callconv -&gt; Callconv
$cmin :: Callconv -&gt; Callconv -&gt; Callconv
min :: Callconv -&gt; Callconv -&gt; Callconv
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203477"><span id="local-6989586621679203479"><span id="local-6989586621679203481"><span id="local-6989586621679203483"><span id="local-6989586621679203485"><span id="local-6989586621679203490"><span id="local-6989586621679203495"><span id="local-6989586621679203498"><span id="local-6989586621679203501"><span id="local-6989586621679203504"><span id="local-6989586621679203507"><span id="local-6989586621679203510"><span id="local-6989586621679203515"><span id="local-6989586621679203520"><span class="annot"><span class="annottext">Typeable Callconv
Typeable Callconv =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Callconv -&gt; c Callconv)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Callconv)
-&gt; (Callconv -&gt; Constr)
-&gt; (Callconv -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Callconv))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Callconv))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Callconv -&gt; Callconv)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Callconv -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Callconv -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Callconv -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Callconv -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv)
-&gt; Data Callconv
Callconv -&gt; Constr
Callconv -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Callconv -&gt; Callconv
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Callconv -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Callconv -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Callconv -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Callconv -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Callconv
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Callconv -&gt; c Callconv
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Callconv)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Callconv)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Callconv -&gt; c Callconv
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Callconv -&gt; c Callconv
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Callconv
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Callconv
$ctoConstr :: Callconv -&gt; Constr
toConstr :: Callconv -&gt; Constr
$cdataTypeOf :: Callconv -&gt; DataType
dataTypeOf :: Callconv -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Callconv)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Callconv)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Callconv)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Callconv)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Callconv -&gt; Callconv
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Callconv -&gt; Callconv
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Callconv -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Callconv -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Callconv -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Callconv -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Callconv -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Callconv -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Callconv -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Callconv -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Callconv -&gt; m Callconv
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203525"><span id="local-6989586621679203527"><span class="annot"><span class="annottext">(forall x. Callconv -&gt; Rep Callconv x)
-&gt; (forall x. Rep Callconv x -&gt; Callconv) -&gt; Generic Callconv
forall x. Rep Callconv x -&gt; Callconv
forall x. Callconv -&gt; Rep Callconv x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Callconv -&gt; Rep Callconv x
from :: forall x. Callconv -&gt; Rep Callconv x
$cto :: forall x. Rep Callconv x -&gt; Callconv
to :: forall x. Rep Callconv x -&gt; Callconv
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2639"></span><span>
</span><span id="line-2640"></span><span class="hs-keyword">data</span><span> </span><span id="Safety"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Safety"><span class="hs-identifier hs-var">Safety</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Unsafe"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Unsafe"><span class="hs-identifier hs-var">Unsafe</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Safe"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Safe"><span class="hs-identifier hs-var">Safe</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Interruptible"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Interruptible"><span class="hs-identifier hs-var">Interruptible</span></a></span></span><span>
</span><span id="line-2641"></span><span>        </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679203533"><span id="local-6989586621679203535"><span id="local-6989586621679203538"><span class="annot"><span class="annottext">Int -&gt; Safety -&gt; FilePath -&gt; FilePath
[Safety] -&gt; FilePath -&gt; FilePath
Safety -&gt; FilePath
(Int -&gt; Safety -&gt; FilePath -&gt; FilePath)
-&gt; (Safety -&gt; FilePath)
-&gt; ([Safety] -&gt; FilePath -&gt; FilePath)
-&gt; Show Safety
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Safety -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Safety -&gt; FilePath -&gt; FilePath
$cshow :: Safety -&gt; FilePath
show :: Safety -&gt; FilePath
$cshowList :: [Safety] -&gt; FilePath -&gt; FilePath
showList :: [Safety] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203541"><span id="local-6989586621679203545"><span class="annot"><span class="annottext">Safety -&gt; Safety -&gt; Bool
(Safety -&gt; Safety -&gt; Bool)
-&gt; (Safety -&gt; Safety -&gt; Bool) -&gt; Eq Safety
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Safety -&gt; Safety -&gt; Bool
== :: Safety -&gt; Safety -&gt; Bool
$c/= :: Safety -&gt; Safety -&gt; Bool
/= :: Safety -&gt; Safety -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203550"><span id="local-6989586621679203554"><span id="local-6989586621679203558"><span id="local-6989586621679203561"><span id="local-6989586621679203564"><span id="local-6989586621679203567"><span id="local-6989586621679203570"><span class="annot"><span class="annottext">Eq Safety
Eq Safety =&gt;
(Safety -&gt; Safety -&gt; Ordering)
-&gt; (Safety -&gt; Safety -&gt; Bool)
-&gt; (Safety -&gt; Safety -&gt; Bool)
-&gt; (Safety -&gt; Safety -&gt; Bool)
-&gt; (Safety -&gt; Safety -&gt; Bool)
-&gt; (Safety -&gt; Safety -&gt; Safety)
-&gt; (Safety -&gt; Safety -&gt; Safety)
-&gt; Ord Safety
Safety -&gt; Safety -&gt; Bool
Safety -&gt; Safety -&gt; Ordering
Safety -&gt; Safety -&gt; Safety
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Safety -&gt; Safety -&gt; Ordering
compare :: Safety -&gt; Safety -&gt; Ordering
$c&lt; :: Safety -&gt; Safety -&gt; Bool
&lt; :: Safety -&gt; Safety -&gt; Bool
$c&lt;= :: Safety -&gt; Safety -&gt; Bool
&lt;= :: Safety -&gt; Safety -&gt; Bool
$c&gt; :: Safety -&gt; Safety -&gt; Bool
&gt; :: Safety -&gt; Safety -&gt; Bool
$c&gt;= :: Safety -&gt; Safety -&gt; Bool
&gt;= :: Safety -&gt; Safety -&gt; Bool
$cmax :: Safety -&gt; Safety -&gt; Safety
max :: Safety -&gt; Safety -&gt; Safety
$cmin :: Safety -&gt; Safety -&gt; Safety
min :: Safety -&gt; Safety -&gt; Safety
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203575"><span id="local-6989586621679203577"><span id="local-6989586621679203579"><span id="local-6989586621679203581"><span id="local-6989586621679203583"><span id="local-6989586621679203588"><span id="local-6989586621679203593"><span id="local-6989586621679203596"><span id="local-6989586621679203599"><span id="local-6989586621679203602"><span id="local-6989586621679203605"><span id="local-6989586621679203608"><span id="local-6989586621679203613"><span id="local-6989586621679203618"><span class="annot"><span class="annottext">Typeable Safety
Typeable Safety =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Safety -&gt; c Safety)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Safety)
-&gt; (Safety -&gt; Constr)
-&gt; (Safety -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Safety))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Safety))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Safety -&gt; Safety)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Safety -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Safety -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety)
-&gt; Data Safety
Safety -&gt; Constr
Safety -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Safety -&gt; Safety
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Safety -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Safety -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Safety
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Safety -&gt; c Safety
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Safety)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Safety)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Safety -&gt; c Safety
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Safety -&gt; c Safety
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Safety
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Safety
$ctoConstr :: Safety -&gt; Constr
toConstr :: Safety -&gt; Constr
$cdataTypeOf :: Safety -&gt; DataType
dataTypeOf :: Safety -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Safety)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Safety)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Safety)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Safety)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Safety -&gt; Safety
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Safety -&gt; Safety
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Safety -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Safety -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Safety -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Safety -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety -&gt; m Safety
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203623"><span id="local-6989586621679203625"><span class="annot"><span class="annottext">(forall x. Safety -&gt; Rep Safety x)
-&gt; (forall x. Rep Safety x -&gt; Safety) -&gt; Generic Safety
forall x. Rep Safety x -&gt; Safety
forall x. Safety -&gt; Rep Safety x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Safety -&gt; Rep Safety x
from :: forall x. Safety -&gt; Rep Safety x
$cto :: forall x. Rep Safety x -&gt; Safety
to :: forall x. Rep Safety x -&gt; Safety
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2642"></span><span>
</span><span id="line-2643"></span><span class="hs-keyword">data</span><span> </span><span id="Pragma"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pragma"><span class="hs-identifier hs-var">Pragma</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="InlineP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InlineP"><span class="hs-identifier hs-var">InlineP</span></a></span></span><span>         </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Inline"><span class="hs-identifier hs-type">Inline</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RuleMatch"><span class="hs-identifier hs-type">RuleMatch</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Phases"><span class="hs-identifier hs-type">Phases</span></a></span><span>
</span><span id="line-2644"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="OpaqueP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#OpaqueP"><span class="hs-identifier hs-var">OpaqueP</span></a></span></span><span>         </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2645"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="SpecialiseP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SpecialiseP"><span class="hs-identifier hs-var">SpecialiseP</span></a></span></span><span>     </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Inline"><span class="hs-identifier hs-type">Inline</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Phases"><span class="hs-identifier hs-type">Phases</span></a></span><span>
</span><span id="line-2646"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="SpecialiseInstP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SpecialiseInstP"><span class="hs-identifier hs-var">SpecialiseInstP</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2647"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="RuleP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RuleP"><span class="hs-identifier hs-var">RuleP</span></a></span></span><span>           </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RuleBndr"><span class="hs-identifier hs-type">RuleBndr</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Phases"><span class="hs-identifier hs-type">Phases</span></a></span><span>
</span><span id="line-2648"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="AnnP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnnP"><span class="hs-identifier hs-var">AnnP</span></a></span></span><span>            </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnnTarget"><span class="hs-identifier hs-type">AnnTarget</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span>
</span><span id="line-2649"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="LineP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LineP"><span class="hs-identifier hs-var">LineP</span></a></span></span><span>           </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2650"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="CompleteP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CompleteP"><span class="hs-identifier hs-var">CompleteP</span></a></span></span><span>       </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2651"></span><span>                </span><span class="annot"><span class="hs-comment">-- ^ @{ {\-\# COMPLETE C_1, ..., C_i [ :: T ] \#-} }@</span></span><span>
</span><span id="line-2652"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="SCCP"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SCCP"><span class="hs-identifier hs-var">SCCP</span></a></span></span><span>            </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span>
</span><span id="line-2653"></span><span>                </span><span class="annot"><span class="hs-comment">-- ^ @{ {\-\# SCC fun &quot;optional_name&quot; \#-} }@</span></span><span>
</span><span id="line-2654"></span><span>        </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679203637"><span id="local-6989586621679203679"><span id="local-6989586621679203682"><span class="annot"><span class="annottext">Int -&gt; Pragma -&gt; FilePath -&gt; FilePath
[Pragma] -&gt; FilePath -&gt; FilePath
Pragma -&gt; FilePath
(Int -&gt; Pragma -&gt; FilePath -&gt; FilePath)
-&gt; (Pragma -&gt; FilePath)
-&gt; ([Pragma] -&gt; FilePath -&gt; FilePath)
-&gt; Show Pragma
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Pragma -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Pragma -&gt; FilePath -&gt; FilePath
$cshow :: Pragma -&gt; FilePath
show :: Pragma -&gt; FilePath
$cshowList :: [Pragma] -&gt; FilePath -&gt; FilePath
showList :: [Pragma] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203688"><span id="local-6989586621679203723"><span class="annot"><span class="annottext">Pragma -&gt; Pragma -&gt; Bool
(Pragma -&gt; Pragma -&gt; Bool)
-&gt; (Pragma -&gt; Pragma -&gt; Bool) -&gt; Eq Pragma
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Pragma -&gt; Pragma -&gt; Bool
== :: Pragma -&gt; Pragma -&gt; Bool
$c/= :: Pragma -&gt; Pragma -&gt; Bool
/= :: Pragma -&gt; Pragma -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203731"><span id="local-6989586621679203769"><span id="local-6989586621679203772"><span id="local-6989586621679203775"><span id="local-6989586621679203778"><span id="local-6989586621679203781"><span id="local-6989586621679203784"><span class="annot"><span class="annottext">Eq Pragma
Eq Pragma =&gt;
(Pragma -&gt; Pragma -&gt; Ordering)
-&gt; (Pragma -&gt; Pragma -&gt; Bool)
-&gt; (Pragma -&gt; Pragma -&gt; Bool)
-&gt; (Pragma -&gt; Pragma -&gt; Bool)
-&gt; (Pragma -&gt; Pragma -&gt; Bool)
-&gt; (Pragma -&gt; Pragma -&gt; Pragma)
-&gt; (Pragma -&gt; Pragma -&gt; Pragma)
-&gt; Ord Pragma
Pragma -&gt; Pragma -&gt; Bool
Pragma -&gt; Pragma -&gt; Ordering
Pragma -&gt; Pragma -&gt; Pragma
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Pragma -&gt; Pragma -&gt; Ordering
compare :: Pragma -&gt; Pragma -&gt; Ordering
$c&lt; :: Pragma -&gt; Pragma -&gt; Bool
&lt; :: Pragma -&gt; Pragma -&gt; Bool
$c&lt;= :: Pragma -&gt; Pragma -&gt; Bool
&lt;= :: Pragma -&gt; Pragma -&gt; Bool
$c&gt; :: Pragma -&gt; Pragma -&gt; Bool
&gt; :: Pragma -&gt; Pragma -&gt; Bool
$c&gt;= :: Pragma -&gt; Pragma -&gt; Bool
&gt;= :: Pragma -&gt; Pragma -&gt; Bool
$cmax :: Pragma -&gt; Pragma -&gt; Pragma
max :: Pragma -&gt; Pragma -&gt; Pragma
$cmin :: Pragma -&gt; Pragma -&gt; Pragma
min :: Pragma -&gt; Pragma -&gt; Pragma
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203792"><span id="local-6989586621679203825"><span id="local-6989586621679203854"><span id="local-6989586621679203856"><span id="local-6989586621679203858"><span id="local-6989586621679203863"><span id="local-6989586621679203868"><span id="local-6989586621679203871"><span id="local-6989586621679203874"><span id="local-6989586621679203877"><span id="local-6989586621679203880"><span id="local-6989586621679203883"><span id="local-6989586621679203888"><span id="local-6989586621679203893"><span class="annot"><span class="annottext">Typeable Pragma
Typeable Pragma =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Pragma -&gt; c Pragma)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Pragma)
-&gt; (Pragma -&gt; Constr)
-&gt; (Pragma -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Pragma))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Pragma))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Pragma -&gt; Pragma)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pragma -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pragma -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pragma -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pragma -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma)
-&gt; Data Pragma
Pragma -&gt; Constr
Pragma -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Pragma -&gt; Pragma
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pragma -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pragma -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pragma -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pragma -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Pragma
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pragma -&gt; c Pragma
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Pragma)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Pragma)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pragma -&gt; c Pragma
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pragma -&gt; c Pragma
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Pragma
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Pragma
$ctoConstr :: Pragma -&gt; Constr
toConstr :: Pragma -&gt; Constr
$cdataTypeOf :: Pragma -&gt; DataType
dataTypeOf :: Pragma -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Pragma)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Pragma)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Pragma)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Pragma)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Pragma -&gt; Pragma
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Pragma -&gt; Pragma
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pragma -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pragma -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pragma -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pragma -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pragma -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pragma -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pragma -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pragma -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pragma -&gt; m Pragma
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203903"><span id="local-6989586621679203905"><span class="annot"><span class="annottext">(forall x. Pragma -&gt; Rep Pragma x)
-&gt; (forall x. Rep Pragma x -&gt; Pragma) -&gt; Generic Pragma
forall x. Rep Pragma x -&gt; Pragma
forall x. Pragma -&gt; Rep Pragma x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Pragma -&gt; Rep Pragma x
from :: forall x. Pragma -&gt; Rep Pragma x
$cto :: forall x. Rep Pragma x -&gt; Pragma
to :: forall x. Rep Pragma x -&gt; Pragma
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2655"></span><span>
</span><span id="line-2656"></span><span class="hs-keyword">data</span><span> </span><span id="Inline"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Inline"><span class="hs-identifier hs-var">Inline</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="NoInline"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NoInline"><span class="hs-identifier hs-var">NoInline</span></a></span></span><span>
</span><span id="line-2657"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="Inline"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Inline"><span class="hs-identifier hs-var">Inline</span></a></span></span><span>
</span><span id="line-2658"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="Inlinable"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Inlinable"><span class="hs-identifier hs-var">Inlinable</span></a></span></span><span>
</span><span id="line-2659"></span><span>            </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679203908"><span id="local-6989586621679203910"><span id="local-6989586621679203913"><span class="annot"><span class="annottext">Int -&gt; Inline -&gt; FilePath -&gt; FilePath
[Inline] -&gt; FilePath -&gt; FilePath
Inline -&gt; FilePath
(Int -&gt; Inline -&gt; FilePath -&gt; FilePath)
-&gt; (Inline -&gt; FilePath)
-&gt; ([Inline] -&gt; FilePath -&gt; FilePath)
-&gt; Show Inline
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Inline -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Inline -&gt; FilePath -&gt; FilePath
$cshow :: Inline -&gt; FilePath
show :: Inline -&gt; FilePath
$cshowList :: [Inline] -&gt; FilePath -&gt; FilePath
showList :: [Inline] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203916"><span id="local-6989586621679203920"><span class="annot"><span class="annottext">Inline -&gt; Inline -&gt; Bool
(Inline -&gt; Inline -&gt; Bool)
-&gt; (Inline -&gt; Inline -&gt; Bool) -&gt; Eq Inline
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Inline -&gt; Inline -&gt; Bool
== :: Inline -&gt; Inline -&gt; Bool
$c/= :: Inline -&gt; Inline -&gt; Bool
/= :: Inline -&gt; Inline -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203925"><span id="local-6989586621679203929"><span id="local-6989586621679203933"><span id="local-6989586621679203936"><span id="local-6989586621679203939"><span id="local-6989586621679203942"><span id="local-6989586621679203945"><span class="annot"><span class="annottext">Eq Inline
Eq Inline =&gt;
(Inline -&gt; Inline -&gt; Ordering)
-&gt; (Inline -&gt; Inline -&gt; Bool)
-&gt; (Inline -&gt; Inline -&gt; Bool)
-&gt; (Inline -&gt; Inline -&gt; Bool)
-&gt; (Inline -&gt; Inline -&gt; Bool)
-&gt; (Inline -&gt; Inline -&gt; Inline)
-&gt; (Inline -&gt; Inline -&gt; Inline)
-&gt; Ord Inline
Inline -&gt; Inline -&gt; Bool
Inline -&gt; Inline -&gt; Ordering
Inline -&gt; Inline -&gt; Inline
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Inline -&gt; Inline -&gt; Ordering
compare :: Inline -&gt; Inline -&gt; Ordering
$c&lt; :: Inline -&gt; Inline -&gt; Bool
&lt; :: Inline -&gt; Inline -&gt; Bool
$c&lt;= :: Inline -&gt; Inline -&gt; Bool
&lt;= :: Inline -&gt; Inline -&gt; Bool
$c&gt; :: Inline -&gt; Inline -&gt; Bool
&gt; :: Inline -&gt; Inline -&gt; Bool
$c&gt;= :: Inline -&gt; Inline -&gt; Bool
&gt;= :: Inline -&gt; Inline -&gt; Bool
$cmax :: Inline -&gt; Inline -&gt; Inline
max :: Inline -&gt; Inline -&gt; Inline
$cmin :: Inline -&gt; Inline -&gt; Inline
min :: Inline -&gt; Inline -&gt; Inline
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203950"><span id="local-6989586621679203952"><span id="local-6989586621679203954"><span id="local-6989586621679203956"><span id="local-6989586621679203958"><span id="local-6989586621679203963"><span id="local-6989586621679203968"><span id="local-6989586621679203971"><span id="local-6989586621679203974"><span id="local-6989586621679203977"><span id="local-6989586621679203980"><span id="local-6989586621679203983"><span id="local-6989586621679203988"><span id="local-6989586621679203993"><span class="annot"><span class="annottext">Typeable Inline
Typeable Inline =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Inline -&gt; c Inline)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Inline)
-&gt; (Inline -&gt; Constr)
-&gt; (Inline -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Inline))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Inline))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Inline -&gt; Inline)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Inline -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Inline -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Inline -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Inline -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline)
-&gt; Data Inline
Inline -&gt; Constr
Inline -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Inline -&gt; Inline
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Inline -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Inline -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Inline -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Inline -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Inline
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Inline -&gt; c Inline
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Inline)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Inline)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Inline -&gt; c Inline
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Inline -&gt; c Inline
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Inline
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Inline
$ctoConstr :: Inline -&gt; Constr
toConstr :: Inline -&gt; Constr
$cdataTypeOf :: Inline -&gt; DataType
dataTypeOf :: Inline -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Inline)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Inline)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Inline)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Inline)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Inline -&gt; Inline
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Inline -&gt; Inline
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Inline -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Inline -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Inline -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Inline -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Inline -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Inline -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Inline -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Inline -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Inline -&gt; m Inline
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679203998"><span id="local-6989586621679204000"><span class="annot"><span class="annottext">(forall x. Inline -&gt; Rep Inline x)
-&gt; (forall x. Rep Inline x -&gt; Inline) -&gt; Generic Inline
forall x. Rep Inline x -&gt; Inline
forall x. Inline -&gt; Rep Inline x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Inline -&gt; Rep Inline x
from :: forall x. Inline -&gt; Rep Inline x
$cto :: forall x. Rep Inline x -&gt; Inline
to :: forall x. Rep Inline x -&gt; Inline
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2660"></span><span>
</span><span id="line-2661"></span><span class="hs-keyword">data</span><span> </span><span id="RuleMatch"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RuleMatch"><span class="hs-identifier hs-var">RuleMatch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ConLike"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ConLike"><span class="hs-identifier hs-var">ConLike</span></a></span></span><span>
</span><span id="line-2662"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="FunLike"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FunLike"><span class="hs-identifier hs-var">FunLike</span></a></span></span><span>
</span><span id="line-2663"></span><span>               </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204003"><span id="local-6989586621679204005"><span id="local-6989586621679204008"><span class="annot"><span class="annottext">Int -&gt; RuleMatch -&gt; FilePath -&gt; FilePath
[RuleMatch] -&gt; FilePath -&gt; FilePath
RuleMatch -&gt; FilePath
(Int -&gt; RuleMatch -&gt; FilePath -&gt; FilePath)
-&gt; (RuleMatch -&gt; FilePath)
-&gt; ([RuleMatch] -&gt; FilePath -&gt; FilePath)
-&gt; Show RuleMatch
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; RuleMatch -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; RuleMatch -&gt; FilePath -&gt; FilePath
$cshow :: RuleMatch -&gt; FilePath
show :: RuleMatch -&gt; FilePath
$cshowList :: [RuleMatch] -&gt; FilePath -&gt; FilePath
showList :: [RuleMatch] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204011"><span id="local-6989586621679204015"><span class="annot"><span class="annottext">RuleMatch -&gt; RuleMatch -&gt; Bool
(RuleMatch -&gt; RuleMatch -&gt; Bool)
-&gt; (RuleMatch -&gt; RuleMatch -&gt; Bool) -&gt; Eq RuleMatch
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: RuleMatch -&gt; RuleMatch -&gt; Bool
== :: RuleMatch -&gt; RuleMatch -&gt; Bool
$c/= :: RuleMatch -&gt; RuleMatch -&gt; Bool
/= :: RuleMatch -&gt; RuleMatch -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204020"><span id="local-6989586621679204022"><span id="local-6989586621679204024"><span id="local-6989586621679204027"><span id="local-6989586621679204030"><span id="local-6989586621679204033"><span id="local-6989586621679204036"><span class="annot"><span class="annottext">Eq RuleMatch
Eq RuleMatch =&gt;
(RuleMatch -&gt; RuleMatch -&gt; Ordering)
-&gt; (RuleMatch -&gt; RuleMatch -&gt; Bool)
-&gt; (RuleMatch -&gt; RuleMatch -&gt; Bool)
-&gt; (RuleMatch -&gt; RuleMatch -&gt; Bool)
-&gt; (RuleMatch -&gt; RuleMatch -&gt; Bool)
-&gt; (RuleMatch -&gt; RuleMatch -&gt; RuleMatch)
-&gt; (RuleMatch -&gt; RuleMatch -&gt; RuleMatch)
-&gt; Ord RuleMatch
RuleMatch -&gt; RuleMatch -&gt; Bool
RuleMatch -&gt; RuleMatch -&gt; Ordering
RuleMatch -&gt; RuleMatch -&gt; RuleMatch
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: RuleMatch -&gt; RuleMatch -&gt; Ordering
compare :: RuleMatch -&gt; RuleMatch -&gt; Ordering
$c&lt; :: RuleMatch -&gt; RuleMatch -&gt; Bool
&lt; :: RuleMatch -&gt; RuleMatch -&gt; Bool
$c&lt;= :: RuleMatch -&gt; RuleMatch -&gt; Bool
&lt;= :: RuleMatch -&gt; RuleMatch -&gt; Bool
$c&gt; :: RuleMatch -&gt; RuleMatch -&gt; Bool
&gt; :: RuleMatch -&gt; RuleMatch -&gt; Bool
$c&gt;= :: RuleMatch -&gt; RuleMatch -&gt; Bool
&gt;= :: RuleMatch -&gt; RuleMatch -&gt; Bool
$cmax :: RuleMatch -&gt; RuleMatch -&gt; RuleMatch
max :: RuleMatch -&gt; RuleMatch -&gt; RuleMatch
$cmin :: RuleMatch -&gt; RuleMatch -&gt; RuleMatch
min :: RuleMatch -&gt; RuleMatch -&gt; RuleMatch
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204041"><span id="local-6989586621679204043"><span id="local-6989586621679204045"><span id="local-6989586621679204047"><span id="local-6989586621679204049"><span id="local-6989586621679204054"><span id="local-6989586621679204059"><span id="local-6989586621679204062"><span id="local-6989586621679204065"><span id="local-6989586621679204068"><span id="local-6989586621679204071"><span id="local-6989586621679204074"><span id="local-6989586621679204079"><span id="local-6989586621679204084"><span class="annot"><span class="annottext">Typeable RuleMatch
Typeable RuleMatch =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; RuleMatch -&gt; c RuleMatch)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RuleMatch)
-&gt; (RuleMatch -&gt; Constr)
-&gt; (RuleMatch -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RuleMatch))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c RuleMatch))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; RuleMatch -&gt; RuleMatch)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleMatch -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleMatch -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleMatch -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleMatch -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch)
-&gt; Data RuleMatch
RuleMatch -&gt; Constr
RuleMatch -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; RuleMatch -&gt; RuleMatch
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleMatch -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleMatch -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleMatch -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleMatch -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RuleMatch
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleMatch -&gt; c RuleMatch
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RuleMatch)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c RuleMatch)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleMatch -&gt; c RuleMatch
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleMatch -&gt; c RuleMatch
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RuleMatch
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RuleMatch
$ctoConstr :: RuleMatch -&gt; Constr
toConstr :: RuleMatch -&gt; Constr
$cdataTypeOf :: RuleMatch -&gt; DataType
dataTypeOf :: RuleMatch -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RuleMatch)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RuleMatch)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c RuleMatch)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c RuleMatch)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RuleMatch -&gt; RuleMatch
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RuleMatch -&gt; RuleMatch
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleMatch -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleMatch -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleMatch -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleMatch -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleMatch -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleMatch -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleMatch -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleMatch -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleMatch -&gt; m RuleMatch
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204089"><span id="local-6989586621679204091"><span class="annot"><span class="annottext">(forall x. RuleMatch -&gt; Rep RuleMatch x)
-&gt; (forall x. Rep RuleMatch x -&gt; RuleMatch) -&gt; Generic RuleMatch
forall x. Rep RuleMatch x -&gt; RuleMatch
forall x. RuleMatch -&gt; Rep RuleMatch x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. RuleMatch -&gt; Rep RuleMatch x
from :: forall x. RuleMatch -&gt; Rep RuleMatch x
$cto :: forall x. Rep RuleMatch x -&gt; RuleMatch
to :: forall x. Rep RuleMatch x -&gt; RuleMatch
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2664"></span><span>
</span><span id="line-2665"></span><span class="hs-keyword">data</span><span> </span><span id="Phases"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Phases"><span class="hs-identifier hs-var">Phases</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="AllPhases"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AllPhases"><span class="hs-identifier hs-var">AllPhases</span></a></span></span><span>
</span><span id="line-2666"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="FromPhase"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FromPhase"><span class="hs-identifier hs-var">FromPhase</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-2667"></span><span>            </span><span class="hs-glyph">|</span><span> </span><span id="BeforePhase"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BeforePhase"><span class="hs-identifier hs-var">BeforePhase</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-2668"></span><span>            </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204094"><span id="local-6989586621679204100"><span id="local-6989586621679204103"><span class="annot"><span class="annottext">Int -&gt; Phases -&gt; FilePath -&gt; FilePath
[Phases] -&gt; FilePath -&gt; FilePath
Phases -&gt; FilePath
(Int -&gt; Phases -&gt; FilePath -&gt; FilePath)
-&gt; (Phases -&gt; FilePath)
-&gt; ([Phases] -&gt; FilePath -&gt; FilePath)
-&gt; Show Phases
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Phases -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Phases -&gt; FilePath -&gt; FilePath
$cshow :: Phases -&gt; FilePath
show :: Phases -&gt; FilePath
$cshowList :: [Phases] -&gt; FilePath -&gt; FilePath
showList :: [Phases] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204106"><span id="local-6989586621679204112"><span class="annot"><span class="annottext">Phases -&gt; Phases -&gt; Bool
(Phases -&gt; Phases -&gt; Bool)
-&gt; (Phases -&gt; Phases -&gt; Bool) -&gt; Eq Phases
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Phases -&gt; Phases -&gt; Bool
== :: Phases -&gt; Phases -&gt; Bool
$c/= :: Phases -&gt; Phases -&gt; Bool
/= :: Phases -&gt; Phases -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204117"><span id="local-6989586621679204121"><span id="local-6989586621679204125"><span id="local-6989586621679204128"><span id="local-6989586621679204131"><span id="local-6989586621679204134"><span id="local-6989586621679204137"><span class="annot"><span class="annottext">Eq Phases
Eq Phases =&gt;
(Phases -&gt; Phases -&gt; Ordering)
-&gt; (Phases -&gt; Phases -&gt; Bool)
-&gt; (Phases -&gt; Phases -&gt; Bool)
-&gt; (Phases -&gt; Phases -&gt; Bool)
-&gt; (Phases -&gt; Phases -&gt; Bool)
-&gt; (Phases -&gt; Phases -&gt; Phases)
-&gt; (Phases -&gt; Phases -&gt; Phases)
-&gt; Ord Phases
Phases -&gt; Phases -&gt; Bool
Phases -&gt; Phases -&gt; Ordering
Phases -&gt; Phases -&gt; Phases
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Phases -&gt; Phases -&gt; Ordering
compare :: Phases -&gt; Phases -&gt; Ordering
$c&lt; :: Phases -&gt; Phases -&gt; Bool
&lt; :: Phases -&gt; Phases -&gt; Bool
$c&lt;= :: Phases -&gt; Phases -&gt; Bool
&lt;= :: Phases -&gt; Phases -&gt; Bool
$c&gt; :: Phases -&gt; Phases -&gt; Bool
&gt; :: Phases -&gt; Phases -&gt; Bool
$c&gt;= :: Phases -&gt; Phases -&gt; Bool
&gt;= :: Phases -&gt; Phases -&gt; Bool
$cmax :: Phases -&gt; Phases -&gt; Phases
max :: Phases -&gt; Phases -&gt; Phases
$cmin :: Phases -&gt; Phases -&gt; Phases
min :: Phases -&gt; Phases -&gt; Phases
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204142"><span id="local-6989586621679204146"><span id="local-6989586621679204150"><span id="local-6989586621679204152"><span id="local-6989586621679204154"><span id="local-6989586621679204159"><span id="local-6989586621679204164"><span id="local-6989586621679204167"><span id="local-6989586621679204170"><span id="local-6989586621679204173"><span id="local-6989586621679204176"><span id="local-6989586621679204179"><span id="local-6989586621679204184"><span id="local-6989586621679204189"><span class="annot"><span class="annottext">Typeable Phases
Typeable Phases =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Phases -&gt; c Phases)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Phases)
-&gt; (Phases -&gt; Constr)
-&gt; (Phases -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Phases))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Phases))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Phases -&gt; Phases)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Phases -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Phases -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Phases -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Phases -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases)
-&gt; Data Phases
Phases -&gt; Constr
Phases -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Phases -&gt; Phases
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Phases -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Phases -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Phases -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Phases -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Phases
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Phases -&gt; c Phases
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Phases)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Phases)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Phases -&gt; c Phases
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Phases -&gt; c Phases
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Phases
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Phases
$ctoConstr :: Phases -&gt; Constr
toConstr :: Phases -&gt; Constr
$cdataTypeOf :: Phases -&gt; DataType
dataTypeOf :: Phases -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Phases)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Phases)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Phases)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Phases)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Phases -&gt; Phases
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Phases -&gt; Phases
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Phases -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Phases -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Phases -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Phases -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Phases -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Phases -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Phases -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Phases -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Phases -&gt; m Phases
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204194"><span id="local-6989586621679204196"><span class="annot"><span class="annottext">(forall x. Phases -&gt; Rep Phases x)
-&gt; (forall x. Rep Phases x -&gt; Phases) -&gt; Generic Phases
forall x. Rep Phases x -&gt; Phases
forall x. Phases -&gt; Rep Phases x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Phases -&gt; Rep Phases x
from :: forall x. Phases -&gt; Rep Phases x
$cto :: forall x. Rep Phases x -&gt; Phases
to :: forall x. Rep Phases x -&gt; Phases
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2669"></span><span>
</span><span id="line-2670"></span><span class="hs-keyword">data</span><span> </span><span id="RuleBndr"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RuleBndr"><span class="hs-identifier hs-var">RuleBndr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="RuleVar"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RuleVar"><span class="hs-identifier hs-var">RuleVar</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2671"></span><span>              </span><span class="hs-glyph">|</span><span> </span><span id="TypedRuleVar"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypedRuleVar"><span class="hs-identifier hs-var">TypedRuleVar</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2672"></span><span>              </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204201"><span id="local-6989586621679204208"><span id="local-6989586621679204211"><span class="annot"><span class="annottext">Int -&gt; RuleBndr -&gt; FilePath -&gt; FilePath
[RuleBndr] -&gt; FilePath -&gt; FilePath
RuleBndr -&gt; FilePath
(Int -&gt; RuleBndr -&gt; FilePath -&gt; FilePath)
-&gt; (RuleBndr -&gt; FilePath)
-&gt; ([RuleBndr] -&gt; FilePath -&gt; FilePath)
-&gt; Show RuleBndr
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; RuleBndr -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; RuleBndr -&gt; FilePath -&gt; FilePath
$cshow :: RuleBndr -&gt; FilePath
show :: RuleBndr -&gt; FilePath
$cshowList :: [RuleBndr] -&gt; FilePath -&gt; FilePath
showList :: [RuleBndr] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204214"><span id="local-6989586621679204221"><span class="annot"><span class="annottext">RuleBndr -&gt; RuleBndr -&gt; Bool
(RuleBndr -&gt; RuleBndr -&gt; Bool)
-&gt; (RuleBndr -&gt; RuleBndr -&gt; Bool) -&gt; Eq RuleBndr
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: RuleBndr -&gt; RuleBndr -&gt; Bool
== :: RuleBndr -&gt; RuleBndr -&gt; Bool
$c/= :: RuleBndr -&gt; RuleBndr -&gt; Bool
/= :: RuleBndr -&gt; RuleBndr -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204226"><span id="local-6989586621679204231"><span id="local-6989586621679204236"><span id="local-6989586621679204239"><span id="local-6989586621679204242"><span id="local-6989586621679204245"><span id="local-6989586621679204248"><span class="annot"><span class="annottext">Eq RuleBndr
Eq RuleBndr =&gt;
(RuleBndr -&gt; RuleBndr -&gt; Ordering)
-&gt; (RuleBndr -&gt; RuleBndr -&gt; Bool)
-&gt; (RuleBndr -&gt; RuleBndr -&gt; Bool)
-&gt; (RuleBndr -&gt; RuleBndr -&gt; Bool)
-&gt; (RuleBndr -&gt; RuleBndr -&gt; Bool)
-&gt; (RuleBndr -&gt; RuleBndr -&gt; RuleBndr)
-&gt; (RuleBndr -&gt; RuleBndr -&gt; RuleBndr)
-&gt; Ord RuleBndr
RuleBndr -&gt; RuleBndr -&gt; Bool
RuleBndr -&gt; RuleBndr -&gt; Ordering
RuleBndr -&gt; RuleBndr -&gt; RuleBndr
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: RuleBndr -&gt; RuleBndr -&gt; Ordering
compare :: RuleBndr -&gt; RuleBndr -&gt; Ordering
$c&lt; :: RuleBndr -&gt; RuleBndr -&gt; Bool
&lt; :: RuleBndr -&gt; RuleBndr -&gt; Bool
$c&lt;= :: RuleBndr -&gt; RuleBndr -&gt; Bool
&lt;= :: RuleBndr -&gt; RuleBndr -&gt; Bool
$c&gt; :: RuleBndr -&gt; RuleBndr -&gt; Bool
&gt; :: RuleBndr -&gt; RuleBndr -&gt; Bool
$c&gt;= :: RuleBndr -&gt; RuleBndr -&gt; Bool
&gt;= :: RuleBndr -&gt; RuleBndr -&gt; Bool
$cmax :: RuleBndr -&gt; RuleBndr -&gt; RuleBndr
max :: RuleBndr -&gt; RuleBndr -&gt; RuleBndr
$cmin :: RuleBndr -&gt; RuleBndr -&gt; RuleBndr
min :: RuleBndr -&gt; RuleBndr -&gt; RuleBndr
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204253"><span id="local-6989586621679204258"><span id="local-6989586621679204263"><span id="local-6989586621679204265"><span id="local-6989586621679204267"><span id="local-6989586621679204272"><span id="local-6989586621679204277"><span id="local-6989586621679204280"><span id="local-6989586621679204283"><span id="local-6989586621679204286"><span id="local-6989586621679204289"><span id="local-6989586621679204292"><span id="local-6989586621679204297"><span id="local-6989586621679204302"><span class="annot"><span class="annottext">Typeable RuleBndr
Typeable RuleBndr =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; RuleBndr -&gt; c RuleBndr)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RuleBndr)
-&gt; (RuleBndr -&gt; Constr)
-&gt; (RuleBndr -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RuleBndr))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c RuleBndr))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; RuleBndr -&gt; RuleBndr)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleBndr -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleBndr -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleBndr -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleBndr -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr)
-&gt; Data RuleBndr
RuleBndr -&gt; Constr
RuleBndr -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; RuleBndr -&gt; RuleBndr
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleBndr -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleBndr -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleBndr -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleBndr -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RuleBndr
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleBndr -&gt; c RuleBndr
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RuleBndr)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c RuleBndr)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleBndr -&gt; c RuleBndr
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleBndr -&gt; c RuleBndr
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RuleBndr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c RuleBndr
$ctoConstr :: RuleBndr -&gt; Constr
toConstr :: RuleBndr -&gt; Constr
$cdataTypeOf :: RuleBndr -&gt; DataType
dataTypeOf :: RuleBndr -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RuleBndr)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c RuleBndr)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c RuleBndr)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c RuleBndr)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RuleBndr -&gt; RuleBndr
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RuleBndr -&gt; RuleBndr
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleBndr -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleBndr -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleBndr -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleBndr -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleBndr -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleBndr -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleBndr -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleBndr -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleBndr -&gt; m RuleBndr
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204307"><span id="local-6989586621679204309"><span class="annot"><span class="annottext">(forall x. RuleBndr -&gt; Rep RuleBndr x)
-&gt; (forall x. Rep RuleBndr x -&gt; RuleBndr) -&gt; Generic RuleBndr
forall x. Rep RuleBndr x -&gt; RuleBndr
forall x. RuleBndr -&gt; Rep RuleBndr x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. RuleBndr -&gt; Rep RuleBndr x
from :: forall x. RuleBndr -&gt; Rep RuleBndr x
$cto :: forall x. Rep RuleBndr x -&gt; RuleBndr
to :: forall x. Rep RuleBndr x -&gt; RuleBndr
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2673"></span><span>
</span><span id="line-2674"></span><span class="hs-keyword">data</span><span> </span><span id="AnnTarget"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnnTarget"><span class="hs-identifier hs-var">AnnTarget</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ModuleAnnotation"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModuleAnnotation"><span class="hs-identifier hs-var">ModuleAnnotation</span></a></span></span><span>
</span><span id="line-2675"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="TypeAnnotation"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TypeAnnotation"><span class="hs-identifier hs-var">TypeAnnotation</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2676"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="ValueAnnotation"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ValueAnnotation"><span class="hs-identifier hs-var">ValueAnnotation</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2677"></span><span>              </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204315"><span id="local-6989586621679204321"><span id="local-6989586621679204324"><span class="annot"><span class="annottext">Int -&gt; AnnTarget -&gt; FilePath -&gt; FilePath
[AnnTarget] -&gt; FilePath -&gt; FilePath
AnnTarget -&gt; FilePath
(Int -&gt; AnnTarget -&gt; FilePath -&gt; FilePath)
-&gt; (AnnTarget -&gt; FilePath)
-&gt; ([AnnTarget] -&gt; FilePath -&gt; FilePath)
-&gt; Show AnnTarget
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; AnnTarget -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; AnnTarget -&gt; FilePath -&gt; FilePath
$cshow :: AnnTarget -&gt; FilePath
show :: AnnTarget -&gt; FilePath
$cshowList :: [AnnTarget] -&gt; FilePath -&gt; FilePath
showList :: [AnnTarget] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204327"><span id="local-6989586621679204333"><span class="annot"><span class="annottext">AnnTarget -&gt; AnnTarget -&gt; Bool
(AnnTarget -&gt; AnnTarget -&gt; Bool)
-&gt; (AnnTarget -&gt; AnnTarget -&gt; Bool) -&gt; Eq AnnTarget
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: AnnTarget -&gt; AnnTarget -&gt; Bool
== :: AnnTarget -&gt; AnnTarget -&gt; Bool
$c/= :: AnnTarget -&gt; AnnTarget -&gt; Bool
/= :: AnnTarget -&gt; AnnTarget -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204338"><span id="local-6989586621679204342"><span id="local-6989586621679204346"><span id="local-6989586621679204349"><span id="local-6989586621679204352"><span id="local-6989586621679204355"><span id="local-6989586621679204358"><span class="annot"><span class="annottext">Eq AnnTarget
Eq AnnTarget =&gt;
(AnnTarget -&gt; AnnTarget -&gt; Ordering)
-&gt; (AnnTarget -&gt; AnnTarget -&gt; Bool)
-&gt; (AnnTarget -&gt; AnnTarget -&gt; Bool)
-&gt; (AnnTarget -&gt; AnnTarget -&gt; Bool)
-&gt; (AnnTarget -&gt; AnnTarget -&gt; Bool)
-&gt; (AnnTarget -&gt; AnnTarget -&gt; AnnTarget)
-&gt; (AnnTarget -&gt; AnnTarget -&gt; AnnTarget)
-&gt; Ord AnnTarget
AnnTarget -&gt; AnnTarget -&gt; Bool
AnnTarget -&gt; AnnTarget -&gt; Ordering
AnnTarget -&gt; AnnTarget -&gt; AnnTarget
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: AnnTarget -&gt; AnnTarget -&gt; Ordering
compare :: AnnTarget -&gt; AnnTarget -&gt; Ordering
$c&lt; :: AnnTarget -&gt; AnnTarget -&gt; Bool
&lt; :: AnnTarget -&gt; AnnTarget -&gt; Bool
$c&lt;= :: AnnTarget -&gt; AnnTarget -&gt; Bool
&lt;= :: AnnTarget -&gt; AnnTarget -&gt; Bool
$c&gt; :: AnnTarget -&gt; AnnTarget -&gt; Bool
&gt; :: AnnTarget -&gt; AnnTarget -&gt; Bool
$c&gt;= :: AnnTarget -&gt; AnnTarget -&gt; Bool
&gt;= :: AnnTarget -&gt; AnnTarget -&gt; Bool
$cmax :: AnnTarget -&gt; AnnTarget -&gt; AnnTarget
max :: AnnTarget -&gt; AnnTarget -&gt; AnnTarget
$cmin :: AnnTarget -&gt; AnnTarget -&gt; AnnTarget
min :: AnnTarget -&gt; AnnTarget -&gt; AnnTarget
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204363"><span id="local-6989586621679204367"><span id="local-6989586621679204371"><span id="local-6989586621679204373"><span id="local-6989586621679204375"><span id="local-6989586621679204380"><span id="local-6989586621679204385"><span id="local-6989586621679204388"><span id="local-6989586621679204391"><span id="local-6989586621679204394"><span id="local-6989586621679204397"><span id="local-6989586621679204400"><span id="local-6989586621679204405"><span id="local-6989586621679204410"><span class="annot"><span class="annottext">Typeable AnnTarget
Typeable AnnTarget =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; AnnTarget -&gt; c AnnTarget)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c AnnTarget)
-&gt; (AnnTarget -&gt; Constr)
-&gt; (AnnTarget -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c AnnTarget))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c AnnTarget))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; AnnTarget -&gt; AnnTarget)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnTarget -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnTarget -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; AnnTarget -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; AnnTarget -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget)
-&gt; Data AnnTarget
AnnTarget -&gt; Constr
AnnTarget -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; AnnTarget -&gt; AnnTarget
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; AnnTarget -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; AnnTarget -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnTarget -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnTarget -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c AnnTarget
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; AnnTarget -&gt; c AnnTarget
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c AnnTarget)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c AnnTarget)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; AnnTarget -&gt; c AnnTarget
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; AnnTarget -&gt; c AnnTarget
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c AnnTarget
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c AnnTarget
$ctoConstr :: AnnTarget -&gt; Constr
toConstr :: AnnTarget -&gt; Constr
$cdataTypeOf :: AnnTarget -&gt; DataType
dataTypeOf :: AnnTarget -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c AnnTarget)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c AnnTarget)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c AnnTarget)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c AnnTarget)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; AnnTarget -&gt; AnnTarget
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; AnnTarget -&gt; AnnTarget
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnTarget -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnTarget -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnTarget -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnTarget -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; AnnTarget -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; AnnTarget -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; AnnTarget -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; AnnTarget -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnTarget -&gt; m AnnTarget
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204415"><span id="local-6989586621679204417"><span class="annot"><span class="annottext">(forall x. AnnTarget -&gt; Rep AnnTarget x)
-&gt; (forall x. Rep AnnTarget x -&gt; AnnTarget) -&gt; Generic AnnTarget
forall x. Rep AnnTarget x -&gt; AnnTarget
forall x. AnnTarget -&gt; Rep AnnTarget x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. AnnTarget -&gt; Rep AnnTarget x
from :: forall x. AnnTarget -&gt; Rep AnnTarget x
$cto :: forall x. Rep AnnTarget x -&gt; AnnTarget
to :: forall x. Rep AnnTarget x -&gt; AnnTarget
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2678"></span><span>
</span><span id="line-2679"></span><span class="hs-keyword">type</span><span> </span><span id="Cxt"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-var">Cxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pred"><span class="hs-identifier hs-type">Pred</span></a></span><span class="hs-special">]</span><span>                 </span><span class="annot"><span class="hs-comment">-- ^ @(Eq a, Ord b)@</span></span><span>
</span><span id="line-2680"></span><span>
</span><span id="line-2681"></span><span class="hs-comment">-- | Since the advent of @ConstraintKinds@, constraints are really just types.</span><span>
</span><span id="line-2682"></span><span class="hs-comment">-- Equality constraints use the 'EqualityT' constructor. Constraints may also</span><span>
</span><span id="line-2683"></span><span class="hs-comment">-- be tuples of other constraints.</span><span>
</span><span id="line-2684"></span><span class="hs-keyword">type</span><span> </span><span id="Pred"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Pred"><span class="hs-identifier hs-var">Pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2685"></span><span>
</span><span id="line-2686"></span><span class="hs-comment">-- | 'SourceUnpackedness' corresponds to unpack annotations found in the source code.</span><span>
</span><span id="line-2687"></span><span class="hs-comment">--</span><span>
</span><span id="line-2688"></span><span class="hs-comment">-- This may not agree with the annotations returned by 'reifyConStrictness'.</span><span>
</span><span id="line-2689"></span><span class="hs-comment">-- See 'reifyConStrictness' for more information.</span><span>
</span><span id="line-2690"></span><span class="hs-keyword">data</span><span> </span><span id="SourceUnpackedness"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SourceUnpackedness"><span class="hs-identifier hs-var">SourceUnpackedness</span></a></span></span><span>
</span><span id="line-2691"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NoSourceUnpackedness"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NoSourceUnpackedness"><span class="hs-identifier hs-var">NoSourceUnpackedness</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @C a@</span></span><span>
</span><span id="line-2692"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SourceNoUnpack"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SourceNoUnpack"><span class="hs-identifier hs-var">SourceNoUnpack</span></a></span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @C { {\-\# NOUNPACK \#-\} } a@</span></span><span>
</span><span id="line-2693"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SourceUnpack"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SourceUnpack"><span class="hs-identifier hs-var">SourceUnpack</span></a></span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ @C { {\-\# UNPACK \#-\} } a@</span></span><span>
</span><span id="line-2694"></span><span>        </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204424"><span id="local-6989586621679204426"><span id="local-6989586621679204430"><span class="annot"><span class="annottext">Int -&gt; SourceUnpackedness -&gt; FilePath -&gt; FilePath
[SourceUnpackedness] -&gt; FilePath -&gt; FilePath
SourceUnpackedness -&gt; FilePath
(Int -&gt; SourceUnpackedness -&gt; FilePath -&gt; FilePath)
-&gt; (SourceUnpackedness -&gt; FilePath)
-&gt; ([SourceUnpackedness] -&gt; FilePath -&gt; FilePath)
-&gt; Show SourceUnpackedness
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; SourceUnpackedness -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; SourceUnpackedness -&gt; FilePath -&gt; FilePath
$cshow :: SourceUnpackedness -&gt; FilePath
show :: SourceUnpackedness -&gt; FilePath
$cshowList :: [SourceUnpackedness] -&gt; FilePath -&gt; FilePath
showList :: [SourceUnpackedness] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204433"><span id="local-6989586621679204437"><span class="annot"><span class="annottext">SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
(SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool)
-&gt; (SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool)
-&gt; Eq SourceUnpackedness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
== :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
$c/= :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
/= :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204443"><span id="local-6989586621679204447"><span id="local-6989586621679204451"><span id="local-6989586621679204455"><span id="local-6989586621679204458"><span id="local-6989586621679204461"><span id="local-6989586621679204464"><span class="annot"><span class="annottext">Eq SourceUnpackedness
Eq SourceUnpackedness =&gt;
(SourceUnpackedness -&gt; SourceUnpackedness -&gt; Ordering)
-&gt; (SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool)
-&gt; (SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool)
-&gt; (SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool)
-&gt; (SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool)
-&gt; (SourceUnpackedness -&gt; SourceUnpackedness -&gt; SourceUnpackedness)
-&gt; (SourceUnpackedness -&gt; SourceUnpackedness -&gt; SourceUnpackedness)
-&gt; Ord SourceUnpackedness
SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
SourceUnpackedness -&gt; SourceUnpackedness -&gt; Ordering
SourceUnpackedness -&gt; SourceUnpackedness -&gt; SourceUnpackedness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Ordering
compare :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Ordering
$c&lt; :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
&lt; :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
$c&lt;= :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
&lt;= :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
$c&gt; :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
&gt; :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
$c&gt;= :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
&gt;= :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; Bool
$cmax :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; SourceUnpackedness
max :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; SourceUnpackedness
$cmin :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; SourceUnpackedness
min :: SourceUnpackedness -&gt; SourceUnpackedness -&gt; SourceUnpackedness
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204469"><span id="local-6989586621679204471"><span id="local-6989586621679204473"><span id="local-6989586621679204475"><span id="local-6989586621679204477"><span id="local-6989586621679204483"><span id="local-6989586621679204488"><span id="local-6989586621679204491"><span id="local-6989586621679204494"><span id="local-6989586621679204497"><span id="local-6989586621679204500"><span id="local-6989586621679204503"><span id="local-6989586621679204508"><span id="local-6989586621679204513"><span class="annot"><span class="annottext">Typeable SourceUnpackedness
Typeable SourceUnpackedness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; SourceUnpackedness
 -&gt; c SourceUnpackedness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SourceUnpackedness)
-&gt; (SourceUnpackedness -&gt; Constr)
-&gt; (SourceUnpackedness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SourceUnpackedness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c SourceUnpackedness))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; SourceUnpackedness -&gt; SourceUnpackedness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceUnpackedness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceUnpackedness -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; SourceUnpackedness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SourceUnpackedness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SourceUnpackedness -&gt; m SourceUnpackedness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SourceUnpackedness -&gt; m SourceUnpackedness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SourceUnpackedness -&gt; m SourceUnpackedness)
-&gt; Data SourceUnpackedness
SourceUnpackedness -&gt; Constr
SourceUnpackedness -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; SourceUnpackedness -&gt; SourceUnpackedness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SourceUnpackedness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SourceUnpackedness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceUnpackedness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceUnpackedness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceUnpackedness -&gt; m SourceUnpackedness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceUnpackedness -&gt; m SourceUnpackedness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SourceUnpackedness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; SourceUnpackedness
-&gt; c SourceUnpackedness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SourceUnpackedness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SourceUnpackedness)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; SourceUnpackedness
-&gt; c SourceUnpackedness
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; SourceUnpackedness
-&gt; c SourceUnpackedness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SourceUnpackedness
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SourceUnpackedness
$ctoConstr :: SourceUnpackedness -&gt; Constr
toConstr :: SourceUnpackedness -&gt; Constr
$cdataTypeOf :: SourceUnpackedness -&gt; DataType
dataTypeOf :: SourceUnpackedness -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SourceUnpackedness)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SourceUnpackedness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SourceUnpackedness)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SourceUnpackedness)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; SourceUnpackedness -&gt; SourceUnpackedness
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; SourceUnpackedness -&gt; SourceUnpackedness
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceUnpackedness -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceUnpackedness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceUnpackedness -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceUnpackedness -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SourceUnpackedness -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SourceUnpackedness -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SourceUnpackedness -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SourceUnpackedness -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceUnpackedness -&gt; m SourceUnpackedness
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceUnpackedness -&gt; m SourceUnpackedness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceUnpackedness -&gt; m SourceUnpackedness
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceUnpackedness -&gt; m SourceUnpackedness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceUnpackedness -&gt; m SourceUnpackedness
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceUnpackedness -&gt; m SourceUnpackedness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204518"><span id="local-6989586621679204520"><span class="annot"><span class="annottext">(forall x. SourceUnpackedness -&gt; Rep SourceUnpackedness x)
-&gt; (forall x. Rep SourceUnpackedness x -&gt; SourceUnpackedness)
-&gt; Generic SourceUnpackedness
forall x. Rep SourceUnpackedness x -&gt; SourceUnpackedness
forall x. SourceUnpackedness -&gt; Rep SourceUnpackedness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. SourceUnpackedness -&gt; Rep SourceUnpackedness x
from :: forall x. SourceUnpackedness -&gt; Rep SourceUnpackedness x
$cto :: forall x. Rep SourceUnpackedness x -&gt; SourceUnpackedness
to :: forall x. Rep SourceUnpackedness x -&gt; SourceUnpackedness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2695"></span><span>
</span><span id="line-2696"></span><span class="hs-comment">-- | 'SourceStrictness' corresponds to strictness annotations found in the source code.</span><span>
</span><span id="line-2697"></span><span class="hs-comment">--</span><span>
</span><span id="line-2698"></span><span class="hs-comment">-- This may not agree with the annotations returned by 'reifyConStrictness'.</span><span>
</span><span id="line-2699"></span><span class="hs-comment">-- See 'reifyConStrictness' for more information.</span><span>
</span><span id="line-2700"></span><span class="hs-keyword">data</span><span> </span><span id="SourceStrictness"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SourceStrictness"><span class="hs-identifier hs-var">SourceStrictness</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="NoSourceStrictness"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NoSourceStrictness"><span class="hs-identifier hs-var">NoSourceStrictness</span></a></span></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @C a@</span></span><span>
</span><span id="line-2701"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span id="SourceLazy"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SourceLazy"><span class="hs-identifier hs-var">SourceLazy</span></a></span></span><span>            </span><span class="annot"><span class="hs-comment">-- ^ @C {~}a@</span></span><span>
</span><span id="line-2702"></span><span>                      </span><span class="hs-glyph">|</span><span> </span><span id="SourceStrict"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SourceStrict"><span class="hs-identifier hs-var">SourceStrict</span></a></span></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ @C {!}a@</span></span><span>
</span><span id="line-2703"></span><span>        </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204526"><span id="local-6989586621679204528"><span id="local-6989586621679204532"><span class="annot"><span class="annottext">Int -&gt; SourceStrictness -&gt; FilePath -&gt; FilePath
[SourceStrictness] -&gt; FilePath -&gt; FilePath
SourceStrictness -&gt; FilePath
(Int -&gt; SourceStrictness -&gt; FilePath -&gt; FilePath)
-&gt; (SourceStrictness -&gt; FilePath)
-&gt; ([SourceStrictness] -&gt; FilePath -&gt; FilePath)
-&gt; Show SourceStrictness
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; SourceStrictness -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; SourceStrictness -&gt; FilePath -&gt; FilePath
$cshow :: SourceStrictness -&gt; FilePath
show :: SourceStrictness -&gt; FilePath
$cshowList :: [SourceStrictness] -&gt; FilePath -&gt; FilePath
showList :: [SourceStrictness] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204535"><span id="local-6989586621679204539"><span class="annot"><span class="annottext">SourceStrictness -&gt; SourceStrictness -&gt; Bool
(SourceStrictness -&gt; SourceStrictness -&gt; Bool)
-&gt; (SourceStrictness -&gt; SourceStrictness -&gt; Bool)
-&gt; Eq SourceStrictness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
== :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
$c/= :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
/= :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204545"><span id="local-6989586621679204549"><span id="local-6989586621679204553"><span id="local-6989586621679204557"><span id="local-6989586621679204560"><span id="local-6989586621679204563"><span id="local-6989586621679204566"><span class="annot"><span class="annottext">Eq SourceStrictness
Eq SourceStrictness =&gt;
(SourceStrictness -&gt; SourceStrictness -&gt; Ordering)
-&gt; (SourceStrictness -&gt; SourceStrictness -&gt; Bool)
-&gt; (SourceStrictness -&gt; SourceStrictness -&gt; Bool)
-&gt; (SourceStrictness -&gt; SourceStrictness -&gt; Bool)
-&gt; (SourceStrictness -&gt; SourceStrictness -&gt; Bool)
-&gt; (SourceStrictness -&gt; SourceStrictness -&gt; SourceStrictness)
-&gt; (SourceStrictness -&gt; SourceStrictness -&gt; SourceStrictness)
-&gt; Ord SourceStrictness
SourceStrictness -&gt; SourceStrictness -&gt; Bool
SourceStrictness -&gt; SourceStrictness -&gt; Ordering
SourceStrictness -&gt; SourceStrictness -&gt; SourceStrictness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: SourceStrictness -&gt; SourceStrictness -&gt; Ordering
compare :: SourceStrictness -&gt; SourceStrictness -&gt; Ordering
$c&lt; :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
&lt; :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
$c&lt;= :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
&lt;= :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
$c&gt; :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
&gt; :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
$c&gt;= :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
&gt;= :: SourceStrictness -&gt; SourceStrictness -&gt; Bool
$cmax :: SourceStrictness -&gt; SourceStrictness -&gt; SourceStrictness
max :: SourceStrictness -&gt; SourceStrictness -&gt; SourceStrictness
$cmin :: SourceStrictness -&gt; SourceStrictness -&gt; SourceStrictness
min :: SourceStrictness -&gt; SourceStrictness -&gt; SourceStrictness
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204571"><span id="local-6989586621679204573"><span id="local-6989586621679204575"><span id="local-6989586621679204577"><span id="local-6989586621679204579"><span id="local-6989586621679204585"><span id="local-6989586621679204590"><span id="local-6989586621679204593"><span id="local-6989586621679204596"><span id="local-6989586621679204599"><span id="local-6989586621679204602"><span id="local-6989586621679204605"><span id="local-6989586621679204610"><span id="local-6989586621679204615"><span class="annot"><span class="annottext">Typeable SourceStrictness
Typeable SourceStrictness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; SourceStrictness -&gt; c SourceStrictness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SourceStrictness)
-&gt; (SourceStrictness -&gt; Constr)
-&gt; (SourceStrictness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SourceStrictness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c SourceStrictness))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; SourceStrictness -&gt; SourceStrictness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceStrictness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceStrictness -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; SourceStrictness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SourceStrictness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SourceStrictness -&gt; m SourceStrictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SourceStrictness -&gt; m SourceStrictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; SourceStrictness -&gt; m SourceStrictness)
-&gt; Data SourceStrictness
SourceStrictness -&gt; Constr
SourceStrictness -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; SourceStrictness -&gt; SourceStrictness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SourceStrictness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SourceStrictness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceStrictness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceStrictness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceStrictness -&gt; m SourceStrictness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceStrictness -&gt; m SourceStrictness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SourceStrictness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SourceStrictness -&gt; c SourceStrictness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SourceStrictness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SourceStrictness)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SourceStrictness -&gt; c SourceStrictness
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SourceStrictness -&gt; c SourceStrictness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SourceStrictness
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SourceStrictness
$ctoConstr :: SourceStrictness -&gt; Constr
toConstr :: SourceStrictness -&gt; Constr
$cdataTypeOf :: SourceStrictness -&gt; DataType
dataTypeOf :: SourceStrictness -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SourceStrictness)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SourceStrictness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SourceStrictness)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SourceStrictness)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; SourceStrictness -&gt; SourceStrictness
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; SourceStrictness -&gt; SourceStrictness
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceStrictness -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceStrictness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceStrictness -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SourceStrictness -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SourceStrictness -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SourceStrictness -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SourceStrictness -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SourceStrictness -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceStrictness -&gt; m SourceStrictness
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceStrictness -&gt; m SourceStrictness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceStrictness -&gt; m SourceStrictness
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceStrictness -&gt; m SourceStrictness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceStrictness -&gt; m SourceStrictness
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SourceStrictness -&gt; m SourceStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204620"><span id="local-6989586621679204622"><span class="annot"><span class="annottext">(forall x. SourceStrictness -&gt; Rep SourceStrictness x)
-&gt; (forall x. Rep SourceStrictness x -&gt; SourceStrictness)
-&gt; Generic SourceStrictness
forall x. Rep SourceStrictness x -&gt; SourceStrictness
forall x. SourceStrictness -&gt; Rep SourceStrictness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. SourceStrictness -&gt; Rep SourceStrictness x
from :: forall x. SourceStrictness -&gt; Rep SourceStrictness x
$cto :: forall x. Rep SourceStrictness x -&gt; SourceStrictness
to :: forall x. Rep SourceStrictness x -&gt; SourceStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2704"></span><span>
</span><span id="line-2705"></span><span class="hs-comment">-- | Unlike 'SourceStrictness' and 'SourceUnpackedness', 'DecidedStrictness'</span><span>
</span><span id="line-2706"></span><span class="hs-comment">-- refers to the strictness annotations that the compiler chooses for a data constructor</span><span>
</span><span id="line-2707"></span><span class="hs-comment">-- field, which may be different from what is written in source code.</span><span>
</span><span id="line-2708"></span><span class="hs-comment">--</span><span>
</span><span id="line-2709"></span><span class="hs-comment">-- Note that non-unpacked strict fields are assigned 'DecidedLazy' when a bang would be inappropriate,</span><span>
</span><span id="line-2710"></span><span class="hs-comment">-- such as the field of a newtype constructor and fields that have an unlifted type.</span><span>
</span><span id="line-2711"></span><span class="hs-comment">--</span><span>
</span><span id="line-2712"></span><span class="hs-comment">-- See 'reifyConStrictness' for more information.</span><span>
</span><span id="line-2713"></span><span class="hs-keyword">data</span><span> </span><span id="DecidedStrictness"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DecidedStrictness"><span class="hs-identifier hs-var">DecidedStrictness</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DecidedLazy"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DecidedLazy"><span class="hs-identifier hs-var">DecidedLazy</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Field inferred to not have a bang.</span></span><span>
</span><span id="line-2714"></span><span>                       </span><span class="hs-glyph">|</span><span> </span><span id="DecidedStrict"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DecidedStrict"><span class="hs-identifier hs-var">DecidedStrict</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Field inferred to have a bang.</span></span><span>
</span><span id="line-2715"></span><span>                       </span><span class="hs-glyph">|</span><span> </span><span id="DecidedUnpack"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DecidedUnpack"><span class="hs-identifier hs-var">DecidedUnpack</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ Field inferred to be unpacked.</span></span><span>
</span><span id="line-2716"></span><span>        </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204626"><span id="local-6989586621679204628"><span id="local-6989586621679204632"><span class="annot"><span class="annottext">Int -&gt; DecidedStrictness -&gt; FilePath -&gt; FilePath
[DecidedStrictness] -&gt; FilePath -&gt; FilePath
DecidedStrictness -&gt; FilePath
(Int -&gt; DecidedStrictness -&gt; FilePath -&gt; FilePath)
-&gt; (DecidedStrictness -&gt; FilePath)
-&gt; ([DecidedStrictness] -&gt; FilePath -&gt; FilePath)
-&gt; Show DecidedStrictness
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; DecidedStrictness -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; DecidedStrictness -&gt; FilePath -&gt; FilePath
$cshow :: DecidedStrictness -&gt; FilePath
show :: DecidedStrictness -&gt; FilePath
$cshowList :: [DecidedStrictness] -&gt; FilePath -&gt; FilePath
showList :: [DecidedStrictness] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204635"><span id="local-6989586621679204639"><span class="annot"><span class="annottext">DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
(DecidedStrictness -&gt; DecidedStrictness -&gt; Bool)
-&gt; (DecidedStrictness -&gt; DecidedStrictness -&gt; Bool)
-&gt; Eq DecidedStrictness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
== :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
$c/= :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
/= :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204645"><span id="local-6989586621679204649"><span id="local-6989586621679204653"><span id="local-6989586621679204657"><span id="local-6989586621679204660"><span id="local-6989586621679204663"><span id="local-6989586621679204666"><span class="annot"><span class="annottext">Eq DecidedStrictness
Eq DecidedStrictness =&gt;
(DecidedStrictness -&gt; DecidedStrictness -&gt; Ordering)
-&gt; (DecidedStrictness -&gt; DecidedStrictness -&gt; Bool)
-&gt; (DecidedStrictness -&gt; DecidedStrictness -&gt; Bool)
-&gt; (DecidedStrictness -&gt; DecidedStrictness -&gt; Bool)
-&gt; (DecidedStrictness -&gt; DecidedStrictness -&gt; Bool)
-&gt; (DecidedStrictness -&gt; DecidedStrictness -&gt; DecidedStrictness)
-&gt; (DecidedStrictness -&gt; DecidedStrictness -&gt; DecidedStrictness)
-&gt; Ord DecidedStrictness
DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
DecidedStrictness -&gt; DecidedStrictness -&gt; Ordering
DecidedStrictness -&gt; DecidedStrictness -&gt; DecidedStrictness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: DecidedStrictness -&gt; DecidedStrictness -&gt; Ordering
compare :: DecidedStrictness -&gt; DecidedStrictness -&gt; Ordering
$c&lt; :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
&lt; :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
$c&lt;= :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
&lt;= :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
$c&gt; :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
&gt; :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
$c&gt;= :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
&gt;= :: DecidedStrictness -&gt; DecidedStrictness -&gt; Bool
$cmax :: DecidedStrictness -&gt; DecidedStrictness -&gt; DecidedStrictness
max :: DecidedStrictness -&gt; DecidedStrictness -&gt; DecidedStrictness
$cmin :: DecidedStrictness -&gt; DecidedStrictness -&gt; DecidedStrictness
min :: DecidedStrictness -&gt; DecidedStrictness -&gt; DecidedStrictness
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204671"><span id="local-6989586621679204673"><span id="local-6989586621679204675"><span id="local-6989586621679204677"><span id="local-6989586621679204679"><span id="local-6989586621679204685"><span id="local-6989586621679204690"><span id="local-6989586621679204693"><span id="local-6989586621679204696"><span id="local-6989586621679204699"><span id="local-6989586621679204702"><span id="local-6989586621679204705"><span id="local-6989586621679204710"><span id="local-6989586621679204715"><span class="annot"><span class="annottext">Typeable DecidedStrictness
Typeable DecidedStrictness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; DecidedStrictness
 -&gt; c DecidedStrictness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DecidedStrictness)
-&gt; (DecidedStrictness -&gt; Constr)
-&gt; (DecidedStrictness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DecidedStrictness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DecidedStrictness))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; DecidedStrictness -&gt; DecidedStrictness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DecidedStrictness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DecidedStrictness -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; DecidedStrictness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DecidedStrictness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DecidedStrictness -&gt; m DecidedStrictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DecidedStrictness -&gt; m DecidedStrictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DecidedStrictness -&gt; m DecidedStrictness)
-&gt; Data DecidedStrictness
DecidedStrictness -&gt; Constr
DecidedStrictness -&gt; DataType
(forall b. Data b =&gt; b -&gt; b)
-&gt; DecidedStrictness -&gt; DecidedStrictness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DecidedStrictness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DecidedStrictness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DecidedStrictness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DecidedStrictness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DecidedStrictness -&gt; m DecidedStrictness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DecidedStrictness -&gt; m DecidedStrictness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DecidedStrictness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DecidedStrictness -&gt; c DecidedStrictness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DecidedStrictness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DecidedStrictness)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DecidedStrictness -&gt; c DecidedStrictness
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DecidedStrictness -&gt; c DecidedStrictness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DecidedStrictness
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DecidedStrictness
$ctoConstr :: DecidedStrictness -&gt; Constr
toConstr :: DecidedStrictness -&gt; Constr
$cdataTypeOf :: DecidedStrictness -&gt; DataType
dataTypeOf :: DecidedStrictness -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DecidedStrictness)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DecidedStrictness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DecidedStrictness)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DecidedStrictness)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; DecidedStrictness -&gt; DecidedStrictness
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; DecidedStrictness -&gt; DecidedStrictness
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DecidedStrictness -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DecidedStrictness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DecidedStrictness -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DecidedStrictness -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DecidedStrictness -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DecidedStrictness -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DecidedStrictness -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DecidedStrictness -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DecidedStrictness -&gt; m DecidedStrictness
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DecidedStrictness -&gt; m DecidedStrictness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DecidedStrictness -&gt; m DecidedStrictness
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DecidedStrictness -&gt; m DecidedStrictness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DecidedStrictness -&gt; m DecidedStrictness
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DecidedStrictness -&gt; m DecidedStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204720"><span id="local-6989586621679204722"><span class="annot"><span class="annottext">(forall x. DecidedStrictness -&gt; Rep DecidedStrictness x)
-&gt; (forall x. Rep DecidedStrictness x -&gt; DecidedStrictness)
-&gt; Generic DecidedStrictness
forall x. Rep DecidedStrictness x -&gt; DecidedStrictness
forall x. DecidedStrictness -&gt; Rep DecidedStrictness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. DecidedStrictness -&gt; Rep DecidedStrictness x
from :: forall x. DecidedStrictness -&gt; Rep DecidedStrictness x
$cto :: forall x. Rep DecidedStrictness x -&gt; DecidedStrictness
to :: forall x. Rep DecidedStrictness x -&gt; DecidedStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2717"></span><span>
</span><span id="line-2718"></span><span class="hs-comment">-- | A data constructor.</span><span>
</span><span id="line-2719"></span><span class="hs-comment">--</span><span>
</span><span id="line-2720"></span><span class="hs-comment">-- The constructors for 'Con' can roughly be divided up into two categories:</span><span>
</span><span id="line-2721"></span><span class="hs-comment">-- those for constructors with \&quot;vanilla\&quot; syntax ('NormalC', 'RecC', and</span><span>
</span><span id="line-2722"></span><span class="hs-comment">-- 'InfixC'), and those for constructors with GADT syntax ('GadtC' and</span><span>
</span><span id="line-2723"></span><span class="hs-comment">-- 'RecGadtC'). The 'ForallC' constructor, which quantifies additional type</span><span>
</span><span id="line-2724"></span><span class="hs-comment">-- variables and class contexts, can surround either variety of constructor.</span><span>
</span><span id="line-2725"></span><span class="hs-comment">-- However, the type variables that it quantifies are different depending</span><span>
</span><span id="line-2726"></span><span class="hs-comment">-- on what constructor syntax is used:</span><span>
</span><span id="line-2727"></span><span class="hs-comment">--</span><span>
</span><span id="line-2728"></span><span class="hs-comment">-- * If a 'ForallC' surrounds a constructor with vanilla syntax, then the</span><span>
</span><span id="line-2729"></span><span class="hs-comment">--   'ForallC' will only quantify /existential/ type variables. For example:</span><span>
</span><span id="line-2730"></span><span class="hs-comment">--</span><span>
</span><span id="line-2731"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-2732"></span><span class="hs-comment">--   data Foo a = forall b. MkFoo a b</span><span>
</span><span id="line-2733"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-2734"></span><span class="hs-comment">--</span><span>
</span><span id="line-2735"></span><span class="hs-comment">--   In @MkFoo@, 'ForallC' will quantify @b@, but not @a@.</span><span>
</span><span id="line-2736"></span><span class="hs-comment">--</span><span>
</span><span id="line-2737"></span><span class="hs-comment">-- * If a 'ForallC' surrounds a constructor with GADT syntax, then the</span><span>
</span><span id="line-2738"></span><span class="hs-comment">--   'ForallC' will quantify /all/ type variables used in the constructor.</span><span>
</span><span id="line-2739"></span><span class="hs-comment">--   For example:</span><span>
</span><span id="line-2740"></span><span class="hs-comment">--</span><span>
</span><span id="line-2741"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-2742"></span><span class="hs-comment">--   data Bar a b where</span><span>
</span><span id="line-2743"></span><span class="hs-comment">--     MkBar :: (a ~ b) =&gt; c -&gt; MkBar a b</span><span>
</span><span id="line-2744"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-2745"></span><span class="hs-comment">--</span><span>
</span><span id="line-2746"></span><span class="hs-comment">--   In @MkBar@, 'ForallC' will quantify @a@, @b@, and @c@.</span><span>
</span><span id="line-2747"></span><span class="hs-comment">--</span><span>
</span><span id="line-2748"></span><span class="hs-comment">-- Multiplicity annotations for data types are currently not supported</span><span>
</span><span id="line-2749"></span><span class="hs-comment">-- in Template Haskell (i.e. all fields represented by Template Haskell</span><span>
</span><span id="line-2750"></span><span class="hs-comment">-- will be linear).</span><span>
</span><span id="line-2751"></span><span class="hs-keyword">data</span><span> </span><span id="Con"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Con"><span class="hs-identifier hs-var">Con</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2752"></span><span>  </span><span class="annot"><span class="hs-comment">-- | @C Int a@</span></span><span>
</span><span id="line-2753"></span><span>    </span><span id="NormalC"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NormalC"><span class="hs-identifier hs-var">NormalC</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BangType"><span class="hs-identifier hs-type">BangType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2754"></span><span>
</span><span id="line-2755"></span><span>  </span><span class="annot"><span class="hs-comment">-- | @C { v :: Int, w :: a }@</span></span><span>
</span><span id="line-2756"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecC"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecC"><span class="hs-identifier hs-var">RecC</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarBangType"><span class="hs-identifier hs-type">VarBangType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2757"></span><span>
</span><span id="line-2758"></span><span>  </span><span class="annot"><span class="hs-comment">-- | @Int :+ a@</span></span><span>
</span><span id="line-2759"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InfixC"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixC"><span class="hs-identifier hs-var">InfixC</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BangType"><span class="hs-identifier hs-type">BangType</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BangType"><span class="hs-identifier hs-type">BangType</span></a></span><span>
</span><span id="line-2760"></span><span>
</span><span id="line-2761"></span><span>  </span><span class="annot"><span class="hs-comment">-- | @forall a. Eq a =&gt; C [a]@</span></span><span>
</span><span id="line-2762"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ForallC"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ForallC"><span class="hs-identifier hs-var">ForallC</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Specificity"><span class="hs-identifier hs-type">Specificity</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span>
</span><span id="line-2763"></span><span>
</span><span id="line-2764"></span><span>  </span><span class="hs-comment">-- @C :: a -&gt; b -&gt; T b Int@</span><span>
</span><span id="line-2765"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GadtC"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#GadtC"><span class="hs-identifier hs-var">GadtC</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2766"></span><span>            </span><span class="hs-comment">-- ^ The list of constructors, corresponding to the GADT constructor</span><span>
</span><span id="line-2767"></span><span>            </span><span class="hs-comment">-- syntax @C1, C2 :: a -&gt; T b@.</span><span>
</span><span id="line-2768"></span><span>            </span><span class="hs-comment">--</span><span>
</span><span id="line-2769"></span><span>            </span><span class="hs-comment">-- Invariant: the list must be non-empty.</span><span>
</span><span id="line-2770"></span><span>          </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BangType"><span class="hs-identifier hs-type">BangType</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ The constructor arguments</span></span><span>
</span><span id="line-2771"></span><span>          </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ See Note [GADT return type]</span></span><span>
</span><span id="line-2772"></span><span>
</span><span id="line-2773"></span><span>  </span><span class="annot"><span class="hs-comment">-- | @C :: { v :: Int } -&gt; T b Int@</span></span><span>
</span><span id="line-2774"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecGadtC"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecGadtC"><span class="hs-identifier hs-var">RecGadtC</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2775"></span><span>             </span><span class="hs-comment">-- ^ The list of constructors, corresponding to the GADT record</span><span>
</span><span id="line-2776"></span><span>             </span><span class="hs-comment">-- constructor syntax @C1, C2 :: { fld :: a } -&gt; T b@.</span><span>
</span><span id="line-2777"></span><span>             </span><span class="hs-comment">--</span><span>
</span><span id="line-2778"></span><span>             </span><span class="hs-comment">-- Invariant: the list must be non-empty.</span><span>
</span><span id="line-2779"></span><span>             </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarBangType"><span class="hs-identifier hs-type">VarBangType</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ The constructor arguments</span></span><span>
</span><span id="line-2780"></span><span>             </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ See Note [GADT return type]</span></span><span>
</span><span id="line-2781"></span><span>        </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204731"><span id="local-6989586621679204759"><span id="local-6989586621679204762"><span class="annot"><span class="annottext">Int -&gt; Con -&gt; FilePath -&gt; FilePath
[Con] -&gt; FilePath -&gt; FilePath
Con -&gt; FilePath
(Int -&gt; Con -&gt; FilePath -&gt; FilePath)
-&gt; (Con -&gt; FilePath) -&gt; ([Con] -&gt; FilePath -&gt; FilePath) -&gt; Show Con
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Con -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Con -&gt; FilePath -&gt; FilePath
$cshow :: Con -&gt; FilePath
show :: Con -&gt; FilePath
$cshowList :: [Con] -&gt; FilePath -&gt; FilePath
showList :: [Con] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204770"><span id="local-6989586621679204794"><span class="annot"><span class="annottext">Con -&gt; Con -&gt; Bool
(Con -&gt; Con -&gt; Bool) -&gt; (Con -&gt; Con -&gt; Bool) -&gt; Eq Con
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Con -&gt; Con -&gt; Bool
== :: Con -&gt; Con -&gt; Bool
$c/= :: Con -&gt; Con -&gt; Bool
/= :: Con -&gt; Con -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204804"><span id="local-6989586621679204828"><span id="local-6989586621679204831"><span id="local-6989586621679204834"><span id="local-6989586621679204837"><span id="local-6989586621679204840"><span id="local-6989586621679204843"><span class="annot"><span class="annottext">Eq Con
Eq Con =&gt;
(Con -&gt; Con -&gt; Ordering)
-&gt; (Con -&gt; Con -&gt; Bool)
-&gt; (Con -&gt; Con -&gt; Bool)
-&gt; (Con -&gt; Con -&gt; Bool)
-&gt; (Con -&gt; Con -&gt; Bool)
-&gt; (Con -&gt; Con -&gt; Con)
-&gt; (Con -&gt; Con -&gt; Con)
-&gt; Ord Con
Con -&gt; Con -&gt; Bool
Con -&gt; Con -&gt; Ordering
Con -&gt; Con -&gt; Con
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Con -&gt; Con -&gt; Ordering
compare :: Con -&gt; Con -&gt; Ordering
$c&lt; :: Con -&gt; Con -&gt; Bool
&lt; :: Con -&gt; Con -&gt; Bool
$c&lt;= :: Con -&gt; Con -&gt; Bool
&lt;= :: Con -&gt; Con -&gt; Bool
$c&gt; :: Con -&gt; Con -&gt; Bool
&gt; :: Con -&gt; Con -&gt; Bool
$c&gt;= :: Con -&gt; Con -&gt; Bool
&gt;= :: Con -&gt; Con -&gt; Bool
$cmax :: Con -&gt; Con -&gt; Con
max :: Con -&gt; Con -&gt; Con
$cmin :: Con -&gt; Con -&gt; Con
min :: Con -&gt; Con -&gt; Con
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204853"><span id="local-6989586621679204875"><span id="local-6989586621679204897"><span id="local-6989586621679204899"><span id="local-6989586621679204901"><span id="local-6989586621679204906"><span id="local-6989586621679204911"><span id="local-6989586621679204914"><span id="local-6989586621679204917"><span id="local-6989586621679204920"><span id="local-6989586621679204923"><span id="local-6989586621679204926"><span id="local-6989586621679204931"><span id="local-6989586621679204936"><span class="annot"><span class="annottext">Typeable Con
Typeable Con =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Con -&gt; c Con)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Con)
-&gt; (Con -&gt; Constr)
-&gt; (Con -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Con))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Con))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Con -&gt; Con)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Con -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Con -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Con -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Con -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con)
-&gt; Data Con
Con -&gt; Constr
Con -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Con -&gt; Con
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Con -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Con -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Con -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Con -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Con
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Con -&gt; c Con
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Con)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Con)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Con -&gt; c Con
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Con -&gt; c Con
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Con
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Con
$ctoConstr :: Con -&gt; Constr
toConstr :: Con -&gt; Constr
$cdataTypeOf :: Con -&gt; DataType
dataTypeOf :: Con -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Con)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Con)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Con)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Con)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Con -&gt; Con
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Con -&gt; Con
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Con -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Con -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Con -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Con -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Con -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Con -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Con -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Con -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Con -&gt; m Con
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204948"><span id="local-6989586621679204950"><span class="annot"><span class="annottext">(forall x. Con -&gt; Rep Con x)
-&gt; (forall x. Rep Con x -&gt; Con) -&gt; Generic Con
forall x. Rep Con x -&gt; Con
forall x. Con -&gt; Rep Con x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Con -&gt; Rep Con x
from :: forall x. Con -&gt; Rep Con x
$cto :: forall x. Rep Con x -&gt; Con
to :: forall x. Rep Con x -&gt; Con
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2782"></span><span>
</span><span id="line-2783"></span><span class="hs-comment">-- Note [GADT return type]</span><span>
</span><span id="line-2784"></span><span class="hs-comment">-- ~~~~~~~~~~~~~~~~~~~~~~~</span><span>
</span><span id="line-2785"></span><span class="hs-comment">-- The return type of a GADT constructor does not necessarily match the name of</span><span>
</span><span id="line-2786"></span><span class="hs-comment">-- the data type:</span><span>
</span><span id="line-2787"></span><span class="hs-comment">--</span><span>
</span><span id="line-2788"></span><span class="hs-comment">-- type S = T</span><span>
</span><span id="line-2789"></span><span class="hs-comment">--</span><span>
</span><span id="line-2790"></span><span class="hs-comment">-- data T a where</span><span>
</span><span id="line-2791"></span><span class="hs-comment">--     MkT :: S Int</span><span>
</span><span id="line-2792"></span><span class="hs-comment">--</span><span>
</span><span id="line-2793"></span><span class="hs-comment">--</span><span>
</span><span id="line-2794"></span><span class="hs-comment">-- type S a = T</span><span>
</span><span id="line-2795"></span><span class="hs-comment">--</span><span>
</span><span id="line-2796"></span><span class="hs-comment">-- data T a where</span><span>
</span><span id="line-2797"></span><span class="hs-comment">--     MkT :: S Char Int</span><span>
</span><span id="line-2798"></span><span class="hs-comment">--</span><span>
</span><span id="line-2799"></span><span class="hs-comment">--</span><span>
</span><span id="line-2800"></span><span class="hs-comment">-- type Id a = a</span><span>
</span><span id="line-2801"></span><span class="hs-comment">-- type S a = T</span><span>
</span><span id="line-2802"></span><span class="hs-comment">--</span><span>
</span><span id="line-2803"></span><span class="hs-comment">-- data T a where</span><span>
</span><span id="line-2804"></span><span class="hs-comment">--     MkT :: Id (S Char Int)</span><span>
</span><span id="line-2805"></span><span class="hs-comment">--</span><span>
</span><span id="line-2806"></span><span class="hs-comment">--</span><span>
</span><span id="line-2807"></span><span class="hs-comment">-- That is why we allow the return type stored by a constructor to be an</span><span>
</span><span id="line-2808"></span><span class="hs-comment">-- arbitrary type. See also #11341</span><span>
</span><span id="line-2809"></span><span>
</span><span id="line-2810"></span><span class="hs-keyword">data</span><span> </span><span id="Bang"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bang"><span class="hs-identifier hs-var">Bang</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Bang"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bang"><span class="hs-identifier hs-var">Bang</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SourceUnpackedness"><span class="hs-identifier hs-type">SourceUnpackedness</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SourceStrictness"><span class="hs-identifier hs-type">SourceStrictness</span></a></span><span>
</span><span id="line-2811"></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ @C { {\-\# UNPACK \#-\} !}a@</span></span><span>
</span><span id="line-2812"></span><span>        </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679204954"><span id="local-6989586621679204959"><span id="local-6989586621679204962"><span class="annot"><span class="annottext">Int -&gt; Bang -&gt; FilePath -&gt; FilePath
[Bang] -&gt; FilePath -&gt; FilePath
Bang -&gt; FilePath
(Int -&gt; Bang -&gt; FilePath -&gt; FilePath)
-&gt; (Bang -&gt; FilePath)
-&gt; ([Bang] -&gt; FilePath -&gt; FilePath)
-&gt; Show Bang
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Bang -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Bang -&gt; FilePath -&gt; FilePath
$cshow :: Bang -&gt; FilePath
show :: Bang -&gt; FilePath
$cshowList :: [Bang] -&gt; FilePath -&gt; FilePath
showList :: [Bang] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204965"><span id="local-6989586621679204969"><span class="annot"><span class="annottext">Bang -&gt; Bang -&gt; Bool
(Bang -&gt; Bang -&gt; Bool) -&gt; (Bang -&gt; Bang -&gt; Bool) -&gt; Eq Bang
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Bang -&gt; Bang -&gt; Bool
== :: Bang -&gt; Bang -&gt; Bool
$c/= :: Bang -&gt; Bang -&gt; Bool
/= :: Bang -&gt; Bang -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204974"><span id="local-6989586621679204978"><span id="local-6989586621679204982"><span id="local-6989586621679204985"><span id="local-6989586621679204988"><span id="local-6989586621679204991"><span id="local-6989586621679204994"><span class="annot"><span class="annottext">Eq Bang
Eq Bang =&gt;
(Bang -&gt; Bang -&gt; Ordering)
-&gt; (Bang -&gt; Bang -&gt; Bool)
-&gt; (Bang -&gt; Bang -&gt; Bool)
-&gt; (Bang -&gt; Bang -&gt; Bool)
-&gt; (Bang -&gt; Bang -&gt; Bool)
-&gt; (Bang -&gt; Bang -&gt; Bang)
-&gt; (Bang -&gt; Bang -&gt; Bang)
-&gt; Ord Bang
Bang -&gt; Bang -&gt; Bool
Bang -&gt; Bang -&gt; Ordering
Bang -&gt; Bang -&gt; Bang
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Bang -&gt; Bang -&gt; Ordering
compare :: Bang -&gt; Bang -&gt; Ordering
$c&lt; :: Bang -&gt; Bang -&gt; Bool
&lt; :: Bang -&gt; Bang -&gt; Bool
$c&lt;= :: Bang -&gt; Bang -&gt; Bool
&lt;= :: Bang -&gt; Bang -&gt; Bool
$c&gt; :: Bang -&gt; Bang -&gt; Bool
&gt; :: Bang -&gt; Bang -&gt; Bool
$c&gt;= :: Bang -&gt; Bang -&gt; Bool
&gt;= :: Bang -&gt; Bang -&gt; Bool
$cmax :: Bang -&gt; Bang -&gt; Bang
max :: Bang -&gt; Bang -&gt; Bang
$cmin :: Bang -&gt; Bang -&gt; Bang
min :: Bang -&gt; Bang -&gt; Bang
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679204999"><span id="local-6989586621679205003"><span id="local-6989586621679205007"><span id="local-6989586621679205009"><span id="local-6989586621679205011"><span id="local-6989586621679205016"><span id="local-6989586621679205021"><span id="local-6989586621679205024"><span id="local-6989586621679205027"><span id="local-6989586621679205030"><span id="local-6989586621679205033"><span id="local-6989586621679205036"><span id="local-6989586621679205041"><span id="local-6989586621679205046"><span class="annot"><span class="annottext">Typeable Bang
Typeable Bang =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Bang -&gt; c Bang)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Bang)
-&gt; (Bang -&gt; Constr)
-&gt; (Bang -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Bang))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Bang))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Bang -&gt; Bang)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bang -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bang -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bang -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bang -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang)
-&gt; Data Bang
Bang -&gt; Constr
Bang -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Bang -&gt; Bang
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bang -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bang -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bang -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bang -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Bang
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bang -&gt; c Bang
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Bang)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Bang)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bang -&gt; c Bang
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bang -&gt; c Bang
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Bang
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Bang
$ctoConstr :: Bang -&gt; Constr
toConstr :: Bang -&gt; Constr
$cdataTypeOf :: Bang -&gt; DataType
dataTypeOf :: Bang -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Bang)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Bang)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Bang)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Bang)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Bang -&gt; Bang
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Bang -&gt; Bang
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bang -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bang -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bang -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bang -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bang -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bang -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bang -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bang -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bang -&gt; m Bang
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205051"><span id="local-6989586621679205053"><span class="annot"><span class="annottext">(forall x. Bang -&gt; Rep Bang x)
-&gt; (forall x. Rep Bang x -&gt; Bang) -&gt; Generic Bang
forall x. Rep Bang x -&gt; Bang
forall x. Bang -&gt; Rep Bang x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Bang -&gt; Rep Bang x
from :: forall x. Bang -&gt; Rep Bang x
$cto :: forall x. Rep Bang x -&gt; Bang
to :: forall x. Rep Bang x -&gt; Bang
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-2813"></span><span>
</span><span id="line-2814"></span><span class="hs-keyword">type</span><span> </span><span id="BangType"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BangType"><span class="hs-identifier hs-var">BangType</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bang"><span class="hs-identifier hs-type">Bang</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2815"></span><span class="hs-keyword">type</span><span> </span><span id="VarBangType"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarBangType"><span class="hs-identifier hs-var">VarBangType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bang"><span class="hs-identifier hs-type">Bang</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2816"></span><span>
</span><span id="line-2817"></span><span class="annot"><span class="hs-comment">-- | As of @template-haskell-2.11.0.0@, 'Strict' has been replaced by 'Bang'.</span></span><span>
</span><span id="line-2818"></span><span class="hs-keyword">type</span><span> </span><span id="Strict"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Bang"><span class="hs-identifier hs-type">Bang</span></a></span><span>
</span><span id="line-2819"></span><span>
</span><span id="line-2820"></span><span class="hs-comment">-- | As of @template-haskell-2.11.0.0@, 'StrictType' has been replaced by</span><span>
</span><span id="line-2821"></span><span class="hs-comment">-- 'BangType'.</span><span>
</span><span id="line-2822"></span><span class="hs-keyword">type</span><span> </span><span id="StrictType"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StrictType"><span class="hs-identifier hs-var">StrictType</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BangType"><span class="hs-identifier hs-type">BangType</span></a></span><span>
</span><span id="line-2823"></span><span>
</span><span id="line-2824"></span><span class="hs-comment">-- | As of @template-haskell-2.11.0.0@, 'VarStrictType' has been replaced by</span><span>
</span><span id="line-2825"></span><span class="hs-comment">-- 'VarBangType'.</span><span>
</span><span id="line-2826"></span><span class="hs-keyword">type</span><span> </span><span id="VarStrictType"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarStrictType"><span class="hs-identifier hs-var">VarStrictType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarBangType"><span class="hs-identifier hs-type">VarBangType</span></a></span><span>
</span><span id="line-2827"></span><span>
</span><span id="line-2828"></span><span class="annot"><span class="hs-comment">-- | A pattern synonym's directionality.</span></span><span>
</span><span id="line-2829"></span><span class="hs-keyword">data</span><span> </span><span id="PatSynDir"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynDir"><span class="hs-identifier hs-var">PatSynDir</span></a></span></span><span>
</span><span id="line-2830"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Unidir"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Unidir"><span class="hs-identifier hs-var">Unidir</span></a></span></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ @pattern P x {&lt;-} p@</span></span><span>
</span><span id="line-2831"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ImplBidir"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ImplBidir"><span class="hs-identifier hs-var">ImplBidir</span></a></span></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ @pattern P x {=} p@</span></span><span>
</span><span id="line-2832"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplBidir"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ExplBidir"><span class="hs-identifier hs-var">ExplBidir</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Clause"><span class="hs-identifier hs-type">Clause</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ @pattern P x {&lt;-} p where P x = e@</span></span><span>
</span><span id="line-2833"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679205063"><span id="local-6989586621679205068"><span id="local-6989586621679205071"><span class="annot"><span class="annottext">Int -&gt; PatSynDir -&gt; FilePath -&gt; FilePath
[PatSynDir] -&gt; FilePath -&gt; FilePath
PatSynDir -&gt; FilePath
(Int -&gt; PatSynDir -&gt; FilePath -&gt; FilePath)
-&gt; (PatSynDir -&gt; FilePath)
-&gt; ([PatSynDir] -&gt; FilePath -&gt; FilePath)
-&gt; Show PatSynDir
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; PatSynDir -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; PatSynDir -&gt; FilePath -&gt; FilePath
$cshow :: PatSynDir -&gt; FilePath
show :: PatSynDir -&gt; FilePath
$cshowList :: [PatSynDir] -&gt; FilePath -&gt; FilePath
showList :: [PatSynDir] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205074"><span id="local-6989586621679205080"><span class="annot"><span class="annottext">PatSynDir -&gt; PatSynDir -&gt; Bool
(PatSynDir -&gt; PatSynDir -&gt; Bool)
-&gt; (PatSynDir -&gt; PatSynDir -&gt; Bool) -&gt; Eq PatSynDir
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: PatSynDir -&gt; PatSynDir -&gt; Bool
== :: PatSynDir -&gt; PatSynDir -&gt; Bool
$c/= :: PatSynDir -&gt; PatSynDir -&gt; Bool
/= :: PatSynDir -&gt; PatSynDir -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205085"><span id="local-6989586621679205089"><span id="local-6989586621679205093"><span id="local-6989586621679205096"><span id="local-6989586621679205099"><span id="local-6989586621679205102"><span id="local-6989586621679205105"><span class="annot"><span class="annottext">Eq PatSynDir
Eq PatSynDir =&gt;
(PatSynDir -&gt; PatSynDir -&gt; Ordering)
-&gt; (PatSynDir -&gt; PatSynDir -&gt; Bool)
-&gt; (PatSynDir -&gt; PatSynDir -&gt; Bool)
-&gt; (PatSynDir -&gt; PatSynDir -&gt; Bool)
-&gt; (PatSynDir -&gt; PatSynDir -&gt; Bool)
-&gt; (PatSynDir -&gt; PatSynDir -&gt; PatSynDir)
-&gt; (PatSynDir -&gt; PatSynDir -&gt; PatSynDir)
-&gt; Ord PatSynDir
PatSynDir -&gt; PatSynDir -&gt; Bool
PatSynDir -&gt; PatSynDir -&gt; Ordering
PatSynDir -&gt; PatSynDir -&gt; PatSynDir
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: PatSynDir -&gt; PatSynDir -&gt; Ordering
compare :: PatSynDir -&gt; PatSynDir -&gt; Ordering
$c&lt; :: PatSynDir -&gt; PatSynDir -&gt; Bool
&lt; :: PatSynDir -&gt; PatSynDir -&gt; Bool
$c&lt;= :: PatSynDir -&gt; PatSynDir -&gt; Bool
&lt;= :: PatSynDir -&gt; PatSynDir -&gt; Bool
$c&gt; :: PatSynDir -&gt; PatSynDir -&gt; Bool
&gt; :: PatSynDir -&gt; PatSynDir -&gt; Bool
$c&gt;= :: PatSynDir -&gt; PatSynDir -&gt; Bool
&gt;= :: PatSynDir -&gt; PatSynDir -&gt; Bool
$cmax :: PatSynDir -&gt; PatSynDir -&gt; PatSynDir
max :: PatSynDir -&gt; PatSynDir -&gt; PatSynDir
$cmin :: PatSynDir -&gt; PatSynDir -&gt; PatSynDir
min :: PatSynDir -&gt; PatSynDir -&gt; PatSynDir
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205110"><span id="local-6989586621679205114"><span id="local-6989586621679205118"><span id="local-6989586621679205120"><span id="local-6989586621679205122"><span id="local-6989586621679205127"><span id="local-6989586621679205132"><span id="local-6989586621679205135"><span id="local-6989586621679205138"><span id="local-6989586621679205141"><span id="local-6989586621679205144"><span id="local-6989586621679205147"><span id="local-6989586621679205152"><span id="local-6989586621679205157"><span class="annot"><span class="annottext">Typeable PatSynDir
Typeable PatSynDir =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; PatSynDir -&gt; c PatSynDir)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PatSynDir)
-&gt; (PatSynDir -&gt; Constr)
-&gt; (PatSynDir -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PatSynDir))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PatSynDir))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; PatSynDir -&gt; PatSynDir)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynDir -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynDir -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynDir -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynDir -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir)
-&gt; Data PatSynDir
PatSynDir -&gt; Constr
PatSynDir -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; PatSynDir -&gt; PatSynDir
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynDir -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynDir -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynDir -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynDir -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PatSynDir
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatSynDir -&gt; c PatSynDir
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PatSynDir)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PatSynDir)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatSynDir -&gt; c PatSynDir
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatSynDir -&gt; c PatSynDir
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PatSynDir
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PatSynDir
$ctoConstr :: PatSynDir -&gt; Constr
toConstr :: PatSynDir -&gt; Constr
$cdataTypeOf :: PatSynDir -&gt; DataType
dataTypeOf :: PatSynDir -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PatSynDir)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PatSynDir)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PatSynDir)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PatSynDir)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PatSynDir -&gt; PatSynDir
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PatSynDir -&gt; PatSynDir
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynDir -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynDir -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynDir -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynDir -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynDir -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynDir -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynDir -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynDir -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynDir -&gt; m PatSynDir
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205162"><span id="local-6989586621679205164"><span class="annot"><span class="annottext">(forall x. PatSynDir -&gt; Rep PatSynDir x)
-&gt; (forall x. Rep PatSynDir x -&gt; PatSynDir) -&gt; Generic PatSynDir
forall x. Rep PatSynDir x -&gt; PatSynDir
forall x. PatSynDir -&gt; Rep PatSynDir x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. PatSynDir -&gt; Rep PatSynDir x
from :: forall x. PatSynDir -&gt; Rep PatSynDir x
$cto :: forall x. Rep PatSynDir x -&gt; PatSynDir
to :: forall x. Rep PatSynDir x -&gt; PatSynDir
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2834"></span><span>
</span><span id="line-2835"></span><span class="annot"><span class="hs-comment">-- | A pattern synonym's argument type.</span></span><span>
</span><span id="line-2836"></span><span class="hs-keyword">data</span><span> </span><span id="PatSynArgs"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PatSynArgs"><span class="hs-identifier hs-var">PatSynArgs</span></a></span></span><span>
</span><span id="line-2837"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="PrefixPatSyn"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PrefixPatSyn"><span class="hs-identifier hs-var">PrefixPatSyn</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @pattern P {x y z} = p@</span></span><span>
</span><span id="line-2838"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InfixPatSyn"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixPatSyn"><span class="hs-identifier hs-var">InfixPatSyn</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ @pattern {x P y} = p@</span></span><span>
</span><span id="line-2839"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordPatSyn"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecordPatSyn"><span class="hs-identifier hs-var">RecordPatSyn</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @pattern P { {x,y,z} } = p@</span></span><span>
</span><span id="line-2840"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679205170"><span id="local-6989586621679205180"><span id="local-6989586621679205183"><span class="annot"><span class="annottext">Int -&gt; PatSynArgs -&gt; FilePath -&gt; FilePath
[PatSynArgs] -&gt; FilePath -&gt; FilePath
PatSynArgs -&gt; FilePath
(Int -&gt; PatSynArgs -&gt; FilePath -&gt; FilePath)
-&gt; (PatSynArgs -&gt; FilePath)
-&gt; ([PatSynArgs] -&gt; FilePath -&gt; FilePath)
-&gt; Show PatSynArgs
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; PatSynArgs -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; PatSynArgs -&gt; FilePath -&gt; FilePath
$cshow :: PatSynArgs -&gt; FilePath
show :: PatSynArgs -&gt; FilePath
$cshowList :: [PatSynArgs] -&gt; FilePath -&gt; FilePath
showList :: [PatSynArgs] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205186"><span id="local-6989586621679205195"><span class="annot"><span class="annottext">PatSynArgs -&gt; PatSynArgs -&gt; Bool
(PatSynArgs -&gt; PatSynArgs -&gt; Bool)
-&gt; (PatSynArgs -&gt; PatSynArgs -&gt; Bool) -&gt; Eq PatSynArgs
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
== :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
$c/= :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
/= :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205200"><span id="local-6989586621679205207"><span id="local-6989586621679205214"><span id="local-6989586621679205217"><span id="local-6989586621679205220"><span id="local-6989586621679205223"><span id="local-6989586621679205226"><span class="annot"><span class="annottext">Eq PatSynArgs
Eq PatSynArgs =&gt;
(PatSynArgs -&gt; PatSynArgs -&gt; Ordering)
-&gt; (PatSynArgs -&gt; PatSynArgs -&gt; Bool)
-&gt; (PatSynArgs -&gt; PatSynArgs -&gt; Bool)
-&gt; (PatSynArgs -&gt; PatSynArgs -&gt; Bool)
-&gt; (PatSynArgs -&gt; PatSynArgs -&gt; Bool)
-&gt; (PatSynArgs -&gt; PatSynArgs -&gt; PatSynArgs)
-&gt; (PatSynArgs -&gt; PatSynArgs -&gt; PatSynArgs)
-&gt; Ord PatSynArgs
PatSynArgs -&gt; PatSynArgs -&gt; Bool
PatSynArgs -&gt; PatSynArgs -&gt; Ordering
PatSynArgs -&gt; PatSynArgs -&gt; PatSynArgs
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: PatSynArgs -&gt; PatSynArgs -&gt; Ordering
compare :: PatSynArgs -&gt; PatSynArgs -&gt; Ordering
$c&lt; :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
&lt; :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
$c&lt;= :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
&lt;= :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
$c&gt; :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
&gt; :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
$c&gt;= :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
&gt;= :: PatSynArgs -&gt; PatSynArgs -&gt; Bool
$cmax :: PatSynArgs -&gt; PatSynArgs -&gt; PatSynArgs
max :: PatSynArgs -&gt; PatSynArgs -&gt; PatSynArgs
$cmin :: PatSynArgs -&gt; PatSynArgs -&gt; PatSynArgs
min :: PatSynArgs -&gt; PatSynArgs -&gt; PatSynArgs
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205231"><span id="local-6989586621679205238"><span id="local-6989586621679205245"><span id="local-6989586621679205247"><span id="local-6989586621679205249"><span id="local-6989586621679205254"><span id="local-6989586621679205259"><span id="local-6989586621679205262"><span id="local-6989586621679205265"><span id="local-6989586621679205268"><span id="local-6989586621679205271"><span id="local-6989586621679205274"><span id="local-6989586621679205279"><span id="local-6989586621679205284"><span class="annot"><span class="annottext">Typeable PatSynArgs
Typeable PatSynArgs =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; PatSynArgs -&gt; c PatSynArgs)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PatSynArgs)
-&gt; (PatSynArgs -&gt; Constr)
-&gt; (PatSynArgs -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PatSynArgs))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c PatSynArgs))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; PatSynArgs -&gt; PatSynArgs)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynArgs -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynArgs -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynArgs -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynArgs -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs)
-&gt; Data PatSynArgs
PatSynArgs -&gt; Constr
PatSynArgs -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; PatSynArgs -&gt; PatSynArgs
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynArgs -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynArgs -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynArgs -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynArgs -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PatSynArgs
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatSynArgs -&gt; c PatSynArgs
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PatSynArgs)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PatSynArgs)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatSynArgs -&gt; c PatSynArgs
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatSynArgs -&gt; c PatSynArgs
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PatSynArgs
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c PatSynArgs
$ctoConstr :: PatSynArgs -&gt; Constr
toConstr :: PatSynArgs -&gt; Constr
$cdataTypeOf :: PatSynArgs -&gt; DataType
dataTypeOf :: PatSynArgs -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PatSynArgs)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c PatSynArgs)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PatSynArgs)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c PatSynArgs)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PatSynArgs -&gt; PatSynArgs
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PatSynArgs -&gt; PatSynArgs
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynArgs -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynArgs -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynArgs -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatSynArgs -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynArgs -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynArgs -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynArgs -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatSynArgs -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatSynArgs -&gt; m PatSynArgs
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205289"><span id="local-6989586621679205291"><span class="annot"><span class="annottext">(forall x. PatSynArgs -&gt; Rep PatSynArgs x)
-&gt; (forall x. Rep PatSynArgs x -&gt; PatSynArgs) -&gt; Generic PatSynArgs
forall x. Rep PatSynArgs x -&gt; PatSynArgs
forall x. PatSynArgs -&gt; Rep PatSynArgs x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. PatSynArgs -&gt; Rep PatSynArgs x
from :: forall x. PatSynArgs -&gt; Rep PatSynArgs x
$cto :: forall x. Rep PatSynArgs x -&gt; PatSynArgs
to :: forall x. Rep PatSynArgs x -&gt; PatSynArgs
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2841"></span><span>
</span><span id="line-2842"></span><span class="hs-keyword">data</span><span> </span><span id="Type"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-var">Type</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ForallT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ForallT"><span class="hs-identifier hs-var">ForallT</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Specificity"><span class="hs-identifier hs-type">Specificity</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Cxt"><span class="hs-identifier hs-type">Cxt</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @forall \&lt;vars\&gt;. \&lt;ctxt\&gt; =&gt; \&lt;type\&gt;@</span></span><span>
</span><span id="line-2843"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="ForallVisT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ForallVisT"><span class="hs-identifier hs-var">ForallVisT</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @forall \&lt;vars\&gt; -&gt; \&lt;type\&gt;@</span></span><span>
</span><span id="line-2844"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="AppT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AppT"><span class="hs-identifier hs-var">AppT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                 </span><span class="annot"><span class="hs-comment">-- ^ @T a b@</span></span><span>
</span><span id="line-2845"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="AppKindT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AppKindT"><span class="hs-identifier hs-var">AppKindT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ @T \@k t@</span></span><span>
</span><span id="line-2846"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="SigT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SigT"><span class="hs-identifier hs-var">SigT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span>                 </span><span class="annot"><span class="hs-comment">-- ^ @t :: k@</span></span><span>
</span><span id="line-2847"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="VarT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#VarT"><span class="hs-identifier hs-var">VarT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @a@</span></span><span>
</span><span id="line-2848"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="ConT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ConT"><span class="hs-identifier hs-var">ConT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @T@</span></span><span>
</span><span id="line-2849"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="PromotedT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PromotedT"><span class="hs-identifier hs-var">PromotedT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>                 </span><span class="annot"><span class="hs-comment">-- ^ @'T@</span></span><span>
</span><span id="line-2850"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="InfixT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixT"><span class="hs-identifier hs-var">InfixT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ @T + T@</span></span><span>
</span><span id="line-2851"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="UInfixT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UInfixT"><span class="hs-identifier hs-var">UInfixT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>         </span><span class="hs-comment">-- ^ @T + T@</span><span>
</span><span id="line-2852"></span><span>                                           </span><span class="hs-comment">--</span><span>
</span><span id="line-2853"></span><span>                                           </span><span class="hs-comment">-- See &quot;Language.Haskell.TH.Syntax#infix&quot;</span><span>
</span><span id="line-2854"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="PromotedInfixT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PromotedInfixT"><span class="hs-identifier hs-var">PromotedInfixT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @T :+: T@</span></span><span>
</span><span id="line-2855"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="PromotedUInfixT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PromotedUInfixT"><span class="hs-identifier hs-var">PromotedUInfixT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-comment">-- ^ @T :+: T@</span><span>
</span><span id="line-2856"></span><span>                                           </span><span class="hs-comment">--</span><span>
</span><span id="line-2857"></span><span>                                           </span><span class="hs-comment">-- See &quot;Language.Haskell.TH.Syntax#infix&quot;</span><span>
</span><span id="line-2858"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="ParensT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ParensT"><span class="hs-identifier hs-var">ParensT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ @(T)@</span></span><span>
</span><span id="line-2859"></span><span>
</span><span id="line-2860"></span><span>          </span><span class="hs-comment">-- See Note [Representing concrete syntax in types]</span><span>
</span><span id="line-2861"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="TupleT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TupleT"><span class="hs-identifier hs-var">TupleT</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^ @(,)@, @(,,)@, etc.</span></span><span>
</span><span id="line-2862"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedTupleT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UnboxedTupleT"><span class="hs-identifier hs-var">UnboxedTupleT</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ @(\#,\#)@, @(\#,,\#)@, etc.</span></span><span>
</span><span id="line-2863"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedSumT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#UnboxedSumT"><span class="hs-identifier hs-var">UnboxedSumT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SumArity"><span class="hs-identifier hs-type">SumArity</span></a></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ @(\#|\#)@, @(\#||\#)@, etc.</span></span><span>
</span><span id="line-2864"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="ArrowT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ArrowT"><span class="hs-identifier hs-var">ArrowT</span></a></span></span><span>                         </span><span class="annot"><span class="hs-comment">-- ^ @-&gt;@</span></span><span>
</span><span id="line-2865"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="MulArrowT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#MulArrowT"><span class="hs-identifier hs-var">MulArrowT</span></a></span></span><span>                      </span><span class="hs-comment">-- ^ @%n -&gt;@</span><span>
</span><span id="line-2866"></span><span>                                           </span><span class="hs-comment">--</span><span>
</span><span id="line-2867"></span><span>                                           </span><span class="hs-comment">-- Generalised arrow type with multiplicity argument</span><span>
</span><span id="line-2868"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="EqualityT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#EqualityT"><span class="hs-identifier hs-var">EqualityT</span></a></span></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @~@</span></span><span>
</span><span id="line-2869"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="ListT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ListT"><span class="hs-identifier hs-var">ListT</span></a></span></span><span>                          </span><span class="annot"><span class="hs-comment">-- ^ @[]@</span></span><span>
</span><span id="line-2870"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="PromotedTupleT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PromotedTupleT"><span class="hs-identifier hs-var">PromotedTupleT</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ @'()@, @'(,)@, @'(,,)@, etc.</span></span><span>
</span><span id="line-2871"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="PromotedNilT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PromotedNilT"><span class="hs-identifier hs-var">PromotedNilT</span></a></span></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ @'[]@</span></span><span>
</span><span id="line-2872"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="PromotedConsT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PromotedConsT"><span class="hs-identifier hs-var">PromotedConsT</span></a></span></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^ @'(:)@</span></span><span>
</span><span id="line-2873"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="StarT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StarT"><span class="hs-identifier hs-var">StarT</span></a></span></span><span>                          </span><span class="annot"><span class="hs-comment">-- ^ @*@</span></span><span>
</span><span id="line-2874"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="ConstraintT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ConstraintT"><span class="hs-identifier hs-var">ConstraintT</span></a></span></span><span>                    </span><span class="annot"><span class="hs-comment">-- ^ @Constraint@</span></span><span>
</span><span id="line-2875"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="LitT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#LitT"><span class="hs-identifier hs-var">LitT</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyLit"><span class="hs-identifier hs-type">TyLit</span></a></span><span>                     </span><span class="annot"><span class="hs-comment">-- ^ @0@, @1@, @2@, etc.</span></span><span>
</span><span id="line-2876"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="WildCardT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#WildCardT"><span class="hs-identifier hs-var">WildCardT</span></a></span></span><span>                      </span><span class="annot"><span class="hs-comment">-- ^ @_@</span></span><span>
</span><span id="line-2877"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="ImplicitParamT"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ImplicitParamT"><span class="hs-identifier hs-var">ImplicitParamT</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>     </span><span class="annot"><span class="hs-comment">-- ^ @?x :: t@</span></span><span>
</span><span id="line-2878"></span><span>      </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679205310"><span id="local-6989586621679205370"><span id="local-6989586621679205373"><span class="annot"><span class="annottext">Int -&gt; Type -&gt; FilePath -&gt; FilePath
[Type] -&gt; FilePath -&gt; FilePath
Type -&gt; FilePath
(Int -&gt; Type -&gt; FilePath -&gt; FilePath)
-&gt; (Type -&gt; FilePath)
-&gt; ([Type] -&gt; FilePath -&gt; FilePath)
-&gt; Show Type
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Type -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Type -&gt; FilePath -&gt; FilePath
$cshow :: Type -&gt; FilePath
show :: Type -&gt; FilePath
$cshowList :: [Type] -&gt; FilePath -&gt; FilePath
showList :: [Type] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205378"><span id="local-6989586621679205421"><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Bool
(Type -&gt; Type -&gt; Bool) -&gt; (Type -&gt; Type -&gt; Bool) -&gt; Eq Type
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Type -&gt; Type -&gt; Bool
== :: Type -&gt; Type -&gt; Bool
$c/= :: Type -&gt; Type -&gt; Bool
/= :: Type -&gt; Type -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205428"><span id="local-6989586621679205487"><span id="local-6989586621679205490"><span id="local-6989586621679205493"><span id="local-6989586621679205496"><span id="local-6989586621679205499"><span id="local-6989586621679205502"><span class="annot"><span class="annottext">Eq Type
Eq Type =&gt;
(Type -&gt; Type -&gt; Ordering)
-&gt; (Type -&gt; Type -&gt; Bool)
-&gt; (Type -&gt; Type -&gt; Bool)
-&gt; (Type -&gt; Type -&gt; Bool)
-&gt; (Type -&gt; Type -&gt; Bool)
-&gt; (Type -&gt; Type -&gt; Type)
-&gt; (Type -&gt; Type -&gt; Type)
-&gt; Ord Type
Type -&gt; Type -&gt; Bool
Type -&gt; Type -&gt; Ordering
Type -&gt; Type -&gt; Type
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Type -&gt; Type -&gt; Ordering
compare :: Type -&gt; Type -&gt; Ordering
$c&lt; :: Type -&gt; Type -&gt; Bool
&lt; :: Type -&gt; Type -&gt; Bool
$c&lt;= :: Type -&gt; Type -&gt; Bool
&lt;= :: Type -&gt; Type -&gt; Bool
$c&gt; :: Type -&gt; Type -&gt; Bool
&gt; :: Type -&gt; Type -&gt; Bool
$c&gt;= :: Type -&gt; Type -&gt; Bool
&gt;= :: Type -&gt; Type -&gt; Bool
$cmax :: Type -&gt; Type -&gt; Type
max :: Type -&gt; Type -&gt; Type
$cmin :: Type -&gt; Type -&gt; Type
min :: Type -&gt; Type -&gt; Type
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205509"><span id="local-6989586621679205549"><span id="local-6989586621679205588"><span id="local-6989586621679205590"><span id="local-6989586621679205592"><span id="local-6989586621679205597"><span id="local-6989586621679205602"><span id="local-6989586621679205605"><span id="local-6989586621679205608"><span id="local-6989586621679205611"><span id="local-6989586621679205614"><span id="local-6989586621679205617"><span id="local-6989586621679205622"><span id="local-6989586621679205627"><span class="annot"><span class="annottext">Typeable Type
Typeable Type =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Type -&gt; c Type)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Type)
-&gt; (Type -&gt; Constr)
-&gt; (Type -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Type))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Type))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Type -&gt; Type)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Type -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type)
-&gt; Data Type
Type -&gt; Constr
Type -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Type -&gt; Type
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Type -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Type
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Type -&gt; c Type
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Type)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Type)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Type -&gt; c Type
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Type -&gt; c Type
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Type
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Type
$ctoConstr :: Type -&gt; Constr
toConstr :: Type -&gt; Constr
$cdataTypeOf :: Type -&gt; DataType
dataTypeOf :: Type -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Type)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Type)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Type)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Type)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Type -&gt; Type
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Type -&gt; Type
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Type -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Type -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type -&gt; m Type
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205636"><span id="local-6989586621679205638"><span class="annot"><span class="annottext">(forall x. Type -&gt; Rep Type x)
-&gt; (forall x. Rep Type x -&gt; Type) -&gt; Generic Type
forall x. Rep Type x -&gt; Type
forall x. Type -&gt; Rep Type x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Type -&gt; Rep Type x
from :: forall x. Type -&gt; Rep Type x
$cto :: forall x. Rep Type x -&gt; Type
to :: forall x. Rep Type x -&gt; Type
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2879"></span><span>
</span><span id="line-2880"></span><span class="hs-keyword">data</span><span> </span><span id="Specificity"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Specificity"><span class="hs-identifier hs-var">Specificity</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="SpecifiedSpec"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#SpecifiedSpec"><span class="hs-identifier hs-var">SpecifiedSpec</span></a></span></span><span>          </span><span class="annot"><span class="hs-comment">-- ^ @a@</span></span><span>
</span><span id="line-2881"></span><span>                 </span><span class="hs-glyph">|</span><span> </span><span id="InferredSpec"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InferredSpec"><span class="hs-identifier hs-var">InferredSpec</span></a></span></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ @{a}@</span></span><span>
</span><span id="line-2882"></span><span>      </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679205643"><span id="local-6989586621679205645"><span id="local-6989586621679205648"><span class="annot"><span class="annottext">Int -&gt; Specificity -&gt; FilePath -&gt; FilePath
[Specificity] -&gt; FilePath -&gt; FilePath
Specificity -&gt; FilePath
(Int -&gt; Specificity -&gt; FilePath -&gt; FilePath)
-&gt; (Specificity -&gt; FilePath)
-&gt; ([Specificity] -&gt; FilePath -&gt; FilePath)
-&gt; Show Specificity
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Specificity -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Specificity -&gt; FilePath -&gt; FilePath
$cshow :: Specificity -&gt; FilePath
show :: Specificity -&gt; FilePath
$cshowList :: [Specificity] -&gt; FilePath -&gt; FilePath
showList :: [Specificity] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205651"><span id="local-6989586621679205655"><span class="annot"><span class="annottext">Specificity -&gt; Specificity -&gt; Bool
(Specificity -&gt; Specificity -&gt; Bool)
-&gt; (Specificity -&gt; Specificity -&gt; Bool) -&gt; Eq Specificity
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Specificity -&gt; Specificity -&gt; Bool
== :: Specificity -&gt; Specificity -&gt; Bool
$c/= :: Specificity -&gt; Specificity -&gt; Bool
/= :: Specificity -&gt; Specificity -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205660"><span id="local-6989586621679205662"><span id="local-6989586621679205664"><span id="local-6989586621679205667"><span id="local-6989586621679205670"><span id="local-6989586621679205673"><span id="local-6989586621679205676"><span class="annot"><span class="annottext">Eq Specificity
Eq Specificity =&gt;
(Specificity -&gt; Specificity -&gt; Ordering)
-&gt; (Specificity -&gt; Specificity -&gt; Bool)
-&gt; (Specificity -&gt; Specificity -&gt; Bool)
-&gt; (Specificity -&gt; Specificity -&gt; Bool)
-&gt; (Specificity -&gt; Specificity -&gt; Bool)
-&gt; (Specificity -&gt; Specificity -&gt; Specificity)
-&gt; (Specificity -&gt; Specificity -&gt; Specificity)
-&gt; Ord Specificity
Specificity -&gt; Specificity -&gt; Bool
Specificity -&gt; Specificity -&gt; Ordering
Specificity -&gt; Specificity -&gt; Specificity
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Specificity -&gt; Specificity -&gt; Ordering
compare :: Specificity -&gt; Specificity -&gt; Ordering
$c&lt; :: Specificity -&gt; Specificity -&gt; Bool
&lt; :: Specificity -&gt; Specificity -&gt; Bool
$c&lt;= :: Specificity -&gt; Specificity -&gt; Bool
&lt;= :: Specificity -&gt; Specificity -&gt; Bool
$c&gt; :: Specificity -&gt; Specificity -&gt; Bool
&gt; :: Specificity -&gt; Specificity -&gt; Bool
$c&gt;= :: Specificity -&gt; Specificity -&gt; Bool
&gt;= :: Specificity -&gt; Specificity -&gt; Bool
$cmax :: Specificity -&gt; Specificity -&gt; Specificity
max :: Specificity -&gt; Specificity -&gt; Specificity
$cmin :: Specificity -&gt; Specificity -&gt; Specificity
min :: Specificity -&gt; Specificity -&gt; Specificity
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205681"><span id="local-6989586621679205683"><span id="local-6989586621679205685"><span id="local-6989586621679205687"><span id="local-6989586621679205689"><span id="local-6989586621679205694"><span id="local-6989586621679205699"><span id="local-6989586621679205702"><span id="local-6989586621679205705"><span id="local-6989586621679205708"><span id="local-6989586621679205711"><span id="local-6989586621679205714"><span id="local-6989586621679205719"><span id="local-6989586621679205724"><span class="annot"><span class="annottext">Typeable Specificity
Typeable Specificity =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Specificity -&gt; c Specificity)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Specificity)
-&gt; (Specificity -&gt; Constr)
-&gt; (Specificity -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Specificity))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c Specificity))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Specificity -&gt; Specificity)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Specificity -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Specificity -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Specificity -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Specificity -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity)
-&gt; Data Specificity
Specificity -&gt; Constr
Specificity -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Specificity -&gt; Specificity
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Specificity -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Specificity -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Specificity -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Specificity -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Specificity
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Specificity -&gt; c Specificity
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Specificity)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Specificity)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Specificity -&gt; c Specificity
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Specificity -&gt; c Specificity
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Specificity
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Specificity
$ctoConstr :: Specificity -&gt; Constr
toConstr :: Specificity -&gt; Constr
$cdataTypeOf :: Specificity -&gt; DataType
dataTypeOf :: Specificity -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Specificity)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Specificity)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Specificity)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Specificity)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Specificity -&gt; Specificity
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Specificity -&gt; Specificity
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Specificity -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Specificity -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Specificity -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Specificity -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Specificity -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Specificity -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Specificity -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Specificity -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Specificity -&gt; m Specificity
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205729"><span id="local-6989586621679205731"><span class="annot"><span class="annottext">(forall x. Specificity -&gt; Rep Specificity x)
-&gt; (forall x. Rep Specificity x -&gt; Specificity)
-&gt; Generic Specificity
forall x. Rep Specificity x -&gt; Specificity
forall x. Specificity -&gt; Rep Specificity x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Specificity -&gt; Rep Specificity x
from :: forall x. Specificity -&gt; Rep Specificity x
$cto :: forall x. Rep Specificity x -&gt; Specificity
to :: forall x. Rep Specificity x -&gt; Specificity
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2883"></span><span>
</span><span id="line-2884"></span><span class="hs-comment">-- | The @flag@ type parameter is instantiated to one of the following types:</span><span>
</span><span id="line-2885"></span><span class="hs-comment">--</span><span>
</span><span id="line-2886"></span><span class="hs-comment">--   * 'Specificity' (examples: 'ForallC', 'ForallT')</span><span>
</span><span id="line-2887"></span><span class="hs-comment">--   * 'BndrVis' (examples: 'DataD', 'ClassD', etc.)</span><span>
</span><span id="line-2888"></span><span class="hs-comment">--   * '()', a catch-all type for other forms of binders, including 'ForallVisT', 'DataInstD', 'RuleP', and 'TyVarSig'</span><span>
</span><span id="line-2889"></span><span class="hs-comment">--</span><span>
</span><span id="line-2890"></span><span class="hs-keyword">data</span><span> </span><span id="TyVarBndr"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-var">TyVarBndr</span></a></span></span><span> </span><span id="local-6989586621679205734"><span class="annot"><a href="#local-6989586621679205734"><span class="hs-identifier hs-type">flag</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="PlainTV"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PlainTV"><span class="hs-identifier hs-var">PlainTV</span></a></span></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679205734"><span class="hs-identifier hs-type">flag</span></a></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ @a@</span></span><span>
</span><span id="line-2891"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="KindedTV"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#KindedTV"><span class="hs-identifier hs-var">KindedTV</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679205734"><span class="hs-identifier hs-type">flag</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @(a :: k)@</span></span><span>
</span><span id="line-2892"></span><span>      </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679205737"><span id="local-6989586621679205746"><span id="local-6989586621679205749"><span class="annot"><span class="annottext">Int -&gt; TyVarBndr flag -&gt; FilePath -&gt; FilePath
[TyVarBndr flag] -&gt; FilePath -&gt; FilePath
TyVarBndr flag -&gt; FilePath
(Int -&gt; TyVarBndr flag -&gt; FilePath -&gt; FilePath)
-&gt; (TyVarBndr flag -&gt; FilePath)
-&gt; ([TyVarBndr flag] -&gt; FilePath -&gt; FilePath)
-&gt; Show (TyVarBndr flag)
forall flag.
Show flag =&gt;
Int -&gt; TyVarBndr flag -&gt; FilePath -&gt; FilePath
forall flag. Show flag =&gt; [TyVarBndr flag] -&gt; FilePath -&gt; FilePath
forall flag. Show flag =&gt; TyVarBndr flag -&gt; FilePath
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: forall flag.
Show flag =&gt;
Int -&gt; TyVarBndr flag -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; TyVarBndr flag -&gt; FilePath -&gt; FilePath
$cshow :: forall flag. Show flag =&gt; TyVarBndr flag -&gt; FilePath
show :: TyVarBndr flag -&gt; FilePath
$cshowList :: forall flag. Show flag =&gt; [TyVarBndr flag] -&gt; FilePath -&gt; FilePath
showList :: [TyVarBndr flag] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205753"><span id="local-6989586621679205762"><span class="annot"><span class="annottext">TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
(TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool)
-&gt; (TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool)
-&gt; Eq (TyVarBndr flag)
forall flag. Eq flag =&gt; TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall flag. Eq flag =&gt; TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
== :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
$c/= :: forall flag. Eq flag =&gt; TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
/= :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205769"><span id="local-6989586621679205776"><span id="local-6989586621679205783"><span id="local-6989586621679205786"><span id="local-6989586621679205789"><span id="local-6989586621679205792"><span id="local-6989586621679205795"><span class="annot"><span class="annottext">Eq (TyVarBndr flag)
Eq (TyVarBndr flag) =&gt;
(TyVarBndr flag -&gt; TyVarBndr flag -&gt; Ordering)
-&gt; (TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool)
-&gt; (TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool)
-&gt; (TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool)
-&gt; (TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool)
-&gt; (TyVarBndr flag -&gt; TyVarBndr flag -&gt; TyVarBndr flag)
-&gt; (TyVarBndr flag -&gt; TyVarBndr flag -&gt; TyVarBndr flag)
-&gt; Ord (TyVarBndr flag)
TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
TyVarBndr flag -&gt; TyVarBndr flag -&gt; Ordering
TyVarBndr flag -&gt; TyVarBndr flag -&gt; TyVarBndr flag
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall flag. Ord flag =&gt; Eq (TyVarBndr flag)
forall flag. Ord flag =&gt; TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
forall flag.
Ord flag =&gt;
TyVarBndr flag -&gt; TyVarBndr flag -&gt; Ordering
forall flag.
Ord flag =&gt;
TyVarBndr flag -&gt; TyVarBndr flag -&gt; TyVarBndr flag
$ccompare :: forall flag.
Ord flag =&gt;
TyVarBndr flag -&gt; TyVarBndr flag -&gt; Ordering
compare :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; Ordering
$c&lt; :: forall flag. Ord flag =&gt; TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
&lt; :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
$c&lt;= :: forall flag. Ord flag =&gt; TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
&lt;= :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
$c&gt; :: forall flag. Ord flag =&gt; TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
&gt; :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
$c&gt;= :: forall flag. Ord flag =&gt; TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
&gt;= :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; Bool
$cmax :: forall flag.
Ord flag =&gt;
TyVarBndr flag -&gt; TyVarBndr flag -&gt; TyVarBndr flag
max :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; TyVarBndr flag
$cmin :: forall flag.
Ord flag =&gt;
TyVarBndr flag -&gt; TyVarBndr flag -&gt; TyVarBndr flag
min :: TyVarBndr flag -&gt; TyVarBndr flag -&gt; TyVarBndr flag
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205804"><span id="local-6989586621679205811"><span id="local-6989586621679205818"><span id="local-6989586621679205820"><span id="local-6989586621679205822"><span id="local-6989586621679205828"><span id="local-6989586621679205833"><span id="local-6989586621679205836"><span id="local-6989586621679205839"><span id="local-6989586621679205842"><span id="local-6989586621679205845"><span id="local-6989586621679205848"><span id="local-6989586621679205853"><span id="local-6989586621679205858"><span class="annot"><span class="annottext">Typeable (TyVarBndr flag)
Typeable (TyVarBndr flag) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; TyVarBndr flag -&gt; c (TyVarBndr flag))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBndr flag))
-&gt; (TyVarBndr flag -&gt; Constr)
-&gt; (TyVarBndr flag -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBndr flag)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (TyVarBndr flag)))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; TyVarBndr flag -&gt; TyVarBndr flag)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; TyVarBndr flag -&gt; m (TyVarBndr flag))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; TyVarBndr flag -&gt; m (TyVarBndr flag))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; TyVarBndr flag -&gt; m (TyVarBndr flag))
-&gt; Data (TyVarBndr flag)
TyVarBndr flag -&gt; Constr
TyVarBndr flag -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; TyVarBndr flag -&gt; TyVarBndr flag
forall flag. Data flag =&gt; Typeable (TyVarBndr flag)
forall flag. Data flag =&gt; TyVarBndr flag -&gt; Constr
forall flag. Data flag =&gt; TyVarBndr flag -&gt; DataType
forall flag.
Data flag =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; TyVarBndr flag -&gt; TyVarBndr flag
forall flag u.
Data flag =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; u
forall flag u.
Data flag =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; [u]
forall flag r r'.
Data flag =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r
forall flag r r'.
Data flag =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r
forall flag (m :: * -&gt; *).
(Data flag, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
forall flag (m :: * -&gt; *).
(Data flag, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
forall flag (c :: * -&gt; *).
Data flag =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBndr flag)
forall flag (c :: * -&gt; *).
Data flag =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyVarBndr flag -&gt; c (TyVarBndr flag)
forall flag (t :: * -&gt; *) (c :: * -&gt; *).
(Data flag, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBndr flag))
forall flag (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data flag, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TyVarBndr flag))
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBndr flag)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyVarBndr flag -&gt; c (TyVarBndr flag)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBndr flag))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TyVarBndr flag))
$cgfoldl :: forall flag (c :: * -&gt; *).
Data flag =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyVarBndr flag -&gt; c (TyVarBndr flag)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyVarBndr flag -&gt; c (TyVarBndr flag)
$cgunfold :: forall flag (c :: * -&gt; *).
Data flag =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBndr flag)
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBndr flag)
$ctoConstr :: forall flag. Data flag =&gt; TyVarBndr flag -&gt; Constr
toConstr :: TyVarBndr flag -&gt; Constr
$cdataTypeOf :: forall flag. Data flag =&gt; TyVarBndr flag -&gt; DataType
dataTypeOf :: TyVarBndr flag -&gt; DataType
$cdataCast1 :: forall flag (t :: * -&gt; *) (c :: * -&gt; *).
(Data flag, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBndr flag))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBndr flag))
$cdataCast2 :: forall flag (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data flag, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TyVarBndr flag))
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TyVarBndr flag))
$cgmapT :: forall flag.
Data flag =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; TyVarBndr flag -&gt; TyVarBndr flag
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TyVarBndr flag -&gt; TyVarBndr flag
$cgmapQl :: forall flag r r'.
Data flag =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r
$cgmapQr :: forall flag r r'.
Data flag =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBndr flag -&gt; r
$cgmapQ :: forall flag u.
Data flag =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; [u]
$cgmapQi :: forall flag u.
Data flag =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBndr flag -&gt; u
$cgmapM :: forall flag (m :: * -&gt; *).
(Data flag, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
$cgmapMp :: forall flag (m :: * -&gt; *).
(Data flag, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
$cgmapMo :: forall flag (m :: * -&gt; *).
(Data flag, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; TyVarBndr flag -&gt; m (TyVarBndr flag)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205864"><span id="local-6989586621679205866"><span class="annot"><span class="annottext">(forall x. TyVarBndr flag -&gt; Rep (TyVarBndr flag) x)
-&gt; (forall x. Rep (TyVarBndr flag) x -&gt; TyVarBndr flag)
-&gt; Generic (TyVarBndr flag)
forall x. Rep (TyVarBndr flag) x -&gt; TyVarBndr flag
forall x. TyVarBndr flag -&gt; Rep (TyVarBndr flag) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall flag x. Rep (TyVarBndr flag) x -&gt; TyVarBndr flag
forall flag x. TyVarBndr flag -&gt; Rep (TyVarBndr flag) x
$cfrom :: forall flag x. TyVarBndr flag -&gt; Rep (TyVarBndr flag) x
from :: forall x. TyVarBndr flag -&gt; Rep (TyVarBndr flag) x
$cto :: forall flag x. Rep (TyVarBndr flag) x -&gt; TyVarBndr flag
to :: forall x. Rep (TyVarBndr flag) x -&gt; TyVarBndr flag
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205869"><span id="local-6989586621679205871"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; TyVarBndr a -&gt; TyVarBndr b)
-&gt; (forall a b. a -&gt; TyVarBndr b -&gt; TyVarBndr a)
-&gt; Functor TyVarBndr
forall a b. a -&gt; TyVarBndr b -&gt; TyVarBndr a
forall a b. (a -&gt; b) -&gt; TyVarBndr a -&gt; TyVarBndr b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall a b. (a -&gt; b) -&gt; TyVarBndr a -&gt; TyVarBndr b
fmap :: forall a b. (a -&gt; b) -&gt; TyVarBndr a -&gt; TyVarBndr b
$c&lt;$ :: forall a b. a -&gt; TyVarBndr b -&gt; TyVarBndr a
&lt;$ :: forall a b. a -&gt; TyVarBndr b -&gt; TyVarBndr a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205875"><span id="local-6989586621679205881"><span id="local-6989586621679205884"><span id="local-6989586621679205889"><span id="local-6989586621679205891"><span id="local-6989586621679205894"><span id="local-6989586621679205897"><span id="local-6989586621679205900"><span id="local-6989586621679205903"><span id="local-6989586621679205906"><span id="local-6989586621679205909"><span id="local-6989586621679205911"><span id="local-6989586621679205914"><span id="local-6989586621679205919"><span id="local-6989586621679205924"><span id="local-6989586621679205929"><span id="local-6989586621679205934"><span class="annot"><span class="annottext">(forall m. Monoid m =&gt; TyVarBndr m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBndr a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBndr a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; TyVarBndr a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; TyVarBndr a -&gt; a)
-&gt; (forall a. TyVarBndr a -&gt; [a])
-&gt; (forall a. TyVarBndr a -&gt; Bool)
-&gt; (forall a. TyVarBndr a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; TyVarBndr a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; TyVarBndr a -&gt; a)
-&gt; (forall a. Ord a =&gt; TyVarBndr a -&gt; a)
-&gt; (forall a. Num a =&gt; TyVarBndr a -&gt; a)
-&gt; (forall a. Num a =&gt; TyVarBndr a -&gt; a)
-&gt; Foldable TyVarBndr
forall a. Eq a =&gt; a -&gt; TyVarBndr a -&gt; Bool
forall a. Num a =&gt; TyVarBndr a -&gt; a
forall a. Ord a =&gt; TyVarBndr a -&gt; a
forall m. Monoid m =&gt; TyVarBndr m -&gt; m
forall a. TyVarBndr a -&gt; Bool
forall a. TyVarBndr a -&gt; Int
forall a. TyVarBndr a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; TyVarBndr a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBndr a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
$cfold :: forall m. Monoid m =&gt; TyVarBndr m -&gt; m
fold :: forall m. Monoid m =&gt; TyVarBndr m -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBndr a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBndr a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBndr a -&gt; m
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBndr a -&gt; m
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBndr a -&gt; b
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; TyVarBndr a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; TyVarBndr a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; TyVarBndr a -&gt; a
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; TyVarBndr a -&gt; a
$ctoList :: forall a. TyVarBndr a -&gt; [a]
toList :: forall a. TyVarBndr a -&gt; [a]
$cnull :: forall a. TyVarBndr a -&gt; Bool
null :: forall a. TyVarBndr a -&gt; Bool
$clength :: forall a. TyVarBndr a -&gt; Int
length :: forall a. TyVarBndr a -&gt; Int
$celem :: forall a. Eq a =&gt; a -&gt; TyVarBndr a -&gt; Bool
elem :: forall a. Eq a =&gt; a -&gt; TyVarBndr a -&gt; Bool
$cmaximum :: forall a. Ord a =&gt; TyVarBndr a -&gt; a
maximum :: forall a. Ord a =&gt; TyVarBndr a -&gt; a
$cminimum :: forall a. Ord a =&gt; TyVarBndr a -&gt; a
minimum :: forall a. Ord a =&gt; TyVarBndr a -&gt; a
$csum :: forall a. Num a =&gt; TyVarBndr a -&gt; a
sum :: forall a. Num a =&gt; TyVarBndr a -&gt; a
$cproduct :: forall a. Num a =&gt; TyVarBndr a -&gt; a
product :: forall a. Num a =&gt; TyVarBndr a -&gt; a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205946"><span id="local-6989586621679205952"><span id="local-6989586621679205958"><span id="local-6989586621679205963"><span class="annot"><span class="annottext">Functor TyVarBndr
Foldable TyVarBndr
(Functor TyVarBndr, Foldable TyVarBndr) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; TyVarBndr a -&gt; f (TyVarBndr b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    TyVarBndr (f a) -&gt; f (TyVarBndr a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; TyVarBndr a -&gt; m (TyVarBndr b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    TyVarBndr (m a) -&gt; m (TyVarBndr a))
-&gt; Traversable TyVarBndr
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
TyVarBndr (m a) -&gt; m (TyVarBndr a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
TyVarBndr (f a) -&gt; f (TyVarBndr a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TyVarBndr a -&gt; m (TyVarBndr b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TyVarBndr a -&gt; f (TyVarBndr b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TyVarBndr a -&gt; f (TyVarBndr b)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TyVarBndr a -&gt; f (TyVarBndr b)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
TyVarBndr (f a) -&gt; f (TyVarBndr a)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
TyVarBndr (f a) -&gt; f (TyVarBndr a)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TyVarBndr a -&gt; m (TyVarBndr b)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TyVarBndr a -&gt; m (TyVarBndr b)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
TyVarBndr (m a) -&gt; m (TyVarBndr a)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
TyVarBndr (m a) -&gt; m (TyVarBndr a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2893"></span><span>
</span><span id="line-2894"></span><span class="hs-keyword">data</span><span> </span><span id="BndrVis"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrVis"><span class="hs-identifier hs-var">BndrVis</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="BndrReq"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrReq"><span class="hs-identifier hs-var">BndrReq</span></a></span></span><span>                    </span><span class="annot"><span class="hs-comment">-- ^ @a@</span></span><span>
</span><span id="line-2895"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="BndrInvis"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#BndrInvis"><span class="hs-identifier hs-var">BndrInvis</span></a></span></span><span>                  </span><span class="annot"><span class="hs-comment">-- ^ @\@a@</span></span><span>
</span><span id="line-2896"></span><span>      </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679205972"><span id="local-6989586621679205974"><span id="local-6989586621679205977"><span class="annot"><span class="annottext">Int -&gt; BndrVis -&gt; FilePath -&gt; FilePath
[BndrVis] -&gt; FilePath -&gt; FilePath
BndrVis -&gt; FilePath
(Int -&gt; BndrVis -&gt; FilePath -&gt; FilePath)
-&gt; (BndrVis -&gt; FilePath)
-&gt; ([BndrVis] -&gt; FilePath -&gt; FilePath)
-&gt; Show BndrVis
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; BndrVis -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; BndrVis -&gt; FilePath -&gt; FilePath
$cshow :: BndrVis -&gt; FilePath
show :: BndrVis -&gt; FilePath
$cshowList :: [BndrVis] -&gt; FilePath -&gt; FilePath
showList :: [BndrVis] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205980"><span id="local-6989586621679205984"><span class="annot"><span class="annottext">BndrVis -&gt; BndrVis -&gt; Bool
(BndrVis -&gt; BndrVis -&gt; Bool)
-&gt; (BndrVis -&gt; BndrVis -&gt; Bool) -&gt; Eq BndrVis
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: BndrVis -&gt; BndrVis -&gt; Bool
== :: BndrVis -&gt; BndrVis -&gt; Bool
$c/= :: BndrVis -&gt; BndrVis -&gt; Bool
/= :: BndrVis -&gt; BndrVis -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679205989"><span id="local-6989586621679205991"><span id="local-6989586621679205993"><span id="local-6989586621679205996"><span id="local-6989586621679205999"><span id="local-6989586621679206002"><span id="local-6989586621679206005"><span class="annot"><span class="annottext">Eq BndrVis
Eq BndrVis =&gt;
(BndrVis -&gt; BndrVis -&gt; Ordering)
-&gt; (BndrVis -&gt; BndrVis -&gt; Bool)
-&gt; (BndrVis -&gt; BndrVis -&gt; Bool)
-&gt; (BndrVis -&gt; BndrVis -&gt; Bool)
-&gt; (BndrVis -&gt; BndrVis -&gt; Bool)
-&gt; (BndrVis -&gt; BndrVis -&gt; BndrVis)
-&gt; (BndrVis -&gt; BndrVis -&gt; BndrVis)
-&gt; Ord BndrVis
BndrVis -&gt; BndrVis -&gt; Bool
BndrVis -&gt; BndrVis -&gt; Ordering
BndrVis -&gt; BndrVis -&gt; BndrVis
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: BndrVis -&gt; BndrVis -&gt; Ordering
compare :: BndrVis -&gt; BndrVis -&gt; Ordering
$c&lt; :: BndrVis -&gt; BndrVis -&gt; Bool
&lt; :: BndrVis -&gt; BndrVis -&gt; Bool
$c&lt;= :: BndrVis -&gt; BndrVis -&gt; Bool
&lt;= :: BndrVis -&gt; BndrVis -&gt; Bool
$c&gt; :: BndrVis -&gt; BndrVis -&gt; Bool
&gt; :: BndrVis -&gt; BndrVis -&gt; Bool
$c&gt;= :: BndrVis -&gt; BndrVis -&gt; Bool
&gt;= :: BndrVis -&gt; BndrVis -&gt; Bool
$cmax :: BndrVis -&gt; BndrVis -&gt; BndrVis
max :: BndrVis -&gt; BndrVis -&gt; BndrVis
$cmin :: BndrVis -&gt; BndrVis -&gt; BndrVis
min :: BndrVis -&gt; BndrVis -&gt; BndrVis
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206010"><span id="local-6989586621679206012"><span id="local-6989586621679206014"><span id="local-6989586621679206016"><span id="local-6989586621679206018"><span id="local-6989586621679206023"><span id="local-6989586621679206028"><span id="local-6989586621679206031"><span id="local-6989586621679206034"><span id="local-6989586621679206037"><span id="local-6989586621679206040"><span id="local-6989586621679206043"><span id="local-6989586621679206048"><span id="local-6989586621679206053"><span class="annot"><span class="annottext">Typeable BndrVis
Typeable BndrVis =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; BndrVis -&gt; c BndrVis)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c BndrVis)
-&gt; (BndrVis -&gt; Constr)
-&gt; (BndrVis -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c BndrVis))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c BndrVis))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; BndrVis -&gt; BndrVis)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BndrVis -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BndrVis -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BndrVis -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BndrVis -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis)
-&gt; Data BndrVis
BndrVis -&gt; Constr
BndrVis -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; BndrVis -&gt; BndrVis
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BndrVis -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BndrVis -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BndrVis -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BndrVis -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c BndrVis
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BndrVis -&gt; c BndrVis
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c BndrVis)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c BndrVis)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BndrVis -&gt; c BndrVis
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BndrVis -&gt; c BndrVis
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c BndrVis
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c BndrVis
$ctoConstr :: BndrVis -&gt; Constr
toConstr :: BndrVis -&gt; Constr
$cdataTypeOf :: BndrVis -&gt; DataType
dataTypeOf :: BndrVis -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c BndrVis)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c BndrVis)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c BndrVis)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c BndrVis)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; BndrVis -&gt; BndrVis
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; BndrVis -&gt; BndrVis
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BndrVis -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BndrVis -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BndrVis -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BndrVis -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BndrVis -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BndrVis -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BndrVis -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BndrVis -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BndrVis -&gt; m BndrVis
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206058"><span id="local-6989586621679206060"><span class="annot"><span class="annottext">(forall x. BndrVis -&gt; Rep BndrVis x)
-&gt; (forall x. Rep BndrVis x -&gt; BndrVis) -&gt; Generic BndrVis
forall x. Rep BndrVis x -&gt; BndrVis
forall x. BndrVis -&gt; Rep BndrVis x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. BndrVis -&gt; Rep BndrVis x
from :: forall x. BndrVis -&gt; Rep BndrVis x
$cto :: forall x. Rep BndrVis x -&gt; BndrVis
to :: forall x. Rep BndrVis x -&gt; BndrVis
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2897"></span><span>
</span><span id="line-2898"></span><span class="annot"><span class="hs-comment">-- | Type family result signature</span></span><span>
</span><span id="line-2899"></span><span class="hs-keyword">data</span><span> </span><span id="FamilyResultSig"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#FamilyResultSig"><span class="hs-identifier hs-var">FamilyResultSig</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="NoSig"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NoSig"><span class="hs-identifier hs-var">NoSig</span></a></span></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ no signature</span></span><span>
</span><span id="line-2900"></span><span>                     </span><span class="hs-glyph">|</span><span> </span><span id="KindSig"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#KindSig"><span class="hs-identifier hs-var">KindSig</span></a></span></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ @k@</span></span><span>
</span><span id="line-2901"></span><span>                     </span><span class="hs-glyph">|</span><span> </span><span id="TyVarSig"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarSig"><span class="hs-identifier hs-var">TyVarSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyVarBndr"><span class="hs-identifier hs-type">TyVarBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ @= r, = (r :: k)@</span></span><span>
</span><span id="line-2902"></span><span>      </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679206065"><span id="local-6989586621679206072"><span id="local-6989586621679206075"><span class="annot"><span class="annottext">Int -&gt; FamilyResultSig -&gt; FilePath -&gt; FilePath
[FamilyResultSig] -&gt; FilePath -&gt; FilePath
FamilyResultSig -&gt; FilePath
(Int -&gt; FamilyResultSig -&gt; FilePath -&gt; FilePath)
-&gt; (FamilyResultSig -&gt; FilePath)
-&gt; ([FamilyResultSig] -&gt; FilePath -&gt; FilePath)
-&gt; Show FamilyResultSig
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; FamilyResultSig -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; FamilyResultSig -&gt; FilePath -&gt; FilePath
$cshow :: FamilyResultSig -&gt; FilePath
show :: FamilyResultSig -&gt; FilePath
$cshowList :: [FamilyResultSig] -&gt; FilePath -&gt; FilePath
showList :: [FamilyResultSig] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206078"><span id="local-6989586621679206085"><span class="annot"><span class="annottext">FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
(FamilyResultSig -&gt; FamilyResultSig -&gt; Bool)
-&gt; (FamilyResultSig -&gt; FamilyResultSig -&gt; Bool)
-&gt; Eq FamilyResultSig
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
== :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
$c/= :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
/= :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206090"><span id="local-6989586621679206095"><span id="local-6989586621679206100"><span id="local-6989586621679206103"><span id="local-6989586621679206106"><span id="local-6989586621679206109"><span id="local-6989586621679206112"><span class="annot"><span class="annottext">Eq FamilyResultSig
Eq FamilyResultSig =&gt;
(FamilyResultSig -&gt; FamilyResultSig -&gt; Ordering)
-&gt; (FamilyResultSig -&gt; FamilyResultSig -&gt; Bool)
-&gt; (FamilyResultSig -&gt; FamilyResultSig -&gt; Bool)
-&gt; (FamilyResultSig -&gt; FamilyResultSig -&gt; Bool)
-&gt; (FamilyResultSig -&gt; FamilyResultSig -&gt; Bool)
-&gt; (FamilyResultSig -&gt; FamilyResultSig -&gt; FamilyResultSig)
-&gt; (FamilyResultSig -&gt; FamilyResultSig -&gt; FamilyResultSig)
-&gt; Ord FamilyResultSig
FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
FamilyResultSig -&gt; FamilyResultSig -&gt; Ordering
FamilyResultSig -&gt; FamilyResultSig -&gt; FamilyResultSig
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: FamilyResultSig -&gt; FamilyResultSig -&gt; Ordering
compare :: FamilyResultSig -&gt; FamilyResultSig -&gt; Ordering
$c&lt; :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
&lt; :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
$c&lt;= :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
&lt;= :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
$c&gt; :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
&gt; :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
$c&gt;= :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
&gt;= :: FamilyResultSig -&gt; FamilyResultSig -&gt; Bool
$cmax :: FamilyResultSig -&gt; FamilyResultSig -&gt; FamilyResultSig
max :: FamilyResultSig -&gt; FamilyResultSig -&gt; FamilyResultSig
$cmin :: FamilyResultSig -&gt; FamilyResultSig -&gt; FamilyResultSig
min :: FamilyResultSig -&gt; FamilyResultSig -&gt; FamilyResultSig
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206117"><span id="local-6989586621679206122"><span id="local-6989586621679206127"><span id="local-6989586621679206129"><span id="local-6989586621679206131"><span id="local-6989586621679206136"><span id="local-6989586621679206141"><span id="local-6989586621679206144"><span id="local-6989586621679206147"><span id="local-6989586621679206150"><span id="local-6989586621679206153"><span id="local-6989586621679206156"><span id="local-6989586621679206161"><span id="local-6989586621679206166"><span class="annot"><span class="annottext">Typeable FamilyResultSig
Typeable FamilyResultSig =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; FamilyResultSig -&gt; c FamilyResultSig)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FamilyResultSig)
-&gt; (FamilyResultSig -&gt; Constr)
-&gt; (FamilyResultSig -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FamilyResultSig))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c FamilyResultSig))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; FamilyResultSig -&gt; FamilyResultSig)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FamilyResultSig -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FamilyResultSig -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; FamilyResultSig -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FamilyResultSig -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FamilyResultSig -&gt; m FamilyResultSig)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FamilyResultSig -&gt; m FamilyResultSig)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FamilyResultSig -&gt; m FamilyResultSig)
-&gt; Data FamilyResultSig
FamilyResultSig -&gt; Constr
FamilyResultSig -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; FamilyResultSig -&gt; FamilyResultSig
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FamilyResultSig -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FamilyResultSig -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FamilyResultSig -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FamilyResultSig -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FamilyResultSig -&gt; m FamilyResultSig
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FamilyResultSig -&gt; m FamilyResultSig
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FamilyResultSig
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FamilyResultSig -&gt; c FamilyResultSig
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FamilyResultSig)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FamilyResultSig)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FamilyResultSig -&gt; c FamilyResultSig
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FamilyResultSig -&gt; c FamilyResultSig
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FamilyResultSig
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FamilyResultSig
$ctoConstr :: FamilyResultSig -&gt; Constr
toConstr :: FamilyResultSig -&gt; Constr
$cdataTypeOf :: FamilyResultSig -&gt; DataType
dataTypeOf :: FamilyResultSig -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FamilyResultSig)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FamilyResultSig)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FamilyResultSig)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FamilyResultSig)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FamilyResultSig -&gt; FamilyResultSig
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FamilyResultSig -&gt; FamilyResultSig
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FamilyResultSig -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FamilyResultSig -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FamilyResultSig -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FamilyResultSig -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FamilyResultSig -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FamilyResultSig -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FamilyResultSig -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FamilyResultSig -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FamilyResultSig -&gt; m FamilyResultSig
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FamilyResultSig -&gt; m FamilyResultSig
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FamilyResultSig -&gt; m FamilyResultSig
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FamilyResultSig -&gt; m FamilyResultSig
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FamilyResultSig -&gt; m FamilyResultSig
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FamilyResultSig -&gt; m FamilyResultSig
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206171"><span id="local-6989586621679206173"><span class="annot"><span class="annottext">(forall x. FamilyResultSig -&gt; Rep FamilyResultSig x)
-&gt; (forall x. Rep FamilyResultSig x -&gt; FamilyResultSig)
-&gt; Generic FamilyResultSig
forall x. Rep FamilyResultSig x -&gt; FamilyResultSig
forall x. FamilyResultSig -&gt; Rep FamilyResultSig x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. FamilyResultSig -&gt; Rep FamilyResultSig x
from :: forall x. FamilyResultSig -&gt; Rep FamilyResultSig x
$cto :: forall x. Rep FamilyResultSig x -&gt; FamilyResultSig
to :: forall x. Rep FamilyResultSig x -&gt; FamilyResultSig
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2903"></span><span>
</span><span id="line-2904"></span><span class="annot"><span class="hs-comment">-- | Injectivity annotation</span></span><span>
</span><span id="line-2905"></span><span class="hs-keyword">data</span><span> </span><span id="InjectivityAnn"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InjectivityAnn"><span class="hs-identifier hs-var">InjectivityAnn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="InjectivityAnn"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InjectivityAnn"><span class="hs-identifier hs-var">InjectivityAnn</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2906"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span> </span><span id="local-6989586621679206177"><span id="local-6989586621679206182"><span id="local-6989586621679206185"><span class="annot"><span class="annottext">Int -&gt; InjectivityAnn -&gt; FilePath -&gt; FilePath
[InjectivityAnn] -&gt; FilePath -&gt; FilePath
InjectivityAnn -&gt; FilePath
(Int -&gt; InjectivityAnn -&gt; FilePath -&gt; FilePath)
-&gt; (InjectivityAnn -&gt; FilePath)
-&gt; ([InjectivityAnn] -&gt; FilePath -&gt; FilePath)
-&gt; Show InjectivityAnn
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; InjectivityAnn -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; InjectivityAnn -&gt; FilePath -&gt; FilePath
$cshow :: InjectivityAnn -&gt; FilePath
show :: InjectivityAnn -&gt; FilePath
$cshowList :: [InjectivityAnn] -&gt; FilePath -&gt; FilePath
showList :: [InjectivityAnn] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206188"><span id="local-6989586621679206192"><span class="annot"><span class="annottext">InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
(InjectivityAnn -&gt; InjectivityAnn -&gt; Bool)
-&gt; (InjectivityAnn -&gt; InjectivityAnn -&gt; Bool) -&gt; Eq InjectivityAnn
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
== :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
$c/= :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
/= :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206197"><span id="local-6989586621679206201"><span id="local-6989586621679206205"><span id="local-6989586621679206208"><span id="local-6989586621679206211"><span id="local-6989586621679206214"><span id="local-6989586621679206217"><span class="annot"><span class="annottext">Eq InjectivityAnn
Eq InjectivityAnn =&gt;
(InjectivityAnn -&gt; InjectivityAnn -&gt; Ordering)
-&gt; (InjectivityAnn -&gt; InjectivityAnn -&gt; Bool)
-&gt; (InjectivityAnn -&gt; InjectivityAnn -&gt; Bool)
-&gt; (InjectivityAnn -&gt; InjectivityAnn -&gt; Bool)
-&gt; (InjectivityAnn -&gt; InjectivityAnn -&gt; Bool)
-&gt; (InjectivityAnn -&gt; InjectivityAnn -&gt; InjectivityAnn)
-&gt; (InjectivityAnn -&gt; InjectivityAnn -&gt; InjectivityAnn)
-&gt; Ord InjectivityAnn
InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
InjectivityAnn -&gt; InjectivityAnn -&gt; Ordering
InjectivityAnn -&gt; InjectivityAnn -&gt; InjectivityAnn
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: InjectivityAnn -&gt; InjectivityAnn -&gt; Ordering
compare :: InjectivityAnn -&gt; InjectivityAnn -&gt; Ordering
$c&lt; :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
&lt; :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
$c&lt;= :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
&lt;= :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
$c&gt; :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
&gt; :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
$c&gt;= :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
&gt;= :: InjectivityAnn -&gt; InjectivityAnn -&gt; Bool
$cmax :: InjectivityAnn -&gt; InjectivityAnn -&gt; InjectivityAnn
max :: InjectivityAnn -&gt; InjectivityAnn -&gt; InjectivityAnn
$cmin :: InjectivityAnn -&gt; InjectivityAnn -&gt; InjectivityAnn
min :: InjectivityAnn -&gt; InjectivityAnn -&gt; InjectivityAnn
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206222"><span id="local-6989586621679206227"><span id="local-6989586621679206232"><span id="local-6989586621679206234"><span id="local-6989586621679206236"><span id="local-6989586621679206241"><span id="local-6989586621679206246"><span id="local-6989586621679206249"><span id="local-6989586621679206252"><span id="local-6989586621679206255"><span id="local-6989586621679206258"><span id="local-6989586621679206261"><span id="local-6989586621679206266"><span id="local-6989586621679206271"><span class="annot"><span class="annottext">Typeable InjectivityAnn
Typeable InjectivityAnn =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; InjectivityAnn -&gt; c InjectivityAnn)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c InjectivityAnn)
-&gt; (InjectivityAnn -&gt; Constr)
-&gt; (InjectivityAnn -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c InjectivityAnn))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c InjectivityAnn))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; InjectivityAnn -&gt; InjectivityAnn)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityAnn -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityAnn -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityAnn -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityAnn -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; InjectivityAnn -&gt; m InjectivityAnn)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; InjectivityAnn -&gt; m InjectivityAnn)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; InjectivityAnn -&gt; m InjectivityAnn)
-&gt; Data InjectivityAnn
InjectivityAnn -&gt; Constr
InjectivityAnn -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; InjectivityAnn -&gt; InjectivityAnn
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityAnn -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityAnn -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityAnn -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityAnn -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityAnn -&gt; m InjectivityAnn
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityAnn -&gt; m InjectivityAnn
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c InjectivityAnn
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InjectivityAnn -&gt; c InjectivityAnn
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c InjectivityAnn)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c InjectivityAnn)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InjectivityAnn -&gt; c InjectivityAnn
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InjectivityAnn -&gt; c InjectivityAnn
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c InjectivityAnn
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c InjectivityAnn
$ctoConstr :: InjectivityAnn -&gt; Constr
toConstr :: InjectivityAnn -&gt; Constr
$cdataTypeOf :: InjectivityAnn -&gt; DataType
dataTypeOf :: InjectivityAnn -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c InjectivityAnn)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c InjectivityAnn)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c InjectivityAnn)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c InjectivityAnn)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; InjectivityAnn -&gt; InjectivityAnn
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; InjectivityAnn -&gt; InjectivityAnn
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityAnn -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityAnn -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityAnn -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityAnn -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityAnn -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityAnn -&gt; [u]
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityAnn -&gt; u
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityAnn -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityAnn -&gt; m InjectivityAnn
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityAnn -&gt; m InjectivityAnn
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityAnn -&gt; m InjectivityAnn
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityAnn -&gt; m InjectivityAnn
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityAnn -&gt; m InjectivityAnn
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityAnn -&gt; m InjectivityAnn
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206276"><span id="local-6989586621679206278"><span class="annot"><span class="annottext">(forall x. InjectivityAnn -&gt; Rep InjectivityAnn x)
-&gt; (forall x. Rep InjectivityAnn x -&gt; InjectivityAnn)
-&gt; Generic InjectivityAnn
forall x. Rep InjectivityAnn x -&gt; InjectivityAnn
forall x. InjectivityAnn -&gt; Rep InjectivityAnn x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. InjectivityAnn -&gt; Rep InjectivityAnn x
from :: forall x. InjectivityAnn -&gt; Rep InjectivityAnn x
$cto :: forall x. Rep InjectivityAnn x -&gt; InjectivityAnn
to :: forall x. Rep InjectivityAnn x -&gt; InjectivityAnn
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2907"></span><span>
</span><span id="line-2908"></span><span class="hs-keyword">data</span><span> </span><span id="TyLit"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#TyLit"><span class="hs-identifier hs-var">TyLit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="NumTyLit"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NumTyLit"><span class="hs-identifier hs-var">NumTyLit</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>             </span><span class="annot"><span class="hs-comment">-- ^ @2@</span></span><span>
</span><span id="line-2909"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="StrTyLit"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#StrTyLit"><span class="hs-identifier hs-var">StrTyLit</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ @\&quot;Hello\&quot;@</span></span><span>
</span><span id="line-2910"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="CharTyLit"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#CharTyLit"><span class="hs-identifier hs-var">CharTyLit</span></a></span></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Char"><span class="hs-identifier hs-type">Char</span></a></span><span>               </span><span class="annot"><span class="hs-comment">-- ^ @\'C\'@, @since 4.16.0.0</span></span><span>
</span><span id="line-2911"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span> </span><span id="local-6989586621679206284"><span id="local-6989586621679206293"><span id="local-6989586621679206296"><span class="annot"><span class="annottext">Int -&gt; TyLit -&gt; FilePath -&gt; FilePath
[TyLit] -&gt; FilePath -&gt; FilePath
TyLit -&gt; FilePath
(Int -&gt; TyLit -&gt; FilePath -&gt; FilePath)
-&gt; (TyLit -&gt; FilePath)
-&gt; ([TyLit] -&gt; FilePath -&gt; FilePath)
-&gt; Show TyLit
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; TyLit -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; TyLit -&gt; FilePath -&gt; FilePath
$cshow :: TyLit -&gt; FilePath
show :: TyLit -&gt; FilePath
$cshowList :: [TyLit] -&gt; FilePath -&gt; FilePath
showList :: [TyLit] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206299"><span id="local-6989586621679206307"><span class="annot"><span class="annottext">TyLit -&gt; TyLit -&gt; Bool
(TyLit -&gt; TyLit -&gt; Bool) -&gt; (TyLit -&gt; TyLit -&gt; Bool) -&gt; Eq TyLit
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: TyLit -&gt; TyLit -&gt; Bool
== :: TyLit -&gt; TyLit -&gt; Bool
$c/= :: TyLit -&gt; TyLit -&gt; Bool
/= :: TyLit -&gt; TyLit -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206312"><span id="local-6989586621679206318"><span id="local-6989586621679206324"><span id="local-6989586621679206327"><span id="local-6989586621679206330"><span id="local-6989586621679206333"><span id="local-6989586621679206336"><span class="annot"><span class="annottext">Eq TyLit
Eq TyLit =&gt;
(TyLit -&gt; TyLit -&gt; Ordering)
-&gt; (TyLit -&gt; TyLit -&gt; Bool)
-&gt; (TyLit -&gt; TyLit -&gt; Bool)
-&gt; (TyLit -&gt; TyLit -&gt; Bool)
-&gt; (TyLit -&gt; TyLit -&gt; Bool)
-&gt; (TyLit -&gt; TyLit -&gt; TyLit)
-&gt; (TyLit -&gt; TyLit -&gt; TyLit)
-&gt; Ord TyLit
TyLit -&gt; TyLit -&gt; Bool
TyLit -&gt; TyLit -&gt; Ordering
TyLit -&gt; TyLit -&gt; TyLit
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: TyLit -&gt; TyLit -&gt; Ordering
compare :: TyLit -&gt; TyLit -&gt; Ordering
$c&lt; :: TyLit -&gt; TyLit -&gt; Bool
&lt; :: TyLit -&gt; TyLit -&gt; Bool
$c&lt;= :: TyLit -&gt; TyLit -&gt; Bool
&lt;= :: TyLit -&gt; TyLit -&gt; Bool
$c&gt; :: TyLit -&gt; TyLit -&gt; Bool
&gt; :: TyLit -&gt; TyLit -&gt; Bool
$c&gt;= :: TyLit -&gt; TyLit -&gt; Bool
&gt;= :: TyLit -&gt; TyLit -&gt; Bool
$cmax :: TyLit -&gt; TyLit -&gt; TyLit
max :: TyLit -&gt; TyLit -&gt; TyLit
$cmin :: TyLit -&gt; TyLit -&gt; TyLit
min :: TyLit -&gt; TyLit -&gt; TyLit
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206341"><span id="local-6989586621679206347"><span id="local-6989586621679206353"><span id="local-6989586621679206355"><span id="local-6989586621679206357"><span id="local-6989586621679206362"><span id="local-6989586621679206367"><span id="local-6989586621679206370"><span id="local-6989586621679206373"><span id="local-6989586621679206376"><span id="local-6989586621679206379"><span id="local-6989586621679206382"><span id="local-6989586621679206387"><span id="local-6989586621679206392"><span class="annot"><span class="annottext">Typeable TyLit
Typeable TyLit =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; TyLit -&gt; c TyLit)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TyLit)
-&gt; (TyLit -&gt; Constr)
-&gt; (TyLit -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TyLit))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TyLit))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; TyLit -&gt; TyLit)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyLit -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyLit -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TyLit -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyLit -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit)
-&gt; Data TyLit
TyLit -&gt; Constr
TyLit -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; TyLit -&gt; TyLit
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyLit -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TyLit -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyLit -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyLit -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TyLit
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyLit -&gt; c TyLit
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TyLit)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TyLit)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyLit -&gt; c TyLit
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyLit -&gt; c TyLit
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TyLit
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TyLit
$ctoConstr :: TyLit -&gt; Constr
toConstr :: TyLit -&gt; Constr
$cdataTypeOf :: TyLit -&gt; DataType
dataTypeOf :: TyLit -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TyLit)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TyLit)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TyLit)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TyLit)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TyLit -&gt; TyLit
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TyLit -&gt; TyLit
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyLit -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyLit -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyLit -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyLit -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TyLit -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TyLit -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyLit -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyLit -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyLit -&gt; m TyLit
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206397"><span id="local-6989586621679206399"><span class="annot"><span class="annottext">(forall x. TyLit -&gt; Rep TyLit x)
-&gt; (forall x. Rep TyLit x -&gt; TyLit) -&gt; Generic TyLit
forall x. Rep TyLit x -&gt; TyLit
forall x. TyLit -&gt; Rep TyLit x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. TyLit -&gt; Rep TyLit x
from :: forall x. TyLit -&gt; Rep TyLit x
$cto :: forall x. Rep TyLit x -&gt; TyLit
to :: forall x. Rep TyLit x -&gt; TyLit
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2912"></span><span>
</span><span id="line-2913"></span><span class="annot"><span class="hs-comment">-- | Role annotations</span></span><span>
</span><span id="line-2914"></span><span class="hs-keyword">data</span><span> </span><span id="Role"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Role"><span class="hs-identifier hs-var">Role</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="NominalR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NominalR"><span class="hs-identifier hs-var">NominalR</span></a></span></span><span>            </span><span class="annot"><span class="hs-comment">-- ^ @nominal@</span></span><span>
</span><span id="line-2915"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="RepresentationalR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RepresentationalR"><span class="hs-identifier hs-var">RepresentationalR</span></a></span></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @representational@</span></span><span>
</span><span id="line-2916"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="PhantomR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#PhantomR"><span class="hs-identifier hs-var">PhantomR</span></a></span></span><span>            </span><span class="annot"><span class="hs-comment">-- ^ @phantom@</span></span><span>
</span><span id="line-2917"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span id="InferR"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InferR"><span class="hs-identifier hs-var">InferR</span></a></span></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ @_@</span></span><span>
</span><span id="line-2918"></span><span>  </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679206403"><span id="local-6989586621679206405"><span id="local-6989586621679206408"><span class="annot"><span class="annottext">Int -&gt; Role -&gt; FilePath -&gt; FilePath
[Role] -&gt; FilePath -&gt; FilePath
Role -&gt; FilePath
(Int -&gt; Role -&gt; FilePath -&gt; FilePath)
-&gt; (Role -&gt; FilePath)
-&gt; ([Role] -&gt; FilePath -&gt; FilePath)
-&gt; Show Role
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; Role -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; Role -&gt; FilePath -&gt; FilePath
$cshow :: Role -&gt; FilePath
show :: Role -&gt; FilePath
$cshowList :: [Role] -&gt; FilePath -&gt; FilePath
showList :: [Role] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206411"><span id="local-6989586621679206415"><span class="annot"><span class="annottext">Role -&gt; Role -&gt; Bool
(Role -&gt; Role -&gt; Bool) -&gt; (Role -&gt; Role -&gt; Bool) -&gt; Eq Role
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: Role -&gt; Role -&gt; Bool
== :: Role -&gt; Role -&gt; Bool
$c/= :: Role -&gt; Role -&gt; Bool
/= :: Role -&gt; Role -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206420"><span id="local-6989586621679206424"><span id="local-6989586621679206428"><span id="local-6989586621679206431"><span id="local-6989586621679206434"><span id="local-6989586621679206437"><span id="local-6989586621679206440"><span class="annot"><span class="annottext">Eq Role
Eq Role =&gt;
(Role -&gt; Role -&gt; Ordering)
-&gt; (Role -&gt; Role -&gt; Bool)
-&gt; (Role -&gt; Role -&gt; Bool)
-&gt; (Role -&gt; Role -&gt; Bool)
-&gt; (Role -&gt; Role -&gt; Bool)
-&gt; (Role -&gt; Role -&gt; Role)
-&gt; (Role -&gt; Role -&gt; Role)
-&gt; Ord Role
Role -&gt; Role -&gt; Bool
Role -&gt; Role -&gt; Ordering
Role -&gt; Role -&gt; Role
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: Role -&gt; Role -&gt; Ordering
compare :: Role -&gt; Role -&gt; Ordering
$c&lt; :: Role -&gt; Role -&gt; Bool
&lt; :: Role -&gt; Role -&gt; Bool
$c&lt;= :: Role -&gt; Role -&gt; Bool
&lt;= :: Role -&gt; Role -&gt; Bool
$c&gt; :: Role -&gt; Role -&gt; Bool
&gt; :: Role -&gt; Role -&gt; Bool
$c&gt;= :: Role -&gt; Role -&gt; Bool
&gt;= :: Role -&gt; Role -&gt; Bool
$cmax :: Role -&gt; Role -&gt; Role
max :: Role -&gt; Role -&gt; Role
$cmin :: Role -&gt; Role -&gt; Role
min :: Role -&gt; Role -&gt; Role
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206445"><span id="local-6989586621679206447"><span id="local-6989586621679206449"><span id="local-6989586621679206451"><span id="local-6989586621679206453"><span id="local-6989586621679206458"><span id="local-6989586621679206463"><span id="local-6989586621679206466"><span id="local-6989586621679206469"><span id="local-6989586621679206472"><span id="local-6989586621679206475"><span id="local-6989586621679206478"><span id="local-6989586621679206483"><span id="local-6989586621679206488"><span class="annot"><span class="annottext">Typeable Role
Typeable Role =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Role -&gt; c Role)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Role)
-&gt; (Role -&gt; Constr)
-&gt; (Role -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Role))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Role))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Role -&gt; Role)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Role -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role)
-&gt; Data Role
Role -&gt; Constr
Role -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; Role -&gt; Role
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Role -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Role
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Role -&gt; c Role
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Role)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Role)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Role -&gt; c Role
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Role -&gt; c Role
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Role
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Role
$ctoConstr :: Role -&gt; Constr
toConstr :: Role -&gt; Constr
$cdataTypeOf :: Role -&gt; DataType
dataTypeOf :: Role -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Role)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Role)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Role)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Role)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Role -&gt; Role
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Role -&gt; Role
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Role -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Role -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role -&gt; m Role
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206493"><span id="local-6989586621679206495"><span class="annot"><span class="annottext">(forall x. Role -&gt; Rep Role x)
-&gt; (forall x. Rep Role x -&gt; Role) -&gt; Generic Role
forall x. Rep Role x -&gt; Role
forall x. Role -&gt; Rep Role x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Role -&gt; Rep Role x
from :: forall x. Role -&gt; Rep Role x
$cto :: forall x. Rep Role x -&gt; Role
to :: forall x. Rep Role x -&gt; Role
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2919"></span><span>
</span><span id="line-2920"></span><span class="annot"><span class="hs-comment">-- | Annotation target for reifyAnnotations</span></span><span>
</span><span id="line-2921"></span><span class="hs-keyword">data</span><span> </span><span id="AnnLookup"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnnLookup"><span class="hs-identifier hs-var">AnnLookup</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="AnnLookupModule"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnnLookupModule"><span class="hs-identifier hs-var">AnnLookupModule</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a></span><span>
</span><span id="line-2922"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span id="AnnLookupName"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#AnnLookupName"><span class="hs-identifier hs-var">AnnLookupName</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-2923"></span><span>               </span><span class="hs-keyword">deriving</span><span class="hs-special">(</span><span> </span><span id="local-6989586621679206500"><span id="local-6989586621679206506"><span id="local-6989586621679206510"><span class="annot"><span class="annottext">Int -&gt; AnnLookup -&gt; FilePath -&gt; FilePath
[AnnLookup] -&gt; FilePath -&gt; FilePath
AnnLookup -&gt; FilePath
(Int -&gt; AnnLookup -&gt; FilePath -&gt; FilePath)
-&gt; (AnnLookup -&gt; FilePath)
-&gt; ([AnnLookup] -&gt; FilePath -&gt; FilePath)
-&gt; Show AnnLookup
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; AnnLookup -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; AnnLookup -&gt; FilePath -&gt; FilePath
$cshow :: AnnLookup -&gt; FilePath
show :: AnnLookup -&gt; FilePath
$cshowList :: [AnnLookup] -&gt; FilePath -&gt; FilePath
showList :: [AnnLookup] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206513"><span id="local-6989586621679206519"><span class="annot"><span class="annottext">AnnLookup -&gt; AnnLookup -&gt; Bool
(AnnLookup -&gt; AnnLookup -&gt; Bool)
-&gt; (AnnLookup -&gt; AnnLookup -&gt; Bool) -&gt; Eq AnnLookup
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: AnnLookup -&gt; AnnLookup -&gt; Bool
== :: AnnLookup -&gt; AnnLookup -&gt; Bool
$c/= :: AnnLookup -&gt; AnnLookup -&gt; Bool
/= :: AnnLookup -&gt; AnnLookup -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206525"><span id="local-6989586621679206529"><span id="local-6989586621679206533"><span id="local-6989586621679206537"><span id="local-6989586621679206540"><span id="local-6989586621679206543"><span id="local-6989586621679206546"><span class="annot"><span class="annottext">Eq AnnLookup
Eq AnnLookup =&gt;
(AnnLookup -&gt; AnnLookup -&gt; Ordering)
-&gt; (AnnLookup -&gt; AnnLookup -&gt; Bool)
-&gt; (AnnLookup -&gt; AnnLookup -&gt; Bool)
-&gt; (AnnLookup -&gt; AnnLookup -&gt; Bool)
-&gt; (AnnLookup -&gt; AnnLookup -&gt; Bool)
-&gt; (AnnLookup -&gt; AnnLookup -&gt; AnnLookup)
-&gt; (AnnLookup -&gt; AnnLookup -&gt; AnnLookup)
-&gt; Ord AnnLookup
AnnLookup -&gt; AnnLookup -&gt; Bool
AnnLookup -&gt; AnnLookup -&gt; Ordering
AnnLookup -&gt; AnnLookup -&gt; AnnLookup
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: AnnLookup -&gt; AnnLookup -&gt; Ordering
compare :: AnnLookup -&gt; AnnLookup -&gt; Ordering
$c&lt; :: AnnLookup -&gt; AnnLookup -&gt; Bool
&lt; :: AnnLookup -&gt; AnnLookup -&gt; Bool
$c&lt;= :: AnnLookup -&gt; AnnLookup -&gt; Bool
&lt;= :: AnnLookup -&gt; AnnLookup -&gt; Bool
$c&gt; :: AnnLookup -&gt; AnnLookup -&gt; Bool
&gt; :: AnnLookup -&gt; AnnLookup -&gt; Bool
$c&gt;= :: AnnLookup -&gt; AnnLookup -&gt; Bool
&gt;= :: AnnLookup -&gt; AnnLookup -&gt; Bool
$cmax :: AnnLookup -&gt; AnnLookup -&gt; AnnLookup
max :: AnnLookup -&gt; AnnLookup -&gt; AnnLookup
$cmin :: AnnLookup -&gt; AnnLookup -&gt; AnnLookup
min :: AnnLookup -&gt; AnnLookup -&gt; AnnLookup
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206551"><span id="local-6989586621679206555"><span id="local-6989586621679206559"><span id="local-6989586621679206561"><span id="local-6989586621679206563"><span id="local-6989586621679206569"><span id="local-6989586621679206574"><span id="local-6989586621679206577"><span id="local-6989586621679206580"><span id="local-6989586621679206583"><span id="local-6989586621679206586"><span id="local-6989586621679206589"><span id="local-6989586621679206594"><span id="local-6989586621679206599"><span class="annot"><span class="annottext">Typeable AnnLookup
Typeable AnnLookup =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; AnnLookup -&gt; c AnnLookup)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c AnnLookup)
-&gt; (AnnLookup -&gt; Constr)
-&gt; (AnnLookup -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c AnnLookup))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c AnnLookup))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; AnnLookup -&gt; AnnLookup)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnLookup -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnLookup -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; AnnLookup -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; AnnLookup -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup)
-&gt; Data AnnLookup
AnnLookup -&gt; Constr
AnnLookup -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; AnnLookup -&gt; AnnLookup
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; AnnLookup -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; AnnLookup -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnLookup -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnLookup -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c AnnLookup
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; AnnLookup -&gt; c AnnLookup
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c AnnLookup)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c AnnLookup)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; AnnLookup -&gt; c AnnLookup
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; AnnLookup -&gt; c AnnLookup
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c AnnLookup
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c AnnLookup
$ctoConstr :: AnnLookup -&gt; Constr
toConstr :: AnnLookup -&gt; Constr
$cdataTypeOf :: AnnLookup -&gt; DataType
dataTypeOf :: AnnLookup -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c AnnLookup)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c AnnLookup)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c AnnLookup)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c AnnLookup)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; AnnLookup -&gt; AnnLookup
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; AnnLookup -&gt; AnnLookup
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnLookup -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnLookup -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnLookup -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; AnnLookup -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; AnnLookup -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; AnnLookup -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; AnnLookup -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; AnnLookup -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; AnnLookup -&gt; m AnnLookup
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206604"><span id="local-6989586621679206606"><span class="annot"><span class="annottext">(forall x. AnnLookup -&gt; Rep AnnLookup x)
-&gt; (forall x. Rep AnnLookup x -&gt; AnnLookup) -&gt; Generic AnnLookup
forall x. Rep AnnLookup x -&gt; AnnLookup
forall x. AnnLookup -&gt; Rep AnnLookup x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. AnnLookup -&gt; Rep AnnLookup x
from :: forall x. AnnLookup -&gt; Rep AnnLookup x
$cto :: forall x. Rep AnnLookup x -&gt; AnnLookup
to :: forall x. Rep AnnLookup x -&gt; AnnLookup
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2924"></span><span>
</span><span id="line-2925"></span><span class="hs-comment">-- | To avoid duplication between kinds and types, they</span><span>
</span><span id="line-2926"></span><span class="hs-comment">-- are defined to be the same. Naturally, you would never</span><span>
</span><span id="line-2927"></span><span class="hs-comment">-- have a type be 'StarT' and you would never have a kind</span><span>
</span><span id="line-2928"></span><span class="hs-comment">-- be 'SigT', but many of the other constructors are shared.</span><span>
</span><span id="line-2929"></span><span class="hs-comment">-- Note that the kind @Bool@ is denoted with 'ConT', not</span><span>
</span><span id="line-2930"></span><span class="hs-comment">-- 'PromotedT'. Similarly, tuple kinds are made with 'TupleT',</span><span>
</span><span id="line-2931"></span><span class="hs-comment">-- not 'PromotedTupleT'.</span><span>
</span><span id="line-2932"></span><span>
</span><span id="line-2933"></span><span class="hs-keyword">type</span><span> </span><span id="Kind"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Kind"><span class="hs-identifier hs-var">Kind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-2934"></span><span>
</span><span id="line-2935"></span><span class="hs-comment">{- Note [Representing concrete syntax in types]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Haskell has a rich concrete syntax for types, including
  t1 -&gt; t2, (t1,t2), [t], and so on
In TH we represent all of this using AppT, with a distinguished
type constructor at the head.  So,
  Type              TH representation
  -----------------------------------------------
  t1 -&gt; t2          ArrowT `AppT` t2 `AppT` t2
  [t]               ListT `AppT` t
  (t1,t2)           TupleT 2 `AppT` t1 `AppT` t2
  '(t1,t2)          PromotedTupleT 2 `AppT` t1 `AppT` t2

But if the original HsSyn used prefix application, we won't use
these special TH constructors.  For example
  [] t              ConT &quot;[]&quot; `AppT` t
  (-&gt;) t            ConT &quot;-&gt;&quot; `AppT` t
In this way we can faithfully represent in TH whether the original
HsType used concrete syntax or not.

The one case that doesn't fit this pattern is that of promoted lists
  '[ Maybe, IO ]    PromotedListT 2 `AppT` t1 `AppT` t2
but it's very smelly because there really is no type constructor
corresponding to PromotedListT. So we encode HsExplicitListTy with
PromotedConsT and PromotedNilT (which *do* have underlying type
constructors):
  '[ Maybe, IO ]    PromotedConsT `AppT` Maybe `AppT`
                    (PromotedConsT  `AppT` IO `AppT` PromotedNilT)
-}</span><span>
</span><span id="line-2964"></span><span>
</span><span id="line-2965"></span><span class="hs-comment">-- | A location at which to attach Haddock documentation.</span><span>
</span><span id="line-2966"></span><span class="hs-comment">-- Note that adding documentation to a 'Name' defined oustide of the current</span><span>
</span><span id="line-2967"></span><span class="hs-comment">-- module will cause an error.</span><span>
</span><span id="line-2968"></span><span class="hs-keyword">data</span><span> </span><span id="DocLoc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DocLoc"><span class="hs-identifier hs-var">DocLoc</span></a></span></span><span>
</span><span id="line-2969"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ModuleDoc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ModuleDoc"><span class="hs-identifier hs-var">ModuleDoc</span></a></span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ At the current module's header.</span></span><span>
</span><span id="line-2970"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DeclDoc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#DeclDoc"><span class="hs-identifier hs-var">DeclDoc</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ At a declaration, not necessarily top level.</span></span><span>
</span><span id="line-2971"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArgDoc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ArgDoc"><span class="hs-identifier hs-var">ArgDoc</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>   </span><span class="hs-comment">-- ^ At a specific argument of a function, indexed by its</span><span>
</span><span id="line-2972"></span><span>                      </span><span class="hs-comment">-- position.</span><span>
</span><span id="line-2973"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InstDoc"><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InstDoc"><span class="hs-identifier hs-var">InstDoc</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>      </span><span class="annot"><span class="hs-comment">-- ^ At a class or family instance.</span></span><span>
</span><span id="line-2974"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span> </span><span id="local-6989586621679206613"><span id="local-6989586621679206622"><span id="local-6989586621679206626"><span class="annot"><span class="annottext">Int -&gt; DocLoc -&gt; FilePath -&gt; FilePath
[DocLoc] -&gt; FilePath -&gt; FilePath
DocLoc -&gt; FilePath
(Int -&gt; DocLoc -&gt; FilePath -&gt; FilePath)
-&gt; (DocLoc -&gt; FilePath)
-&gt; ([DocLoc] -&gt; FilePath -&gt; FilePath)
-&gt; Show DocLoc
forall a.
(Int -&gt; a -&gt; FilePath -&gt; FilePath)
-&gt; (a -&gt; FilePath) -&gt; ([a] -&gt; FilePath -&gt; FilePath) -&gt; Show a
$cshowsPrec :: Int -&gt; DocLoc -&gt; FilePath -&gt; FilePath
showsPrec :: Int -&gt; DocLoc -&gt; FilePath -&gt; FilePath
$cshow :: DocLoc -&gt; FilePath
show :: DocLoc -&gt; FilePath
$cshowList :: [DocLoc] -&gt; FilePath -&gt; FilePath
showList :: [DocLoc] -&gt; FilePath -&gt; FilePath
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206629"><span id="local-6989586621679206637"><span class="annot"><span class="annottext">DocLoc -&gt; DocLoc -&gt; Bool
(DocLoc -&gt; DocLoc -&gt; Bool)
-&gt; (DocLoc -&gt; DocLoc -&gt; Bool) -&gt; Eq DocLoc
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: DocLoc -&gt; DocLoc -&gt; Bool
== :: DocLoc -&gt; DocLoc -&gt; Bool
$c/= :: DocLoc -&gt; DocLoc -&gt; Bool
/= :: DocLoc -&gt; DocLoc -&gt; Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Eq"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206643"><span id="local-6989586621679206649"><span id="local-6989586621679206653"><span id="local-6989586621679206656"><span id="local-6989586621679206659"><span id="local-6989586621679206662"><span id="local-6989586621679206665"><span class="annot"><span class="annottext">Eq DocLoc
Eq DocLoc =&gt;
(DocLoc -&gt; DocLoc -&gt; Ordering)
-&gt; (DocLoc -&gt; DocLoc -&gt; Bool)
-&gt; (DocLoc -&gt; DocLoc -&gt; Bool)
-&gt; (DocLoc -&gt; DocLoc -&gt; Bool)
-&gt; (DocLoc -&gt; DocLoc -&gt; Bool)
-&gt; (DocLoc -&gt; DocLoc -&gt; DocLoc)
-&gt; (DocLoc -&gt; DocLoc -&gt; DocLoc)
-&gt; Ord DocLoc
DocLoc -&gt; DocLoc -&gt; Bool
DocLoc -&gt; DocLoc -&gt; Ordering
DocLoc -&gt; DocLoc -&gt; DocLoc
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
$ccompare :: DocLoc -&gt; DocLoc -&gt; Ordering
compare :: DocLoc -&gt; DocLoc -&gt; Ordering
$c&lt; :: DocLoc -&gt; DocLoc -&gt; Bool
&lt; :: DocLoc -&gt; DocLoc -&gt; Bool
$c&lt;= :: DocLoc -&gt; DocLoc -&gt; Bool
&lt;= :: DocLoc -&gt; DocLoc -&gt; Bool
$c&gt; :: DocLoc -&gt; DocLoc -&gt; Bool
&gt; :: DocLoc -&gt; DocLoc -&gt; Bool
$c&gt;= :: DocLoc -&gt; DocLoc -&gt; Bool
&gt;= :: DocLoc -&gt; DocLoc -&gt; Bool
$cmax :: DocLoc -&gt; DocLoc -&gt; DocLoc
max :: DocLoc -&gt; DocLoc -&gt; DocLoc
$cmin :: DocLoc -&gt; DocLoc -&gt; DocLoc
min :: DocLoc -&gt; DocLoc -&gt; DocLoc
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Classes.html#Ord"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></a></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206670"><span id="local-6989586621679206676"><span id="local-6989586621679206682"><span id="local-6989586621679206684"><span id="local-6989586621679206686"><span id="local-6989586621679206692"><span id="local-6989586621679206697"><span id="local-6989586621679206700"><span id="local-6989586621679206703"><span id="local-6989586621679206706"><span id="local-6989586621679206709"><span id="local-6989586621679206712"><span id="local-6989586621679206717"><span id="local-6989586621679206722"><span class="annot"><span class="annottext">Typeable DocLoc
Typeable DocLoc =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; DocLoc -&gt; c DocLoc)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DocLoc)
-&gt; (DocLoc -&gt; Constr)
-&gt; (DocLoc -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DocLoc))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DocLoc))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DocLoc -&gt; DocLoc)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DocLoc -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DocLoc -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DocLoc -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DocLoc -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc)
-&gt; Data DocLoc
DocLoc -&gt; Constr
DocLoc -&gt; DataType
(forall b. Data b =&gt; b -&gt; b) -&gt; DocLoc -&gt; DocLoc
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DocLoc -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DocLoc -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DocLoc -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DocLoc -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DocLoc
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DocLoc -&gt; c DocLoc
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DocLoc)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DocLoc)
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DocLoc -&gt; c DocLoc
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DocLoc -&gt; c DocLoc
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DocLoc
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DocLoc
$ctoConstr :: DocLoc -&gt; Constr
toConstr :: DocLoc -&gt; Constr
$cdataTypeOf :: DocLoc -&gt; DataType
dataTypeOf :: DocLoc -&gt; DataType
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DocLoc)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DocLoc)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DocLoc)
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c DocLoc)
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DocLoc -&gt; DocLoc
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DocLoc -&gt; DocLoc
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DocLoc -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DocLoc -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DocLoc -&gt; r
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DocLoc -&gt; r
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DocLoc -&gt; [u]
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DocLoc -&gt; [u]
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DocLoc -&gt; u
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DocLoc -&gt; u
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DocLoc -&gt; m DocLoc
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679206727"><span id="local-6989586621679206729"><span class="annot"><span class="annottext">(forall x. DocLoc -&gt; Rep DocLoc x)
-&gt; (forall x. Rep DocLoc x -&gt; DocLoc) -&gt; Generic DocLoc
forall x. Rep DocLoc x -&gt; DocLoc
forall x. DocLoc -&gt; Rep DocLoc x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. DocLoc -&gt; Rep DocLoc x
from :: forall x. DocLoc -&gt; Rep DocLoc x
$cto :: forall x. Rep DocLoc x -&gt; DocLoc
to :: forall x. Rep DocLoc x -&gt; DocLoc
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-2975"></span><span>
</span><span id="line-2976"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-2977"></span><span class="hs-comment">--              Internal helper functions</span><span>
</span><span id="line-2978"></span><span class="hs-comment">-----------------------------------------------------</span><span>
</span><span id="line-2979"></span><span>
</span><span id="line-2980"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#cmpEq"><span class="hs-identifier hs-type">cmpEq</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Ordering"><span class="hs-identifier hs-type">Ordering</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span>
</span><span id="line-2981"></span><span id="cmpEq"><span class="annot"><span class="annottext">cmpEq :: Ordering -&gt; Bool
</span><a href="Language.Haskell.TH.Syntax.html#cmpEq"><span class="hs-identifier hs-var hs-var">cmpEq</span></a></span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#EQ"><span class="hs-identifier hs-var">EQ</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-2982"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#cmpEq"><span class="hs-identifier hs-var">cmpEq</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-2983"></span><span>
</span><span id="line-2984"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#thenCmp"><span class="hs-identifier hs-type">thenCmp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Ordering"><span class="hs-identifier hs-type">Ordering</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Ordering"><span class="hs-identifier hs-type">Ordering</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#Ordering"><span class="hs-identifier hs-type">Ordering</span></a></span><span>
</span><span id="line-2985"></span><span id="thenCmp"><span class="annot"><span class="annottext">thenCmp :: Ordering -&gt; Ordering -&gt; Ordering
</span><a href="Language.Haskell.TH.Syntax.html#thenCmp"><span class="hs-identifier hs-var hs-var">thenCmp</span></a></span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="../../ghc-prim-0.12.0-inplace/src/GHC.Types.html#EQ"><span class="hs-identifier hs-var">EQ</span></a></span><span> </span><span id="local-6989586621679206732"><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679206732"><span class="hs-identifier hs-var">o2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679206732"><span class="hs-identifier hs-var">o2</span></a></span><span>
</span><span id="line-2986"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#thenCmp"><span class="hs-identifier hs-var">thenCmp</span></a></span><span> </span><span id="local-6989586621679206733"><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679206733"><span class="hs-identifier hs-var">o1</span></a></span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679206733"><span class="hs-identifier hs-var">o1</span></a></span><span>
</span><span id="line-2987"></span><span>
</span><span id="line-2988"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#get_cons_names"><span class="hs-identifier hs-type">get_cons_names</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2989"></span><span id="get_cons_names"><span class="annot"><span class="annottext">get_cons_names :: Con -&gt; [Name]
</span><a href="Language.Haskell.TH.Syntax.html#get_cons_names"><span class="hs-identifier hs-var hs-var">get_cons_names</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#NormalC"><span class="hs-identifier hs-type">NormalC</span></a></span><span> </span><span id="local-6989586621679206735"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679206735"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="annot"><span class="annottext">[BangType]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679206735"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2990"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#get_cons_names"><span class="hs-identifier hs-var">get_cons_names</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecC"><span class="hs-identifier hs-type">RecC</span></a></span><span> </span><span id="local-6989586621679206736"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679206736"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679206736"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2991"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#get_cons_names"><span class="hs-identifier hs-var">get_cons_names</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#InfixC"><span class="hs-identifier hs-type">InfixC</span></a></span><span> </span><span class="annot"><span class="annottext">BangType
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679206737"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679206737"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="annot"><span class="annottext">BangType
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679206737"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2992"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#get_cons_names"><span class="hs-identifier hs-var">get_cons_names</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#ForallC"><span class="hs-identifier hs-type">ForallC</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr Specificity]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679206738"><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679206738"><span class="hs-identifier hs-var">con</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Con -&gt; [Name]
</span><a href="Language.Haskell.TH.Syntax.html#get_cons_names"><span class="hs-identifier hs-var">get_cons_names</span></a></span><span> </span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679206738"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-2993"></span><span class="hs-comment">-- GadtC can have multiple names, e.g</span><span>
</span><span id="line-2994"></span><span class="hs-comment">-- &gt; data Bar a where</span><span>
</span><span id="line-2995"></span><span class="hs-comment">-- &gt;   MkBar1, MkBar2 :: a -&gt; Bar a</span><span>
</span><span id="line-2996"></span><span class="hs-comment">-- Will have one GadtC with [MkBar1, MkBar2] as names</span><span>
</span><span id="line-2997"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#get_cons_names"><span class="hs-identifier hs-var">get_cons_names</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#GadtC"><span class="hs-identifier hs-type">GadtC</span></a></span><span> </span><span id="local-6989586621679206739"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679206739"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span class="annot"><span class="annottext">[BangType]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679206739"><span class="hs-identifier hs-var">ns</span></a></span><span>
</span><span id="line-2998"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#get_cons_names"><span class="hs-identifier hs-var">get_cons_names</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.html#RecGadtC"><span class="hs-identifier hs-type">RecGadtC</span></a></span><span> </span><span id="local-6989586621679206740"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679206740"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679206740"><span class="hs-identifier hs-var">ns</span></a></span><span>
</span><span id="line-2999"></span></pre></body></html>